/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void sub_180001000();
void GetVolumesInformation();
void __fastcall sub_180001490(__int64 a1, __int64 a2);
BOOLEAN __fastcall sub_180001580(PCUNICODE_STRING Source, PUNICODE_STRING Destination);
LONG __fastcall sub_180001690(__int64 a1);
NTSTATUS __fastcall sub_180001760(ULONG *a1);
__int64 sub_1800017F0();
bool __fastcall GetRegistryValue(struct _UNICODE_STRING *a1, _DWORD *a2, _DWORD *a3);
void __fastcall sub_180001B10(struct _UNICODE_STRING *a1);
void sub_180001C20();
__int64 sub_180001C70();
void __fastcall sub_180001CD0(void *a1);
void __fastcall DeferredRoutine(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);
_BOOL8 __fastcall IntializeLogger(_QWORD *a1);
char CloseDeviceAndLogging();
void __fastcall sub_180001FD0(char a1);
__int64 __fastcall sub_180002000(__int64 a1, IRP *a2);
__int64 __fastcall sub_180002030(struct _DEVICE_OBJECT *a1, __int64 a2);
__int64 __fastcall sub_180002290(PFLT_CALLBACK_DATA CallbackData, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_180002700(int *a1, __int64 a2, __int64 a3, char a4);
__int64 sub_180002870();
__int64 __fastcall ConnectNotifyCallback(PFLT_PORT ClientPort, PVOID ServerPortCookie, _DWORD *ConnectionContext, ULONG SizeOfContext, PVOID *ConnectionPortCookie);
void __fastcall sub_180002930(char a1, struct _KTHREAD *a2, char a3, _OWORD *a4, char *VirtualAddress, ULONG *a6);
void __fastcall DisconnectNotifyCallback(PFLT_PORT *ConnectionCookie, __int64 a2, __int64 a3);
__int64 __fastcall sub_180002BA0(char a1);
bool __fastcall sub_180002CE0(struct _UNICODE_STRING *a1);
_OWORD *__fastcall sub_180002D80(struct _KTHREAD *a1, unsigned __int8 a2, char a3, __int64 a4, int *a5, ULONG *a6);
_OWORD *__fastcall sub_180003060(__int64 a1, __int64 a2, unsigned int *a3);
__int64 __fastcall DriverStartUp(PDRIVER_OBJECT Driver); // idb
__int64 sub_180003630();
struct _UNICODE_STRING *__fastcall sub_180003640(__int64 a1);
__int64 __fastcall MessageNotifyCallback(PVOID PortCookie, char *InputBuffer, __int64 InputBufferLength, PVOID OutputBuffer);
__int64 __fastcall sub_180003720(struct _KTHREAD *a1, unsigned __int8 a2, int *a3, __int64 a4, int a5, __int64 a6, char a7);
void __fastcall sub_1800037C0(__int64 a1);
NTSTATUS __fastcall sub_180003810(PVOID SenderBuffer, ULONG SenderBufferLength, PVOID ReplyBuffer, PULONG ReplyLength);
NTSTATUS __fastcall sub_180003850(PVOID SenderBuffer, ULONG SenderBufferLength);
__int64 __fastcall sub_180003890(char a1, PVOID *a2, unsigned __int16 a3);
void sub_180003A60();
void sub_180003B40();
void __fastcall sub_180003B80(char a1);
__int64 __fastcall sub_180003C90(unsigned __int8 a1, __int16 a2, int a3, int a4, int a5, PSLIST_ENTRY *a6);
__int64 __fastcall sub_180003D20(int a1, int a2, int a3, PSLIST_ENTRY *a4);
__int64 __fastcall sub_180003D60(char a1, unsigned __int8 a2, __int16 a3, int a4, int a5, int a6, _DWORD *a7, PSLIST_ENTRY *a8);
__int64 __fastcall sub_180003E30(unsigned __int8 a1, __int16 a2, int a3, int a4, int a5, PSLIST_ENTRY *a6, unsigned __int16 a7, char *a8);
LONGLONG sub_180004080();
__int64 DriverKeInitialize();
__int64 __fastcall sub_180004350(void (__fastcall *a1)(__int64, _QWORD));
void __fastcall sub_180004460(__int64 a1);
LONG __fastcall sub_180004500(__int64 (*a1)(void));
void __fastcall StartRoutine(PVOID StartContext);
void __fastcall sub_180004580(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);
_OWORD *__fastcall sub_1800045A0(__int64 a1, __int64 a2, char a3);
void __fastcall sub_180004620(__int64 a1);
__int64 *__fastcall sub_1800046B0(__int64 a1, char a2);
__int64 *__fastcall sub_180004830(__int64 a1);
__int64 __fastcall sub_1800048B0(char a1, PVOID *a2, _OWORD *a3, _OWORD *a4);
void __fastcall sub_180004A30(void *a1);
void __fastcall sub_180004A40(__int64 a1, __int64 a2, __int64 a3);
void __fastcall sub_180004B60(int a1, unsigned __int16 *a2, __int64 a3, int a4, unsigned __int16 a5, char *a6);
void __fastcall sub_180004C00(PCUNICODE_STRING SourceString, __int64 a2, __int64 a3);
void __fastcall sub_180004ED0(__int64 a1);
__int64 __fastcall sub_180005940(char a1, __int64 a2, __int64 a3);
LONG __fastcall sub_180005D10(__int64 a1);
PVOID __fastcall sub_180005D50(HANDLE TokenHandle, PVOID TokenInformation, _DWORD *a3, PVOID *a4);
HANDLE DriverKeInitialize2();
void __fastcall sub_180006150(__int64 ParentId, __int64 ProcessId, char Create);
void __fastcall sub_180006160(__int64 a1, __int64 a2, char a3, __int64 a4);
void __fastcall sub_180006400(__int64 a1, __int64 a2, __int64 a3);
void *__fastcall sub_180006430(char a1);
void __fastcall sub_1800064D0(bool a1);
bool __fastcall sub_180006820(void *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, _QWORD *a7, _DWORD *a8);
void __fastcall sub_180006B20(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);
void __fastcall sub_180006B70(PVOID P);
void sub_180006CD0();
void __fastcall sub_180006F10(PVOID StartContext);
void __fastcall NotifyRoutine(HANDLE ProcessId, HANDLE ThreadId, BOOLEAN Create);
void __fastcall sub_180007250(PSLIST_ENTRY ListEntry, _QWORD *a2);
BOOLEAN __fastcall sub_180007380(__int64 a1);
NTSTATUS __fastcall sub_1800073E0(__int64 a1, int a2, int a3, int a4);
void __fastcall sub_180007630(PVOID StartContext);
__int64 __fastcall DriverInitialize(PDRIVER_OBJECT Driver, struct _UNICODE_STRING *a2);
PVOID __fastcall DriverAllocateWithTag(POOL_TYPE a1, unsigned int a2, char a3);
struct _UNICODE_STRING *__fastcall sub_1800078F0(POOL_TYPE a1, const UNICODE_STRING *a2, char a3);
void __fastcall sub_180007950(int a1, __int64 a2, __int64 a3);
UNICODE_STRING *__fastcall sub_1800079B0(char a1, void *a2, const UNICODE_STRING *a3);
int __fastcall sub_180007D00(int a1, struct _SLIST_ENTRY *a2);
__int64 __fastcall sub_180007DE0(__int64 a1, int a2, __int64 a3);
__int64 __fastcall sub_1800085B0(int a1);
PSLIST_ENTRY __fastcall sub_1800087B0(struct _SLIST_ENTRY *a1);
__int16 __fastcall sub_180008800(int a1, __int64 a2, unsigned int a3);
unsigned __int16 __fastcall sub_180008880(int a1, __int64 a2, __int64 a3, _QWORD *a4);
void DriverKeInitialize3();
__int64 __fastcall sub_180008AB0(char *a1, unsigned __int16 a2, _QWORD *a3);
__int64 sub_180008B40();
void __fastcall sub_180008BE0(int a1, int a2, int a3, __int64 a4, unsigned int *a5);
void __fastcall sub_180008CB0(int a1, int a2, __int64 a3, char *a4, unsigned __int16 *a5);
__int64 __fastcall sub_180008D90(void *a1, void *a2, unsigned __int8 a3, unsigned int a4);
__int64 __fastcall sub_180008DF0(HANDLE Handle, void *a2, const UNICODE_STRING *a3);
__int64 __fastcall sub_180009010(HANDLE Handle, void *a2, int a3, int a4, int a5);
__int64 __fastcall sub_180009240(HANDLE Handle, void *a2, int a3, int a4, int a5);
_WORD *__fastcall sub_180009470(HANDLE Handle, void *a2, const UNICODE_STRING *a3, unsigned __int8 a4, unsigned int a5, int a6, PSLIST_ENTRY *Object, _DWORD *a8);
__int64 __fastcall sub_1800097D0(void *a1, const UNICODE_STRING *a2, unsigned __int16 *a3);
__int64 __fastcall sub_180009910(__int16 a1, int a2, volatile void *a3, void *a4, const UNICODE_STRING *a5);
__int64 __fastcall sub_180009AE0(HANDLE Handle, void *a2, int a3, int a4);
__int64 __fastcall sub_180009D10(HANDLE Handle, void *a2, const UNICODE_STRING *a3, int a4, int a5, int a6);
__int64 __fastcall sub_180009F40(HANDLE Handle, void *a2, unsigned __int16 *a3);
__int64 __fastcall sub_18000A1C0(HANDLE Handle, void *a2, int a3, char *a4, int a5);
__int64 __fastcall sub_18000A480(HANDLE Handle, void *a2, const UNICODE_STRING *a3, __int64 a4, int a5, char *a6, int a7);
__int64 __fastcall sub_18000A740(UNICODE_STRING *P, void *a2);
char __fastcall sub_18000A830(volatile void *Address, _QWORD *a2, volatile void **a3);
char __fastcall sub_18000A8B0(_OWORD *Address, volatile void **a2);
__int64 __fastcall sub_18000A920(__int64 a1, __int64 a2);
__int64 sub_18000A970();
__int64 __fastcall sub_18000AA38(__int64 a1, __int64 a2);
// int __cdecl wcsnicmp(const wchar_t *Str1, const wchar_t *Str2, size_t MaxCount);
// wchar_t *__cdecl wcschr(const wchar_t *Str, wchar_t Ch);
void __fastcall __noreturn sub_18000AAA4(ULONG_PTR BugCheckParameter1); // idb
// NTSTATUS __stdcall FltGetVolumeName(PFLT_VOLUME Volume, PUNICODE_STRING VolumeName, PULONG BufferSizeNeeded);
// NTSTATUS __stdcall FltGetDiskDeviceObject(PFLT_VOLUME Volume, PDEVICE_OBJECT *DiskDeviceObject);
// NTSTATUS __stdcall FltEnumerateVolumes(PFLT_FILTER Filter, PFLT_VOLUME *VolumeList, ULONG VolumeListSize, PULONG NumberVolumesReturned);
// void __stdcall FltObjectDereference(PVOID FltObject);
// NTSTATUS __stdcall FltRegisterFilter(PDRIVER_OBJECT Driver, const FLT_REGISTRATION *Registration, PFLT_FILTER *RetFilter);
// void __stdcall FltUnregisterFilter(PFLT_FILTER Filter);
// NTSTATUS __stdcall FltStartFiltering(PFLT_FILTER Filter);
// NTSTATUS __stdcall FltGetFileNameInformation(PFLT_CALLBACK_DATA CallbackData, FLT_FILE_NAME_OPTIONS NameOptions, PFLT_FILE_NAME_INFORMATION *FileNameInformation);
// void __stdcall FltReleaseFileNameInformation(PFLT_FILE_NAME_INFORMATION FileNameInformation);
// NTSTATUS __stdcall FltGetDestinationFileNameInformation(PFLT_INSTANCE Instance, PFILE_OBJECT FileObject, HANDLE RootDirectory, PWSTR FileName, ULONG FileNameLength, FLT_FILE_NAME_OPTIONS NameOptions, PFLT_FILE_NAME_INFORMATION *RetFileNameInformation);
// NTSTATUS __stdcall FltAttachVolume(PFLT_FILTER Filter, PFLT_VOLUME Volume, PCUNICODE_STRING InstanceName, PFLT_INSTANCE *RetInstance);
// NTSTATUS __stdcall FltDetachVolume(PFLT_FILTER Filter, PFLT_VOLUME Volume, PCUNICODE_STRING InstanceName);
// NTSTATUS __stdcall FltCreateFile(PFLT_FILTER Filter, PFLT_INSTANCE Instance, PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength, ULONG Flags);
// NTSTATUS __stdcall FltClose(HANDLE FileHandle);
// NTSTATUS __stdcall FltCreateCommunicationPort(PFLT_FILTER Filter, PFLT_PORT *ServerPort, POBJECT_ATTRIBUTES ObjectAttributes, PVOID ServerPortCookie, PFLT_CONNECT_NOTIFY ConnectNotifyCallback, PFLT_DISCONNECT_NOTIFY DisconnectNotifyCallback, PFLT_MESSAGE_NOTIFY MessageNotifyCallback, LONG MaxConnections);
// void __stdcall FltCloseCommunicationPort(PFLT_PORT ServerPort);
// void __stdcall FltCloseClientPort(PFLT_FILTER Filter, PFLT_PORT *ClientPort);
// NTSTATUS __stdcall FltSendMessage(PFLT_FILTER Filter, PFLT_PORT *ClientPort, PVOID SenderBuffer, ULONG SenderBufferLength, PVOID ReplyBuffer, PULONG ReplyLength, PLARGE_INTEGER Timeout);
// NTSTATUS __stdcall FltBuildDefaultSecurityDescriptor(PSECURITY_DESCRIPTOR *SecurityDescriptor, ACCESS_MASK DesiredAccess);
// void __stdcall FltFreeSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor);
// NTSTATUS __stdcall FltGetFileNameInformationUnsafe(PFILE_OBJECT FileObject, PFLT_INSTANCE Instance, FLT_FILE_NAME_OPTIONS NameOptions, PFLT_FILE_NAME_INFORMATION *FileNameInformation);
__m128 *__fastcall sub_18000AC00(_OWORD *a1, char *a2, unsigned __int64 a3);
__int64 __fastcall sub_18000AEC0(char *a1, unsigned __int8 a2, unsigned __int64 a3);
__int64 __fastcall sub_18000B000(_OWORD *a1, __int64 a2, __int64 a3);
void sub_18000B080();
// __int64 __fastcall KeInsertQueueApc(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall KeInitializeApc(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD); weak
// __int64 __fastcall SeCaptureSecurityDescriptor(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
PVOID sub_180012000();
__int64 __fastcall CreateSercuredDeviceAndControlAccess(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4, int a5, char a6, __int64 a7, __int64 a8, __int64 a9);
__int64 __fastcall sub_180012124(PDRIVER_OBJECT DriverObject, ULONG a2, struct _UNICODE_STRING *a3, ULONG a4, int a5, char a6, unsigned __int16 *a7, __int64 a8, PDEVICE_OBJECT DeviceObject);
NTSTATUS __fastcall sub_1800122B4(PVOID Object, PSECURITY_DESCRIPTOR *a2);
int __fastcall sub_180012374(char a1, int *a2);
NTSTATUS __fastcall sub_18001239C(PSECURITY_DESCRIPTOR SecurityDescriptor, unsigned __int8 *a2, _DWORD *a3);
// __int64 __fastcall PiRegStateOpenClassKey(_DWORD, _DWORD, _DWORD, _DWORD, __int64); weak
__int64 __fastcall sub_180012620(void *a1, __int64 a2);
void __fastcall sub_1800127E8(__int64 a1);
// __int64 __fastcall unknown_libname_1(_QWORD); weak
// __int64 __fastcall PpRegStateLoadSecurityDescriptor(_QWORD, _QWORD); weak
__int64 __fastcall sub_180012828(int a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_180012964(int a1, __int64 a2);
__int64 __fastcall sub_180012AB0(unsigned __int16 *a1, int a2, _QWORD *a3);
NTSTATUS __fastcall sub_180012B90(char **a1, _DWORD *a2, __int64 a3, __int64 a4, ACCESS_MASK AccessMask, int a6, PSID Sid);
__int64 __fastcall sub_180012C88(_WORD *a1, int a2, int *a3, PVOID *a4);
__int64 __fastcall sub_180012D74(wchar_t *Str1, char **a2, wchar_t **a3);
__int64 __fastcall sub_18001312C(wchar_t *Str1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall sub_1800131F4(wchar_t *Str1, _DWORD *a2, _QWORD *a3);
__int64 __fastcall sub_180013280(unsigned __int16 *a1, unsigned __int16 **a2, unsigned int *a3);
__int64 __fastcall sub_180013384(_WORD *a1, int a2, __int64 a3);
__int64 __fastcall sub_180013530(void *a1, struct _UNICODE_STRING *a2, ACCESS_MASK a3, ULONG CreateOptions, void *a5, ULONG *a6, _QWORD *a7);
__int64 __fastcall sub_1800135D0(void *a1, __int64 a2, ACCESS_MASK a3, ULONG a4, void *a5, ULONG *a6, _QWORD *a7);
NTSTATUS __fastcall sub_180013648(void *a1, struct _UNICODE_STRING *a2, ACCESS_MASK a3, void **a4);
NTSTATUS __fastcall sub_1800136B8(void *a1, __int64 a2, ACCESS_MASK a3, void **a4);
NTSTATUS __fastcall sub_18001370C(void *a1, struct _UNICODE_STRING *a2, int a3, _DWORD *a4);
__int64 __fastcall sub_18001378C(HANDLE KeyHandle, PUNICODE_STRING ValueName, int a3, int a4, char **a5);
__int64 __fastcall sub_180013918(HANDLE KeyHandle, PUNICODE_STRING ValueName, unsigned __int16 *a3);
NTSTATUS __fastcall sub_180013A2C(void *a1, __int64 a2, int a3, _DWORD *a4);
__int64 __fastcall sub_180013A80(HANDLE KeyHandle, __int64 a2, int a3, int a4, char **a5);
NTSTATUS __fastcall sub_180013ADC(HANDLE KeyHandle, __int64 a2, ULONG a3, void *a4, ULONG DataSize);
__int64 __fastcall sub_180013B44(HANDLE KeyHandle, __int64 a2, unsigned __int16 *a3);
__int64 __fastcall sub_180013B88(HANDLE KeyHandle, __int64 a2, __int64 a3);
__int64 __fastcall sub_180013BE8(__int64 a1, unsigned __int16 a2);
NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
// void __cdecl _security_init_cookie();

//-------------------------------------------------------------------------
// Data declarations

// extern LARGE_INTEGER (__stdcall *KeQueryPerformanceCounter)(PLARGE_INTEGER PerformanceFrequency);
// extern NTSTATUS (__stdcall *ZwFlushKey)(HANDLE KeyHandle);
// extern NTSTATUS (__stdcall *ZwQueryValueKey)(HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);
// extern NTSTATUS (__stdcall *ZwSetValueKey)(HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);
// extern HANDLE (*PsGetCurrentProcessId)(void);
// extern BOOLEAN (__stdcall *IoSetThreadHardErrorMode)(BOOLEAN EnableHardErrors);
// extern NTSTATUS (__stdcall *ZwQuerySystemInformation)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
// extern void (__stdcall *KeClearEvent)(PRKEVENT Event);
// extern void (__stdcall *IofCompleteRequest)(PIRP Irp, CCHAR PriorityBoost);
// extern PKEVENT (__stdcall *IoCreateNotificationEvent)(PUNICODE_STRING EventName, PHANDLE EventHandle);
// extern NTSTATUS (__stdcall *IoCreateSymbolicLink)(PUNICODE_STRING SymbolicLinkName, PUNICODE_STRING DeviceName);
// extern void (__stdcall *IoDeleteDevice)(PDEVICE_OBJECT DeviceObject);
// extern NTSTATUS (__stdcall *IoDeleteSymbolicLink)(PUNICODE_STRING SymbolicLinkName);
// extern KIRQL (*KeGetCurrentIrql)(void);
// extern NTSTATUS (__stdcall *KeDelayExecutionThread)(KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Interval);
// extern void (__stdcall *KeInitializeSpinLock)(PKSPIN_LOCK SpinLock);
// extern KIRQL (__stdcall *KeAcquireSpinLockRaiseToDpc)(PKSPIN_LOCK SpinLock);
// extern void (__stdcall *KeReleaseSpinLock)(PKSPIN_LOCK SpinLock, KIRQL NewIrql);
// extern void (__stdcall *MmProbeAndLockProcessPages)(PMDL MemoryDescriptorList, PEPROCESS Process, KPROCESSOR_MODE AccessMode, LOCK_OPERATION Operation);
// extern void (__stdcall *MmUnlockPages)(PMDL MemoryDescriptorList);
// extern PVOID (__stdcall *MmMapLockedPagesSpecifyCache)(PMDL MemoryDescriptorList, KPROCESSOR_MODE AccessMode, MEMORY_CACHING_TYPE CacheType, PVOID RequestedAddress, ULONG BugCheckOnFailure, ULONG Priority);
// extern PMDL (__stdcall *IoAllocateMdl)(PVOID VirtualAddress, ULONG Length, BOOLEAN SecondaryBuffer, BOOLEAN ChargeQuota, PIRP Irp);
// extern void (__stdcall *IoFreeMdl)(PMDL Mdl);
// extern PEPROCESS (*IoGetCurrentProcess)(void);
// extern PIRP (*IoGetTopLevelIrp)(void);
// extern void (__stdcall *IoSetTopLevelIrp)(PIRP Irp);
// extern ULONG (__stdcall *RtlLengthSid)(PSID Sid);
// extern PEPROCESS (__stdcall *IoThreadToProcess)(PETHREAD Thread);
// extern LOGICAL (__stdcall *FsRtlIsPagingFile)(PFILE_OBJECT FileObject);
// extern BOOLEAN (__stdcall *KeCancelTimer)(PKTIMER);
// extern USHORT (__stdcall *ExQueryDepthSList)(PSLIST_HEADER SListHead);
// extern PSLIST_ENTRY (__stdcall *ExpInterlockedPopEntrySList)(PSLIST_HEADER ListHead);
// extern PSLIST_ENTRY (__stdcall *ExpInterlockedPushEntrySList)(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry);
// extern void (__stdcall *ExInitializeNPagedLookasideList)(PNPAGED_LOOKASIDE_LIST Lookaside, PALLOCATE_FUNCTION Allocate, PFREE_FUNCTION Free, ULONG Flags, SIZE_T Size, ULONG Tag, USHORT Depth);
// extern NTSTATUS (__stdcall *PsCreateSystemThread)(PHANDLE ThreadHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PKSTART_ROUTINE StartRoutine, PVOID StartContext);
// extern void (__stdcall *IoGetStackLimits)(PULONG_PTR LowLimit, PULONG_PTR HighLimit);
// extern ULONG (__stdcall *RtlWalkFrameChain)(PVOID *Callers, ULONG Count, ULONG Flags);
// extern HANDLE (*PsGetCurrentThreadId)(void);
// extern int (__cdecl *strncmp)(const char *Str1, const char *Str2, size_t MaxCount);
// extern char *(__cdecl *strncpy)(char *Dest, const char *Source, size_t Count);
// extern PVOID (__stdcall *MmGetSystemRoutineAddress)(PUNICODE_STRING SystemRoutineName);
// extern LONG (__stdcall *KeResetEvent)(PRKEVENT Event);
// extern void (__stdcall *KeInitializeTimerEx)(PKTIMER Timer, TIMER_TYPE Type);
// extern BOOLEAN (__stdcall *KeSetTimerEx)(PKTIMER Timer, LARGE_INTEGER DueTime, LONG Period, PKDPC Dpc);
// extern NTSTATUS (__stdcall *KeWaitForMultipleObjects)(ULONG Count, PVOID Object[], WAIT_TYPE WaitType, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PKWAIT_BLOCK WaitBlockArray);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER SListHead);
// extern NTSTATUS (__stdcall *ObReferenceObjectByHandle)(HANDLE Handle, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID *Object, POBJECT_HANDLE_INFORMATION HandleInformation);
// extern NTSTATUS (__stdcall *ZwClose)(HANDLE Handle);
// extern NTSTATUS (__stdcall *PsSetCreateThreadNotifyRoutine)(PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine);
// extern NTSTATUS (__stdcall *PsRemoveCreateThreadNotifyRoutine)(PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine);
// extern NTSTATUS (__stdcall *PsSetLoadImageNotifyRoutine)(PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine);
// extern NTSTATUS (__stdcall *PsRemoveLoadImageNotifyRoutine)(PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine);
// extern NTSTATUS (__stdcall *ZwOpenProcess)(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);
// extern void (__stdcall *KeStackAttachProcess)(PRKPROCESS PROCESS, PRKAPC_STATE ApcState);
// extern void (__stdcall *KeUnstackDetachProcess)(PRKAPC_STATE ApcState);
// extern PACCESS_TOKEN (__stdcall *PsReferencePrimaryToken)(PEPROCESS Process);
// extern PACCESS_TOKEN (__stdcall *PsReferenceImpersonationToken)(PETHREAD Thread, PBOOLEAN CopyOnOpen, PBOOLEAN EffectiveOnly, PSECURITY_IMPERSONATION_LEVEL ImpersonationLevel);
// extern NTSTATUS (__stdcall *PsLookupThreadByThreadId)(HANDLE ThreadId, PETHREAD *Thread);
// extern BOOLEAN (__stdcall *PsIsSystemThread)(PETHREAD Thread);
// extern NTSTATUS (__stdcall *ObOpenObjectByPointer)(PVOID Object, ULONG HandleAttributes, PACCESS_STATE PassedAccessState, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PHANDLE Handle);
// extern NTSTATUS (__stdcall *ZwWaitForSingleObject)(HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// extern NTSTATUS (__stdcall *ZwQueryInformationToken)(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);
// extern NTSTATUS (__stdcall *ZwOpenThread)(PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);
// extern NTSTATUS (__stdcall *ZwQueryInformationProcess)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
// extern NTSTATUS (__stdcall *ZwOpenProcessToken)(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);
// extern PVOID (__stdcall *ExAllocatePoolWithTag)(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
// extern BOOLEAN (__stdcall *PsGetVersion)(PULONG MajorVersion, PULONG MinorVersion, PULONG BuildNumber, PUNICODE_STRING CSDVersion);
// extern void (__stdcall *KeInitializeMutex)(PRKMUTEX Mutex, ULONG Level);
// extern LONG (__stdcall *KeReleaseMutex)(PRKMUTEX Mutex, BOOLEAN Wait);
// extern void (__stdcall *ExInitializePagedLookasideList)(PPAGED_LOOKASIDE_LIST Lookaside, PALLOCATE_FUNCTION Allocate, PFREE_FUNCTION Free, ULONG Flags, SIZE_T Size, ULONG Tag, USHORT Depth);
// extern void (__stdcall *ProbeForRead)(volatile void *Address, SIZE_T Length, ULONG Alignment);
// extern KPROCESSOR_MODE (*ExGetPreviousMode)(void);
// extern NTSTATUS (__stdcall *ObQueryNameString)(PVOID Object, POBJECT_NAME_INFORMATION ObjectNameInfo, ULONG Length, PULONG ReturnLength);
// extern NTSTATUS (__stdcall *ZwWriteFile)(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);
// extern NTSTATUS (__stdcall *ZwSetSecurityObject)(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);
// extern _UNKNOWN IoDeviceObjectType; weak
// extern NTSTATUS (__stdcall *IoCreateDevice)(PDRIVER_OBJECT DriverObject, ULONG DeviceExtensionSize, PUNICODE_STRING DeviceName, ULONG DeviceType, ULONG DeviceCharacteristics, BOOLEAN Exclusive, PDEVICE_OBJECT *DeviceObject);
// extern NTSTATUS (__stdcall *RtlGetDaclSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor, PBOOLEAN DaclPresent, PACL *Dacl, PBOOLEAN DaclDefaulted);
// extern NTSTATUS (__stdcall *RtlGetGroupSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor, PSID *Group, PBOOLEAN GroupDefaulted);
// extern NTSTATUS (__stdcall *RtlGetOwnerSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor, PSID *Owner, PBOOLEAN OwnerDefaulted);
// extern NTSTATUS (__stdcall *RtlGetSaclSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor, PBOOLEAN SaclPresent, PACL *Sacl, PBOOLEAN SaclDefaulted);
// extern ULONG (__stdcall *RtlLengthSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor);
// extern PSE_EXPORTS SeExports;
// extern NTSTATUS (__stdcall *RtlCreateSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Revision);
// extern NTSTATUS (__stdcall *RtlAbsoluteToSelfRelativeSD)(PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor, PULONG BufferLength);
// extern NTSTATUS (__stdcall *RtlAddAccessAllowedAce)(PACL Acl, ULONG AceRevision, ACCESS_MASK AccessMask, PSID Sid);
// extern BOOLEAN (__stdcall *IoIsWdmVersionAvailable)(UCHAR MajorVersion, UCHAR MinorVersion);
// extern NTSTATUS (__stdcall *RtlSetDaclSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor, BOOLEAN DaclPresent, PACL Dacl, BOOLEAN DaclDefaulted);
// extern NTSTATUS (__stdcall *ZwCreateKey)(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);
// extern NTSTATUS (__stdcall *ZwSetInformationFile)(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);
// extern NTSTATUS (__stdcall *ZwCreateFile)(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);
// extern LONG_PTR (__stdcall *ObfDereferenceObject)(PVOID Object);
// extern void (__stdcall *ExQueueWorkItem)(PWORK_QUEUE_ITEM WorkItem, WORK_QUEUE_TYPE QueueType);
// extern void (__stdcall *ExReleaseFastMutex)(PFAST_MUTEX FastMutex);
// extern void (__stdcall *ExAcquireFastMutex)(PFAST_MUTEX FastMutex);
// extern void (__stdcall *ExFreePoolWithTag)(PVOID P, ULONG Tag);
// extern NTSTATUS (__stdcall *KeWaitForSingleObject)(PVOID Object, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// extern BOOLEAN (__stdcall *KeSetTimer)(PKTIMER Timer, LARGE_INTEGER DueTime, PKDPC Dpc);
// extern void (__stdcall *KeInitializeTimer)(PKTIMER Timer);
// extern LONG (__stdcall *KeSetEvent)(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait);
// extern void (__stdcall *KeInitializeEvent)(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State);
// extern void (__stdcall *KeInitializeDpc)(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext);
// extern void (__stdcall *RtlFreeUnicodeString)(PUNICODE_STRING UnicodeString);
// extern NTSTATUS (__stdcall *RtlAppendUnicodeStringToString)(PUNICODE_STRING Destination, PCUNICODE_STRING Source);
// extern void (__stdcall *RtlCopyUnicodeString)(PUNICODE_STRING DestinationString, PCUNICODE_STRING SourceString);
// extern LONG (__stdcall *RtlCompareUnicodeString)(PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive);
// extern NTSTATUS (__stdcall *RtlAnsiStringToUnicodeString)(PUNICODE_STRING DestinationString, PCANSI_STRING SourceString, BOOLEAN AllocateDestinationString);
// extern void (__stdcall *RtlInitUnicodeString)(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// extern NTSTATUS (__stdcall *ZwOpenKey)(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
// extern NTSTATUS (__stdcall *PsSetCreateProcessNotifyRoutine)(PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine, BOOLEAN Remove);
// extern void (__stdcall __noreturn *KeBugCheckEx)(ULONG BugCheckCode, ULONG_PTR BugCheckParameter1, ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter3, ULONG_PTR BugCheckParameter4);
__int128 xmmword_18000C4E0 = 0x52006D00650074007300790053005Ci64; // weak
__int128 xmmword_18000C4F0 = 0x63006F00720050005C0074006F006Fi64; // weak
__int128 xmmword_18000C500 = 0x62006D0070002E006E006F006Di64; // weak
_UNKNOWN unk_18000C590; // weak
__int128 xmmword_18000C5A0 = 0x47003B003B004100280050003A0044i64; // weak
const FLT_REGISTRATION Registration =
{
  112u,
  515u,
  4u,
  NULL,
  &unk_18000C6E0,
  NULL,
  &sub_180002870,
  &sub_180002870,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // idb
_UNKNOWN unk_18000CF20; // weak
HANDLE Handle = (HANDLE)0xFFFFFFFFFFFFFFFFi64; // idb
WCHAR aInsufficientRe[] = L"<INSUFFICIENT RESOURCES>"; // idb
WCHAR aInvalidName[] = L"<INVALID NAME>"; // idb
WCHAR aRegistry[] = L"\\Registry"; // idb
char byte_18000F080 = '\x02'; // weak
_UNKNOWN unk_18000F088; // weak
_UNKNOWN unk_18000F0C0; // weak
_UNKNOWN unk_18000F0D4; // weak
wchar_t *off_18000F210 = L"RC"; // weak
uintptr_t _security_cookie = 47936899621426ui64;
ULONG_PTR BugCheckParameter3 = 18446696136809930189ui64; // idb
PVOID P = NULL; // idb
__int64 qword_18000F2C8 = 0i64; // weak
__int64 qword_18000F2D0 = 0i64; // weak
union _SLIST_HEADER SListHead = { { 0ui64, 0ui64 } }; // idb
__int16 word_18000F310 = 0; // weak
int dword_18000F314 = 0; // weak
int dword_18000F318 = 0; // weak
int dword_18000F31C = 0; // weak
int dword_18000F320 = 0; // weak
int dword_18000F324 = 0; // weak
int dword_18000F328 = 0; // weak
int dword_18000F32C = 0; // weak
__int64 (__fastcall *qword_18000F330)(_QWORD, _QWORD, _QWORD) = NULL; // weak
__int64 (__fastcall *qword_18000F338)(_QWORD) = NULL; // weak
int dword_18000F380 = 0; // weak
char byte_18000F384 = '\0'; // weak
char byte_18000F385 = '\0'; // weak
__int64 qword_18000F388 = 0i64; // weak
union _SLIST_HEADER ListHead = { { 0ui64, 0ui64 } }; // idb
__int16 word_18000F3D0 = 0; // weak
int dword_18000F3D4 = 0; // weak
int dword_18000F3D8 = 0; // weak
int dword_18000F3DC = 0; // weak
int dword_18000F3E0 = 0; // weak
int dword_18000F3E4 = 0; // weak
int dword_18000F3E8 = 0; // weak
int dword_18000F3EC = 0; // weak
__int64 (__fastcall *qword_18000F3F0)(_QWORD, _QWORD, _QWORD) = NULL; // weak
__int64 (__fastcall *qword_18000F3F8)(_QWORD) = NULL; // weak
int dword_18000F440; // weak
union _SLIST_HEADER g_SListHeader; // idb
__int64 DriverZwOpenProcessTokenEx; // weak
struct _NPAGED_LOOKASIDE_LIST Lookaside; // idb
__int64 (__fastcall *DriverZwQueryInformationThread)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *DriverSeLocateProcessImageName)(_QWORD, _QWORD); // weak
__int64 (__fastcall *DriverPsSetCreateProcessNotifyRoutineEx2)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *DriverPsSetCreateThreadNotifyRoutineEx)(_QWORD, _QWORD); // weak
char byte_18000F520; // weak
char byte_18000F521; // weak
char byte_18000F522; // weak
char byte_18000F523; // weak
int dword_18000F524; // weak
__int64 (__fastcall *DriverCmUnRegisterCallback)(_QWORD); // weak
__int64 (__fastcall *DriverCmRegisterCallback)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *DriverCmRegisterCallbackEx)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *DriverCmCallbackGetKeyObjectID)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD); // weak
union _SLIST_HEADER stru_18000F580; // idb
__int16 word_18000F590; // weak
int dword_18000F594; // weak
int dword_18000F598; // weak
int dword_18000F59C; // weak
int dword_18000F5A0; // weak
int dword_18000F5A4; // weak
int dword_18000F5A8; // weak
int dword_18000F5AC; // weak
__int64 (__fastcall *qword_18000F5B0)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_18000F5B8)(_QWORD); // weak
char byte_18000F600; // weak
__int64 qword_18000F608; // weak
__int64 (__fastcall *qword_18000F610)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _QWORD, _QWORD); // weak
char byte_18000F618; // weak
int dword_18000F61C; // weak
struct _KMUTANT g_KeMutek4; // idb
__int64 qword_18000F680; // weak
__int64 qword_18000F688; // weak
struct _KMUTANT Mutex; // idb
__int64 qword_18000F6E0; // weak
__int64 qword_18000F6E8; // weak
__int64 qword_18000F6F0; // weak
struct _UNICODE_STRING stru_18000F700; // idb
UNICODE_STRING String2; // idb
UNICODE_STRING Source; // idb
UNICODE_STRING Destination; // idb
__int64 qword_18000F740; // weak
ULONG BuildNumber; // idb
_UNKNOWN unk_18000F760; // weak
struct _KTIMER g_KeTimer3; // idb
struct _KEVENT g_KeEvent4; // idb
HANDLE qword_1800107B8; // idb
struct _KEVENT g_KeEvent2; // idb
KSPIN_LOCK g_KSpinLock; // idb
HANDLE ThreadHandle; // idb
struct _KTIMER g_KeTimer4; // idb
struct _KEVENT g_KeEvent3; // idb
int dword_180010858; // weak
struct _KTIMER g_KeTimer2; // idb
struct _KDPC g_KeDpc2; // idb
struct _FAST_MUTEX g_KeMutek3; // idb
__int64 qword_180010920; // weak
__int64 qword_180010928; // weak
__int64 qword_180010930; // weak
__int64 qword_180010938; // weak
__int64 qword_180010940; // weak
__int64 (*qword_180010948)(void); // weak
struct _FAST_MUTEX g_FastMutek2; // idb
__int64 qword_1800109A0; // weak
__int64 qword_1800109A8; // weak
union _LARGE_INTEGER PerformanceFrequency; // idb
__int64 qword_1800109B8; // weak
__int64 qword_1800109C0; // weak
struct _KTIMER g_KeTimer; // idb
struct _KDPC g_KeDpc; // idb
struct _KEVENT g_KeEvent; // idb
int dword_180010A78; // weak
struct _FAST_MUTEX g_FastMutek; // idb
__int64 qword_180010AC0; // weak
__int64 qword_180010AC8; // weak
__int64 qword_180010AD0; // weak
KSPIN_LOCK SpinLock; // idb
PFLT_PORT ClientPort; // idb
PFLT_PORT qword_180010AE8; // idb
PFLT_PORT ServerPort; // idb
PFLT_FILTER Filter; // idb
__int64 qword_180010B00; // weak
PRKEVENT Event; // idb
HANDLE EventHandle; // idb
PDEVICE_OBJECT DeviceObject; // idb
PDEVICE_OBJECT g_DriverObj; // idb
struct _KDPC Dpc; // idb
struct _KTIMER Timer; // idb
struct _KEVENT Object; // idb
struct _FAST_MUTEX FastMutex; // idb
UNICODE_STRING DestinationString; // idb


//----- (0000000180001000) ----------------------------------------------------
void sub_180001000()
{
  unsigned int *i; // rsi
  unsigned int j; // edi
  unsigned int k; // ebx
  unsigned int *v3; // r8
  unsigned __int64 v4; // rdx
  bool v5; // al
  __int64 v6; // rax
  HANDLE v7; // rax
  HANDLE CurrentProcessId; // rax
  UNICODE_STRING Source; // [rsp+20h] [rbp-29h] BYREF
  struct _UNICODE_STRING Destination; // [rsp+30h] [rbp-19h] BYREF
  struct _STRING SourceString; // [rsp+40h] [rbp-9h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+50h] [rbp+7h] BYREF
  int v13; // [rsp+60h] [rbp+17h] BYREF
  __int64 v14; // [rsp+68h] [rbp+1Fh]
  __int64 v15; // [rsp+78h] [rbp+2Fh]
  ULONG ReturnLength; // [rsp+B0h] [rbp+67h] BYREF

  RtlInitUnicodeString(&DestinationString, L"\\SystemRoot\\System32\\Drivers\\");
  ReturnLength = 1000;
  for ( i = (unsigned int *)DriverAllocateWithTag(PagedPool, 0x3E8u, 98);
        ZwQuerySystemInformation(SystemModuleInformation, i, ReturnLength, &ReturnLength);
        i = (unsigned int *)DriverAllocateWithTag(PagedPool, ReturnLength, 98) )
  {
    ExFreePoolWithTag(i, 0);
    ReturnLength += 1000;
  }
  for ( j = 0; j < 2; ++j )
  {
    for ( k = 0; k < *i; ++k )
    {
      v3 = &i[74 * k];
      v4 = *((_QWORD *)v3 + 3);
      v5 = (unsigned __int64)sub_180001000 > v4 && (unsigned __int64)sub_180001000 < v4 + v3[8];
      if ( j )
      {
        if ( !v5 )
        {
LABEL_13:
          v13 |= 0x100u;
          v14 = *((_QWORD *)v3 + 3);
          v15 = v3[8];
          v6 = -1i64;
          do
            ++v6;
          while ( *((_BYTE *)v3 + v6 + 48) );
          SourceString.Buffer = (PCHAR)(v3 + 12);
          SourceString.Length = v6;
          if ( RtlAnsiStringToUnicodeString(&Source, &SourceString, 1u) >= 0 )
          {
            if ( *Source.Buffer == 92
              || (Destination.MaximumLength = Source.Length + DestinationString.Length,
                  (Destination.Buffer = (PWSTR)DriverAllocateWithTag(
                                                 NonPagedPool,
                                                 (unsigned __int16)(Source.Length + DestinationString.Length),
                                                 98)) == 0i64) )
            {
              CurrentProcessId = PsGetCurrentProcessId();
              sub_180004C00(&Source, (__int64)CurrentProcessId, (__int64)&v13);
            }
            else
            {
              RtlCopyUnicodeString(&Destination, &DestinationString);
              RtlAppendUnicodeStringToString(&Destination, &Source);
              v7 = PsGetCurrentProcessId();
              sub_180004C00(&Destination, (__int64)v7, (__int64)&v13);
              ExFreePoolWithTag(Destination.Buffer, 0);
            }
            RtlFreeUnicodeString(&Source);
          }
        }
      }
      else if ( v5 )
      {
        goto LABEL_13;
      }
    }
  }
  ExFreePoolWithTag(i, 0);
}
// 1800010F7: conditional instruction was optimized away because edi.4==1

//----- (0000000180001220) ----------------------------------------------------
void GetVolumesInformation()
{
  PVOID i; // rbx
  PFLT_VOLUME *v1; // rax
  PFLT_VOLUME *v2; // r15
  __int64 j; // rbp
  PFLT_VOLUME *v4; // r14
  ULONG DeviceType; // ebx
  struct _UNICODE_STRING *v6; // rax
  struct _UNICODE_STRING *v7; // rsi
  WCHAR *v8; // rax
  int v9; // eax
  PVOID *v10; // rcx
  char *v11; // rax
  char *v12; // rax
  ULONG NumberVolumesReturned; // [rsp+60h] [rbp+8h] BYREF
  ULONG BufferSizeNeeded; // [rsp+68h] [rbp+10h] BYREF
  PDEVICE_OBJECT DiskDeviceObject; // [rsp+70h] [rbp+18h] BYREF

  ExAcquireFastMutex(&FastMutex);
  for ( i = P; P; i = P )
  {
    P = (PVOID)*((_QWORD *)i + 3);
    ExFreePoolWithTag(*((PVOID *)i + 1), 0);
    ExFreePoolWithTag(i, 0);
  }
  if ( FltEnumerateVolumes(Filter, 0i64, 0, &NumberVolumesReturned) == -1073741789 )
  {
    v1 = (PFLT_VOLUME *)DriverAllocateWithTag(NonPagedPool, 8 * NumberVolumesReturned, 98);
    v2 = v1;
    if ( v1 )
    {
      if ( FltEnumerateVolumes(Filter, v1, NumberVolumesReturned, &NumberVolumesReturned) >= 0 )
      {
        for ( j = 0i64; (unsigned int)j < NumberVolumesReturned; j = (unsigned int)(j + 1) )
        {
          v4 = &v2[j];
          if ( FltGetDiskDeviceObject(*v4, &DiskDeviceObject) >= 0 )
          {
            DeviceType = DiskDeviceObject->DeviceType;
            if ( DeviceType == 7 || DeviceType == 2 )
            {
              ObfDereferenceObject(DiskDeviceObject);
              v6 = (struct _UNICODE_STRING *)DriverAllocateWithTag(NonPagedPool, 0x20u, 98);
              v7 = v6;
              if ( v6 )
              {
                *(_DWORD *)&v6[1].Length = DeviceType;
                if ( FltGetVolumeName(*v4, 0i64, &BufferSizeNeeded) == -1073741789
                  && (v8 = (WCHAR *)DriverAllocateWithTag(NonPagedPool, BufferSizeNeeded, 98), (v7->Buffer = v8) != 0i64) )
                {
                  v7->MaximumLength = BufferSizeNeeded;
                  if ( FltGetVolumeName(*v4, v7, 0i64) >= 0 )
                  {
                    v9 = *(_DWORD *)&v7[1].Length;
                    v10 = &P;
                    if ( v9 == 7 )
                    {
                      v11 = (char *)P;
                      if ( P )
                      {
                        do
                        {
                          if ( *((_DWORD *)v11 + 4) != 7 )
                            break;
                          v10 = (PVOID *)(v11 + 24);
                          v11 = (char *)*((_QWORD *)v11 + 3);
                        }
                        while ( v11 );
                      }
                    }
                    else if ( v9 == 2 )
                    {
                      v12 = (char *)P;
                      if ( P )
                      {
                        do
                        {
                          if ( *((_DWORD *)v12 + 4) == 2 )
                            break;
                          v10 = (PVOID *)(v12 + 24);
                          v12 = (char *)*((_QWORD *)v12 + 3);
                        }
                        while ( v12 );
                      }
                    }
                    v7[1].Buffer = (PWSTR)*v10;
                    *v10 = v7;
                  }
                  else
                  {
                    ExFreePoolWithTag(v7->Buffer, 0);
                    ExFreePoolWithTag(v7, 0);
                  }
                }
                else
                {
                  ExFreePoolWithTag(v7, 0);
                }
              }
            }
            else
            {
              ObfDereferenceObject(DiskDeviceObject);
            }
          }
          FltObjectDereference(*v4);
        }
      }
      ExFreePoolWithTag(v2, 0);
    }
  }
  ExReleaseFastMutex(&FastMutex);
}

//----- (0000000180001490) ----------------------------------------------------
void __fastcall sub_180001490(__int64 a1, __int64 a2)
{
  _OWORD *v4; // rax
  unsigned __int16 v5; // [rsp+30h] [rbp-68h] BYREF
  PVOID P; // [rsp+38h] [rbp-60h]
  struct _WORK_QUEUE_ITEM WorkItem; // [rsp+40h] [rbp-58h] BYREF
  struct _KEVENT Event; // [rsp+60h] [rbp-38h] BYREF
  unsigned __int16 *v9; // [rsp+78h] [rbp-20h]
  __int64 v10; // [rsp+80h] [rbp-18h]

  *(_QWORD *)(a2 + 8) = 0i64;
  v5 = *(_WORD *)a1;
  v4 = DriverAllocateWithTag(NonPagedPool, v5, 98);
  P = v4;
  if ( v4 )
  {
    sub_18000AC00(v4, *(char **)(a1 + 8), v5);
    v10 = a2;
    v9 = &v5;
    KeInitializeEvent(&Event, NotificationEvent, 0);
    WorkItem.List.Flink = 0i64;
    WorkItem.WorkerRoutine = (PWORKER_THREAD_ROUTINE)sub_180001690;
    WorkItem.Parameter = &WorkItem;
    if ( PsGetCurrentProcessId() == (HANDLE)qword_180010940 )
      sub_180001690((__int64)&WorkItem);
    else
      ExQueueWorkItem(&WorkItem, DelayedWorkQueue);
    KeWaitForSingleObject(&Event, Executive, 0, 0, 0i64);
    ExFreePoolWithTag(P, 0);
  }
}
// 180010940: using guessed type __int64 qword_180010940;

//----- (0000000180001580) ----------------------------------------------------
BOOLEAN __fastcall sub_180001580(PCUNICODE_STRING Source, PUNICODE_STRING Destination)
{
  unsigned int v3; // edi
  BOOLEAN v5; // r14
  unsigned __int16 *v6; // rbx
  __int64 v7; // rcx
  USHORT v8; // ax
  WCHAR *v9; // rax
  unsigned int v10; // ecx

  v3 = 0;
  v5 = IoSetThreadHardErrorMode(0);
  while ( 1 )
  {
    ExAcquireFastMutex(&FastMutex);
    v6 = (unsigned __int16 *)P;
    if ( v3 )
    {
      v7 = v3;
      do
      {
        v6 = (unsigned __int16 *)*((_QWORD *)v6 + 3);
        --v7;
      }
      while ( v7 );
    }
    if ( !v6 )
      break;
    v8 = Source->Length + *v6;
    Destination->MaximumLength = v8;
    v9 = (WCHAR *)DriverAllocateWithTag(NonPagedPool, v8, 73);
    Destination->Buffer = v9;
    if ( !v9 )
      break;
    v10 = *v6;
    Destination->Length = v10;
    sub_18000AC00(v9, *((char **)v6 + 1), v10);
    ExReleaseFastMutex(&FastMutex);
    RtlAppendUnicodeStringToString(Destination, Source);
    if ( sub_180002CE0(Destination) )
      return IoSetThreadHardErrorMode(v5);
    ExFreePoolWithTag(Destination->Buffer, 0);
    ++v3;
    Destination->Buffer = 0i64;
  }
  ExReleaseFastMutex(&FastMutex);
  return IoSetThreadHardErrorMode(v5);
}

//----- (0000000180001690) ----------------------------------------------------
LONG __fastcall sub_180001690(__int64 a1)
{
  UNICODE_STRING *v1; // rbx
  struct _UNICODE_STRING *v3; // rdi
  USHORT Length; // bp
  LONG v5; // eax
  WCHAR *v6; // rax

  v1 = *(UNICODE_STRING **)(a1 + 56);
  v3 = *(struct _UNICODE_STRING **)(a1 + 64);
  Length = v1->Length;
  if ( v1->Length > DestinationString.Length
    && (v1->Length = DestinationString.Length,
        v5 = RtlCompareUnicodeString(&DestinationString, v1, 1u),
        v1->Length = Length,
        !v5)
    || sub_180002CE0(v1)
    || (sub_180001580(v1, v3), !v3->Buffer) && (GetVolumesInformation(), sub_180001580(v1, v3), !v3->Buffer) )
  {
    v6 = (WCHAR *)DriverAllocateWithTag(NonPagedPool, v1->Length, 98);
    v3->Buffer = v6;
    if ( v6 )
    {
      v3->MaximumLength = v1->Length;
      RtlCopyUnicodeString(v3, v1);
    }
  }
  return KeSetEvent((PRKEVENT)(a1 + 32), 0, 0);
}

//----- (0000000180001760) ----------------------------------------------------
NTSTATUS __fastcall sub_180001760(ULONG *a1)
{
  NTSTATUS result; // eax
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+50h] [rbp-18h] BYREF
  __int64 FileInformation; // [rsp+70h] [rbp+8h] BYREF

  result = ZwWriteFile(Handle, 0i64, 0i64, 0i64, &IoStatusBlock, a1 + 1, *a1, 0i64, 0i64);
  if ( IoStatusBlock.Status == -1073741697 )
  {
    FileInformation = 0i64;
    ZwSetInformationFile(Handle, &IoStatusBlock, &FileInformation, 8u, FileEndOfFileInformation);
    return sub_180001C70();
  }
  return result;
}

//----- (00000001800017F0) ----------------------------------------------------
__int64 sub_1800017F0()
{
  struct _UNICODE_STRING DestinationString; // [rsp+60h] [rbp-88h] BYREF
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+70h] [rbp-78h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+80h] [rbp-68h] BYREF
  _OWORD v4[3]; // [rsp+B0h] [rbp-38h] BYREF

  v4[0] = xmmword_18000C4E0;
  v4[1] = xmmword_18000C4F0;
  v4[2] = xmmword_18000C500;
  if ( Handle != (HANDLE)-1i64 )
    return sub_180004350((void (__fastcall *)(__int64, _QWORD))sub_180001760);
  RtlInitUnicodeString(&DestinationString, (PCWSTR)v4);
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = &DestinationString;
  *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0i64;
  if ( ZwCreateFile(&Handle, 0x100002u, &ObjectAttributes, &IoStatusBlock, 0i64, 0x80u, 1u, 5u, 0x20u, 0i64, 0) >= 0 )
    return sub_180004350((void (__fastcall *)(__int64, _QWORD))sub_180001760);
  sub_180003B40();
  return 3221225489i64;
}
// 18000C4E0: using guessed type __int128 xmmword_18000C4E0;
// 18000C4F0: using guessed type __int128 xmmword_18000C4F0;
// 18000C500: using guessed type __int128 xmmword_18000C500;

//----- (00000001800018F0) ----------------------------------------------------
bool __fastcall GetRegistryValue(struct _UNICODE_STRING *a1, _DWORD *a2, _DWORD *a3)
{
  int v5; // edi
  _DWORD *v6; // rbx
  void *KeyHandle; // [rsp+30h] [rbp-29h] BYREF
  HANDLE Handle; // [rsp+38h] [rbp-21h] BYREF
  struct _UNICODE_STRING ValueName; // [rsp+40h] [rbp-19h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+50h] [rbp-9h] BYREF
  struct _UNICODE_STRING v12; // [rsp+60h] [rbp+7h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+70h] [rbp+17h] BYREF
  ULONG ResultLength; // [rsp+C0h] [rbp+67h] BYREF
  int Data; // [rsp+D8h] [rbp+7Fh] BYREF

  ObjectAttributes.ObjectName = a1;
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 64;
  *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0i64;
  v5 = 3;
  if ( ZwOpenKey(&KeyHandle, 0x2001Fu, &ObjectAttributes) >= 0 )
  {
    v6 = DriverAllocateWithTag(NonPagedPool, 0x14u, 98);
    if ( v6 )
    {
      RtlInitUnicodeString(&DestinationString, L"Start");
      if ( ZwQueryValueKey(KeyHandle, &DestinationString, KeyValuePartialInformation, v6, 0x14u, &ResultLength) >= 0 )
      {
        v5 = v6[3];
        if ( !v5 )
        {
          RtlInitUnicodeString(&v12, L"Parameters");
          ObjectAttributes.RootDirectory = KeyHandle;
          ObjectAttributes.Length = 48;
          ObjectAttributes.ObjectName = &v12;
          ObjectAttributes.Attributes = 64;
          *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0i64;
          if ( ZwOpenKey(&Handle, 0x2001Fu, &ObjectAttributes) >= 0 )
          {
            RtlInitUnicodeString(&ValueName, L"ThreadProfiling");
            if ( ZwQueryValueKey(Handle, &ValueName, KeyValuePartialInformation, v6, 0x14u, &ResultLength) >= 0 )
              *a2 = v6[3];
            RtlInitUnicodeString(&ValueName, L"RuntimeSeconds");
            if ( ZwQueryValueKey(Handle, &ValueName, KeyValuePartialInformation, v6, 0x14u, &ResultLength) >= 0 )
              *a3 = v6[3];
            ZwClose(Handle);
          }
          Data = 3;
          ZwSetValueKey(KeyHandle, &DestinationString, 0, 4u, &Data, 4u);
          ZwFlushKey(KeyHandle);
        }
      }
      ExFreePoolWithTag(v6, 0);
    }
    ZwClose(KeyHandle);
  }
  return v5 == 0;
}

//----- (0000000180001B10) ----------------------------------------------------
void __fastcall sub_180001B10(struct _UNICODE_STRING *a1)
{
  __int64 v2; // rdx
  __int64 v3; // r8
  __int64 v4; // rbx
  unsigned int v5; // [rsp+38h] [rbp+10h] BYREF
  unsigned int v6; // [rsp+40h] [rbp+18h] BYREF

  v5 = -1;
  v6 = 0;
  FastMutex.Count = 1;
  FastMutex.Owner = 0i64;
  FastMutex.Contention = 0;
  KeInitializeEvent(&FastMutex.Event, SynchronizationEvent, 0);
  GetVolumesInformation();
  if ( GetRegistryValue(a1, &v6, &v5) )
  {
    KeInitializeEvent(&Object, NotificationEvent, 0);
    RtlInitUnicodeString(&DestinationString, L"\\SystemRoot");
    qword_180010AD0 = 450000000i64;
    sub_180004500(sub_1800017F0);
    v4 = v5;
    if ( v5 != -1 )
    {
      KeInitializeTimer(&Timer);
      KeInitializeDpc(&Dpc, (PKDEFERRED_ROUTINE)DeferredRoutine, 0i64);
      KeSetTimer(&Timer, (LARGE_INTEGER)-v4, &Dpc);
    }
    sub_180007950(7, v2, v3);
    if ( v6 )
      sub_180007380(v6);
    sub_180001000();
  }
}
// 180001BF9: variable 'v2' is possibly undefined
// 180001BF9: variable 'v3' is possibly undefined
// 180010AD0: using guessed type __int64 qword_180010AD0;

//----- (0000000180001C20) ----------------------------------------------------
void sub_180001C20()
{
  __int64 v0; // rdx
  __int64 v1; // r8

  if ( dword_18000F524 )
  {
    sub_180006CD0();
    sub_180004500(sub_180001C70);
    KeWaitForSingleObject(&Object, Executive, 0, 0, 0i64);
    sub_180007950(0, v0, v1);
  }
}
// 180001C62: variable 'v0' is possibly undefined
// 180001C62: variable 'v1' is possibly undefined
// 18000F524: using guessed type int dword_18000F524;

//----- (0000000180001C70) ----------------------------------------------------
__int64 sub_180001C70()
{
  __int64 result; // rax

  result = sub_180004350((void (__fastcall *)(__int64, _QWORD))sub_180001760);
  if ( (int)result < 0 )
  {
    if ( Handle != (HANDLE)-1i64 )
    {
      ZwClose(Handle);
      Handle = (HANDLE)-1i64;
      KeSetEvent(&Object, 0, 0);
    }
    qword_180010AD0 = 100000000i64;
    return 3221225489i64;
  }
  return result;
}
// 180010AD0: using guessed type __int64 qword_180010AD0;

//----- (0000000180001CD0) ----------------------------------------------------
void __fastcall sub_180001CD0(void *a1)
{
  __int64 v2; // rdx
  __int64 v3; // r8

  if ( dword_18000F524 )
  {
    sub_180006CD0();
    sub_180004500(sub_180001C70);
    KeWaitForSingleObject(&Object, Executive, 0, 0, 0i64);
    sub_180007950(0, v2, v3);
  }
  ExFreePoolWithTag(a1, 0);
}
// 180001D13: variable 'v2' is possibly undefined
// 180001D13: variable 'v3' is possibly undefined
// 18000F524: using guessed type int dword_18000F524;

//----- (0000000180001D30) ----------------------------------------------------
void __fastcall DeferredRoutine(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
  struct _WORK_QUEUE_ITEM *v4; // rax

  v4 = (struct _WORK_QUEUE_ITEM *)DriverAllocateWithTag(NonPagedPool, 0x20u, 77);
  if ( v4 )
  {
    v4->Parameter = v4;
    v4->WorkerRoutine = (PWORKER_THREAD_ROUTINE)sub_180001CD0;
    v4->List.Flink = 0i64;
    ExQueueWorkItem(v4, DelayedWorkQueue);
  }
}

//----- (0000000180001D80) ----------------------------------------------------
_BOOL8 __fastcall IntializeLogger(_QWORD *a1)
{
  int v2; // ebx
  struct _KEVENT *v3; // rax
  bool v4; // bl
  struct _UNICODE_STRING DestinationString; // [rsp+50h] [rbp-58h] BYREF
  struct _UNICODE_STRING EventName; // [rsp+60h] [rbp-48h] BYREF
  struct _UNICODE_STRING SymbolicLinkName; // [rsp+70h] [rbp-38h] BYREF
  WCHAR SourceString[16]; // [rsp+80h] [rbp-28h] BYREF

  g_DriverObj = 0i64;
  DeviceObject = 0i64;
  RtlInitUnicodeString(&DestinationString, L"\\device\\ProcmonExternalLogger");
  v2 = CreateSercuredDeviceAndControlAccess(
         (__int64)a1,
         0,
         (__int64)&DestinationString,
         0x9535u,
         256,
         0,
         (__int64)&unk_18000CF20,
         (__int64)&unk_18000C590,
         (__int64)&g_DriverObj);
  if ( v2 >= 0 )
  {
    a1[16] = sub_180002000;
    a1[14] = sub_180002000;
    a1[29] = sub_180002030;
    a1[28] = sub_180002030;
    RtlInitUnicodeString(&EventName, L"\\??\\ProcmonExternalLoggerEnabled");
    v3 = IoCreateNotificationEvent(&EventName, &EventHandle);
    Event = v3;
    if ( v3 )
      KeClearEvent(v3);
    else
      v2 = -1073741823;
  }
  v4 = v2 >= 0;
  if ( v4 )
  {
    wcscpy(SourceString, (const wchar_t *)&xmmword_18000C5A0);
    RtlInitUnicodeString(&EventName, SourceString);
    RtlInitUnicodeString(&DestinationString, L"\\device\\ProcmonDebugLogger");
    if ( (int)CreateSercuredDeviceAndControlAccess(
                (__int64)a1,
                0,
                (__int64)&DestinationString,
                0x9535u,
                256,
                0,
                (__int64)&EventName,
                (__int64)&unk_18000C590,
                (__int64)&DeviceObject) >= 0 )
    {
      RtlInitUnicodeString(&SymbolicLinkName, L"\\DosDevices\\Global\\ProcmonDebugLogger");
      if ( IoCreateSymbolicLink(&SymbolicLinkName, &DestinationString) < 0 )
      {
        IoDeleteDevice(DeviceObject);
        DeviceObject = 0i64;
      }
    }
  }
  return v4;
}
// 18000C5A0: using guessed type __int128 xmmword_18000C5A0;

//----- (0000000180001F60) ----------------------------------------------------
char CloseDeviceAndLogging()
{
  struct _UNICODE_STRING DestinationString; // [rsp+20h] [rbp-18h] BYREF

  RtlInitUnicodeString(&DestinationString, L"\\DosDevices\\Global\\ProcmonDebugLogger");
  IoDeleteSymbolicLink(&DestinationString);
  if ( DeviceObject )
    IoDeleteDevice(DeviceObject);
  if ( g_DriverObj )
    IoDeleteDevice(g_DriverObj);
  if ( Event )
  {
    KeClearEvent(Event);
    ZwClose(EventHandle);
  }
  return 1;
}

//----- (0000000180001FD0) ----------------------------------------------------
void __fastcall sub_180001FD0(char a1)
{
  if ( Event )
  {
    if ( a1 )
      KeSetEvent(Event, 0, 0);
    else
      KeClearEvent(Event);
  }
}

//----- (0000000180002000) ----------------------------------------------------
__int64 __fastcall sub_180002000(__int64 a1, IRP *a2)
{
  a2->IoStatus.Information = 0i64;
  a2->IoStatus.Status = 0;
  IofCompleteRequest(a2, 0);
  return 0i64;
}

//----- (0000000180002030) ----------------------------------------------------
__int64 __fastcall sub_180002030(struct _DEVICE_OBJECT *a1, __int64 a2)
{
  __int64 v3; // rbx
  unsigned int v4; // edi
  int v5; // r14d
  unsigned int v6; // r14d
  __int64 v7; // r15
  int v8; // ebp
  unsigned __int16 *v9; // rbx
  HANDLE CurrentProcessId; // rax
  __int64 *v11; // r13
  _OWORD *v12; // rax
  char *v13; // rdx
  unsigned __int64 v14; // rdi
  _OWORD *v15; // rax
  HANDLE v16; // rax
  __int64 *v17; // rbp
  __int64 v18; // rcx
  int v20; // [rsp+70h] [rbp+8h] BYREF
  __int64 v21; // [rsp+78h] [rbp+10h] BYREF

  v3 = *(_QWORD *)(a2 + 184);
  v4 = -1073741811;
  if ( a1 == g_DriverObj )
  {
    if ( v3 )
    {
      if ( *(_DWORD *)(v3 + 24) == -1791655424 )
      {
        *(_QWORD *)(a2 + 56) = 0i64;
        v5 = *(_DWORD *)(v3 + 16);
        if ( (unsigned int)(v5 - 13) <= 0xFF2 )
        {
          v6 = v5 - 12;
          v7 = *(_QWORD *)(a2 + 24);
          v8 = *(unsigned __int16 *)(v7 + 4);
          v9 = (unsigned __int16 *)(v7 + 12);
          CurrentProcessId = PsGetCurrentProcessId();
          v11 = sub_1800046B0((__int64)CurrentProcessId, 1);
          if ( !v11 )
            goto LABEL_21;
          if ( v8 != 3 )
          {
            if ( v8 == 7 )
            {
LABEL_12:
              v14 = 2 * (unsigned int)*v9 + 16;
              goto LABEL_14;
            }
            if ( v8 != 5 )
            {
              if ( v8 != 6 )
              {
                v12 = (_OWORD *)sub_180003C90(
                                  *(_BYTE *)v7,
                                  v8,
                                  *((_DWORD *)v11 + 3),
                                  *(_DWORD *)(v7 + 8),
                                  v6,
                                  (PSLIST_ENTRY *)&v21);
                if ( v12 )
                {
                  v13 = (char *)(v7 + 12);
LABEL_20:
                  sub_18000AC00(v12, v13, v6);
                  sub_180004460(v21);
                }
LABEL_21:
                sub_180004620((__int64)v11);
LABEL_30:
                v4 = 0;
                goto LABEL_31;
              }
              goto LABEL_12;
            }
          }
          v14 = 2 * (unsigned int)*v9 + 12;
LABEL_14:
          if ( (unsigned int)v14 > v6 )
            goto LABEL_21;
          v6 -= v14;
          v15 = (_OWORD *)sub_180003D60(1, *(_BYTE *)v7, v8, *((_DWORD *)v11 + 3), 259, v14, &v20, (PSLIST_ENTRY *)&v21);
          if ( v15 )
          {
            sub_18000AC00(v15, (char *)(v7 + 12), v14);
            sub_180004460(v21);
          }
          if ( v20 == -1 )
            goto LABEL_21;
          v12 = (_OWORD *)sub_180003D20(v20, *(_DWORD *)(v7 + 8), v6, (PSLIST_ENTRY *)&v21);
          if ( !v12 )
            goto LABEL_21;
          v13 = (char *)v9 + v14;
          goto LABEL_20;
        }
      }
    }
  }
  else if ( a1 == DeviceObject )
  {
    if ( v3 )
    {
      if ( *(_DWORD *)(v3 + 24) == -1791655420 && *(_DWORD *)(v3 + 16) < 0x1000u )
      {
        v16 = PsGetCurrentProcessId();
        v17 = sub_1800046B0((__int64)v16, 1);
        if ( v17 )
        {
          v18 = sub_180003C90(4u, 2, *((_DWORD *)v17 + 3), 259, *(_DWORD *)(v3 + 16) + 2, (PSLIST_ENTRY *)&v21);
          if ( v18 )
          {
            *(_WORD *)v18 = *(_WORD *)(v3 + 16) >> 1;
            sub_18000AC00((_OWORD *)(v18 + 2), *(char **)(a2 + 24), *(unsigned int *)(v3 + 16));
            sub_180004460(v21);
          }
          sub_180004620((__int64)v17);
          goto LABEL_30;
        }
      }
    }
  }
LABEL_31:
  *(_DWORD *)(a2 + 48) = v4;
  IofCompleteRequest((PIRP)a2, 0);
  return v4;
}

//----- (0000000180002290) ----------------------------------------------------
__int64 __fastcall sub_180002290(PFLT_CALLBACK_DATA CallbackData, __int64 a2, _QWORD *a3)
{
  PFLT_IO_PARAMETER_BLOCK Iopb; // rax
  char v4; // di
  IRP *TopLevelIrp; // r15
  unsigned int v8; // r13d
  struct _FILE_OBJECT *v10; // rcx
  struct _UNICODE_STRING *v11; // rsi
  __int64 v12; // rbx
  struct _UNICODE_STRING *v13; // rax
  __int64 v14; // rdi
  KIRQL v15; // r15
  _QWORD *v16; // rax
  _QWORD *v17; // rbx
  bool v18; // bl
  HANDLE CurrentProcessId; // rax
  __int64 *v20; // rax
  __int64 v21; // r15
  _OWORD *v22; // rax
  PFLT_IO_PARAMETER_BLOCK v23; // rdx
  UCHAR EaList; // r12
  int v25; // ebx
  __int16 v26; // di
  LOGICAL IsPagingFile; // eax
  __int64 v28; // rax
  __int64 v29; // rbx
  unsigned int v30; // [rsp+40h] [rbp-58h] BYREF
  PFLT_FILE_NAME_INFORMATION FileNameInformation; // [rsp+48h] [rbp-50h] BYREF
  PVOID P; // [rsp+50h] [rbp-48h]
  __int64 v33; // [rsp+58h] [rbp-40h] BYREF
  ULONG BufferSizeNeeded; // [rsp+A0h] [rbp+8h] BYREF
  _QWORD *v35; // [rsp+B0h] [rbp+18h]
  unsigned int v36; // [rsp+B8h] [rbp+20h] BYREF

  v35 = a3;
  Iopb = CallbackData->Iopb;
  v4 = 0;
  FileNameInformation = 0i64;
  TopLevelIrp = 0i64;
  v8 = 1;
  if ( Iopb->MajorFunction != 16 )
  {
    v10 = *(struct _FILE_OBJECT **)(a2 + 32);
    if ( !v10 || (dword_18000F524 & 2) == 0 )
      return v8;
    if ( FsRtlIsPagingFile(v10) && KeGetCurrentIrql() == 1 )
    {
      v11 = sub_180003640(*(_QWORD *)(a2 + 32));
    }
    else
    {
      if ( FltGetFileNameInformation(CallbackData, 0x401u, &FileNameInformation) < 0 )
        goto LABEL_12;
      v11 = sub_1800078F0(NonPagedPool, &FileNameInformation->Name, 49);
      FltReleaseFileNameInformation(FileNameInformation);
    }
    if ( v11 )
    {
LABEL_24:
      if ( FsRtlIsPagingFile(*(PFILE_OBJECT *)(a2 + 32)) )
      {
        v14 = *(_QWORD *)(a2 + 32);
        v15 = KeAcquireSpinLockRaiseToDpc(&SpinLock);
        if ( !sub_180003640(v14) )
        {
          v16 = DriverAllocateWithTag(NonPagedPool, (unsigned int)v11->Length + 32, 49);
          v17 = v16;
          if ( v16 )
          {
            v16[1] = v14;
            *((_WORD *)v16 + 8) = v11->Length;
            v16[3] = v16 + 4;
            sub_18000AC00((_OWORD *)v16 + 2, (char *)v11->Buffer, v11->Length);
            *v17 = qword_18000F2D0;
            qword_18000F2D0 = (__int64)v17;
          }
        }
        KeReleaseSpinLock(&SpinLock, v15);
      }
      v18 = (CallbackData->Iopb->IrpFlags & 0x40) == 0;
      CurrentProcessId = PsGetCurrentProcessId();
      v20 = sub_1800046B0((__int64)CurrentProcessId, v18);
      v21 = (__int64)v20;
      if ( v20 && *((_BYTE *)v20 + 24) )
      {
        if ( (CallbackData->Flags & 2) != 0 )
          CallbackData->IoStatus.Status = 0;
        v22 = sub_180003060(a2, (__int64)CallbackData->Iopb, &v36);
        v23 = CallbackData->Iopb;
        P = v22;
        if ( v23->MajorFunction == 5 || v23->MajorFunction == 6 || v23->MajorFunction == 10 )
          EaList = (UCHAR)v23->Parameters.QueryEa.EaList;
        else
          EaList = v23->MinorFunction;
        v25 = v11->Length + v36 + 70;
        v26 = (unsigned __int8)(v23->MajorFunction + 20);
        IsPagingFile = FsRtlIsPagingFile(*(PFILE_OBJECT *)(a2 + 32));
        v28 = sub_180003D60(IsPagingFile == 0, 3u, v26, *(_DWORD *)(v21 + 12), 259, v25, &v30, (PSLIST_ENTRY *)&v33);
        v29 = v28;
        if ( v28 )
        {
          *(_BYTE *)v28 = EaList;
          *(_DWORD *)(v28 + 8) = CallbackData->Iopb->IrpFlags | (CallbackData->Iopb->OperationFlags << 20);
          *(_DWORD *)(v28 + 12) = CallbackData->Flags;
          *(_QWORD *)(v28 + 16) = CallbackData->Iopb->Parameters.Create.SecurityContext;
          *(_QWORD *)(v28 + 24) = CallbackData->Iopb->Parameters.QueryEa.EaList;
          *(_QWORD *)(v28 + 32) = CallbackData->Iopb->Parameters.Read.ByteOffset.QuadPart;
          *(_QWORD *)(v28 + 40) = CallbackData->Iopb->Parameters.CreatePipe.Parameters;
          *(_QWORD *)(v28 + 48) = CallbackData->Iopb->Parameters.Create.EaBuffer;
          *(_QWORD *)(v28 + 56) = CallbackData->Iopb->Parameters.Create.AllocationSize.QuadPart;
          *(_WORD *)(v28 + 64) = v11->Length >> 1;
          sub_18000AC00((_OWORD *)(v28 + 68), (char *)v11->Buffer, v11->Length);
          if ( v36 )
          {
            sub_18000AC00((_OWORD *)(v29 + v11->Length + 68i64), (char *)P, v36);
            ExFreePoolWithTag(P, 0);
          }
          sub_180004460(v33);
          v8 = 0;
          *v35 = v30;
        }
        sub_180004620(v21);
      }
      ExFreePoolWithTag(v11, 0);
      return v8;
    }
LABEL_12:
    if ( FltGetFileNameInformation(CallbackData, 0x402u, &FileNameInformation) < 0 )
    {
      if ( FsRtlIsPagingFile(*(PFILE_OBJECT *)(a2 + 32))
        && (v12 = *(_QWORD *)(a2 + 32), IoGetTopLevelIrp() == *(PIRP *)(v12 + 96)) )
      {
        v11 = sub_180003640(v12);
      }
      else
      {
        if ( FsRtlIsPagingFile(*(PFILE_OBJECT *)(a2 + 32)) )
        {
          TopLevelIrp = IoGetTopLevelIrp();
          IoSetTopLevelIrp(*(PIRP *)(*(_QWORD *)(a2 + 32) + 96i64));
          v4 = 1;
        }
        FltGetVolumeName(*(PFLT_VOLUME *)(a2 + 16), 0i64, &BufferSizeNeeded);
        BufferSizeNeeded += *(unsigned __int16 *)(*(_QWORD *)(a2 + 32) + 88i64);
        v13 = (struct _UNICODE_STRING *)DriverAllocateWithTag(NonPagedPool, BufferSizeNeeded + 16, 49);
        v11 = v13;
        if ( v13 )
        {
          v13->MaximumLength = BufferSizeNeeded;
          v13->Buffer = &v13[1].Length;
          FltGetVolumeName(*(PFLT_VOLUME *)(a2 + 16), v13, &BufferSizeNeeded);
          RtlAppendUnicodeStringToString(v11, (PCUNICODE_STRING)(*(_QWORD *)(a2 + 32) + 88i64));
        }
        if ( v4 )
          IoSetTopLevelIrp(TopLevelIrp);
      }
    }
    else
    {
      v11 = sub_1800078F0(NonPagedPool, &FileNameInformation->Name, 49);
      FltReleaseFileNameInformation(FileNameInformation);
    }
    if ( !v11 )
      return v8;
    goto LABEL_24;
  }
  if ( !qword_18000F2C8 )
  {
    sub_180001C20();
    return 1i64;
  }
  return v8;
}
// 18000F2C8: using guessed type __int64 qword_18000F2C8;
// 18000F2D0: using guessed type __int64 qword_18000F2D0;
// 18000F524: using guessed type int dword_18000F524;

//----- (0000000180002700) ----------------------------------------------------
__int64 __fastcall sub_180002700(int *a1, __int64 a2, __int64 a3, char a4)
{
  KIRQL CurrentIrql; // al
  _QWORD *v9; // rax
  _QWORD *v10; // rbx
  __int128 v11; // xmm0
  __int64 v12; // r9
  ULONG v13; // eax
  unsigned __int8 v14; // dl
  int v15; // r8d
  struct _KTHREAD *v16; // rcx
  char *v17; // rbx
  _OWORD *v18; // rax
  __int64 v19; // rax
  __int64 v21; // [rsp+50h] [rbp+8h] BYREF
  ULONG v22; // [rsp+68h] [rbp+20h] BYREF

  CurrentIrql = KeGetCurrentIrql();
  if ( (a4 & 1) == 0 )
  {
    if ( CurrentIrql == 2 )
    {
      v9 = DriverAllocateWithTag(NonPagedPool, 0x58u, 73);
      v10 = v9;
      if ( v9 )
      {
        v9[3] = v9;
        v9[2] = sub_1800037C0;
        *v9 = 0i64;
        v9[4] = *((_QWORD *)a1 + 1);
        *((_BYTE *)v9 + 40) = *(_BYTE *)(*((_QWORD *)a1 + 2) + 4i64);
        v9[6] = sub_180004080();
        v11 = *(_OWORD *)(a1 + 6);
        v10[9] = a3;
        *(_OWORD *)(v10 + 7) = v11;
        *((_DWORD *)v10 + 20) = *a1;
        ExQueueWorkItem((PWORK_QUEUE_ITEM)v10, DelayedWorkQueue);
      }
    }
    else
    {
      v12 = *((_QWORD *)a1 + 2);
      v13 = 8;
      v14 = *(_BYTE *)(v12 + 4);
      if ( v14 )
        v13 = a1[8];
      v15 = *a1;
      v16 = (struct _KTHREAD *)*((_QWORD *)a1 + 1);
      v22 = v13;
      v17 = (char *)sub_180002D80(v16, v14, v15, v12, a1 + 6, &v22);
      v18 = (_OWORD *)sub_180003D20(a3, a1[6], v22, (PSLIST_ENTRY *)&v21);
      if ( v22 )
      {
        if ( v18 )
          sub_18000AC00(v18, v17, v22);
        ExFreePoolWithTag(v17, 0);
      }
      sub_180004460(v21);
    }
  }
  v19 = *((_QWORD *)a1 + 2);
  if ( *(_BYTE *)(v19 + 4) == 13 && *(_DWORD *)(v19 + 40) == 589856 )
    FltDetachVolume(Filter, *(PFLT_VOLUME *)(a2 + 16), 0i64);
  return 0i64;
}

//----- (0000000180002870) ----------------------------------------------------
__int64 sub_180002870()
{
  return 0i64;
}

//----- (0000000180002880) ----------------------------------------------------
__int64 __fastcall ConnectNotifyCallback(
        PFLT_PORT ClientPort,
        PVOID ServerPortCookie,
        _DWORD *ConnectionContext,
        ULONG SizeOfContext,
        PVOID *ConnectionPortCookie)
{
  HANDLE CurrentProcessId; // rax

  if ( SizeOfContext != 4 )
    return 3221225485i64;
  if ( *ConnectionContext )
  {
    if ( *ConnectionContext == 1 )
    {
      ::ClientPort = ClientPort;
      *ConnectionPortCookie = &::ClientPort;
    }
    return 0i64;
  }
  else if ( qword_18000F2C8 )
  {
    return 3221225759i64;
  }
  else
  {
    sub_180001C20();
    sub_180004500(sub_180003630);
    qword_18000F2C8 = (__int64)IoGetCurrentProcess();
    CurrentProcessId = PsGetCurrentProcessId();
    qword_180010AE8 = ClientPort;
    qword_180010B00 = (__int64)CurrentProcessId;
    *ConnectionPortCookie = &qword_180010AE8;
    return 0i64;
  }
}
// 18000F2C8: using guessed type __int64 qword_18000F2C8;
// 180010B00: using guessed type __int64 qword_180010B00;

//----- (0000000180002930) ----------------------------------------------------
void __fastcall sub_180002930(char a1, struct _KTHREAD *a2, char a3, _OWORD *a4, char *VirtualAddress, ULONG *a6)
{
  char v8; // di
  ULONG *v9; // rsi
  PMDL Mdl; // rbx
  struct _KPROCESS *v11; // rax
  char *MappedSystemVa; // rax

  v8 = 1;
  if ( a1 == 1 || (a3 & 0xA) != 0 )
  {
    v9 = a6;
    sub_18000AC00(a4, VirtualAddress, *a6);
  }
  else
  {
    v9 = a6;
    Mdl = IoAllocateMdl(VirtualAddress, *a6, 0, 0, 0i64);
    if ( Mdl )
    {
      v11 = IoThreadToProcess(a2);
      MmProbeAndLockProcessPages(Mdl, v11, 0, IoReadAccess);
      if ( (Mdl->MdlFlags & 5) != 0 )
        MappedSystemVa = (char *)Mdl->MappedSystemVa;
      else
        MappedSystemVa = (char *)MmMapLockedPagesSpecifyCache(Mdl, 0, MmCached, 0i64, 0, 0x10u);
      if ( MappedSystemVa )
        sub_18000AC00(a4, MappedSystemVa, *a6);
      else
        v8 = 0;
      MmUnlockPages(Mdl);
      IoFreeMdl(Mdl);
    }
    else
    {
      v8 = 0;
    }
  }
  if ( !v8 )
  {
    *v9 = 0;
    ExFreePoolWithTag(a4, 0);
  }
}

//----- (0000000180002A90) ----------------------------------------------------
void __fastcall DisconnectNotifyCallback(PFLT_PORT *ConnectionCookie, __int64 a2, __int64 a3)
{
  ULONG v4; // edi
  PFLT_VOLUME *v5; // rax
  PFLT_VOLUME *v6; // rsi
  ULONG NumberVolumesReturned; // [rsp+30h] [rbp+8h] BYREF

  if ( ConnectionCookie == &qword_180010AE8 )
  {
    v4 = 0;
    qword_18000F2C8 = 0i64;
    sub_180007950(0, a2, a3);
    NumberVolumesReturned = 0;
    FltEnumerateVolumes(Filter, 0i64, 0, &NumberVolumesReturned);
    if ( NumberVolumesReturned )
    {
      v5 = (PFLT_VOLUME *)DriverAllocateWithTag(PagedPool, 8 * NumberVolumesReturned, 73);
      v6 = v5;
      if ( v5 )
      {
        if ( FltEnumerateVolumes(Filter, v5, 8 * NumberVolumesReturned, &NumberVolumesReturned) >= 0
          && NumberVolumesReturned )
        {
          do
          {
            FltDetachVolume(Filter, v6[v4], 0i64);
            FltObjectDereference(v6[v4++]);
          }
          while ( v4 < NumberVolumesReturned );
        }
        ExFreePoolWithTag(v6, 0);
      }
    }
  }
  FltCloseClientPort(Filter, ConnectionCookie);
}
// 18000F2C8: using guessed type __int64 qword_18000F2C8;

//----- (0000000180002BA0) ----------------------------------------------------
__int64 __fastcall sub_180002BA0(char a1)
{
  __int64 v2; // rdi
  PFLT_VOLUME *v3; // rax
  PFLT_VOLUME *v4; // rsi
  struct _FLT_VOLUME *v5; // rdx
  PFLT_VOLUME *v6; // rbx
  ULONG NumberVolumesReturned; // [rsp+48h] [rbp+10h] BYREF
  union _LARGE_INTEGER Interval; // [rsp+50h] [rbp+18h] BYREF

  v2 = 0i64;
  NumberVolumesReturned = 0;
  FltEnumerateVolumes(Filter, 0i64, 0, &NumberVolumesReturned);
  if ( !NumberVolumesReturned )
    return 0i64;
  v3 = (PFLT_VOLUME *)DriverAllocateWithTag(PagedPool, 8 * NumberVolumesReturned, 73);
  v4 = v3;
  if ( v3 )
  {
    if ( FltEnumerateVolumes(Filter, v3, 8 * NumberVolumesReturned, &NumberVolumesReturned) >= 0
      && NumberVolumesReturned )
    {
      do
      {
        v5 = v4[v2];
        v6 = &v4[v2];
        if ( a1 )
        {
          if ( FltAttachVolume(Filter, v5, 0i64, 0i64) == -1071906805 )
          {
            do
            {
              Interval.QuadPart = -10000000i64;
              KeDelayExecutionThread(0, 1u, &Interval);
            }
            while ( FltAttachVolume(Filter, *v6, 0i64, 0i64) == -1071906805 );
          }
        }
        else
        {
          FltDetachVolume(Filter, v5, 0i64);
        }
        FltObjectDereference(*v6);
        v2 = (unsigned int)(v2 + 1);
      }
      while ( (unsigned int)v2 < NumberVolumesReturned );
    }
    ExFreePoolWithTag(v4, 0);
  }
  return 0i64;
}

//----- (0000000180002CE0) ----------------------------------------------------
bool __fastcall sub_180002CE0(struct _UNICODE_STRING *a1)
{
  NTSTATUS v1; // ebx
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+70h] [rbp-48h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+80h] [rbp-38h] BYREF
  HANDLE FileHandle; // [rsp+C0h] [rbp+8h] BYREF

  ObjectAttributes.ObjectName = a1;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Length = 48;
  ObjectAttributes.Attributes = 576;
  *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0i64;
  v1 = FltCreateFile(Filter, 0i64, &FileHandle, 0, &ObjectAttributes, &IoStatusBlock, 0i64, 0, 7u, 1u, 0, 0i64, 0, 0);
  if ( v1 >= 0 )
    FltClose(FileHandle);
  return v1 == 0;
}
// 180002CE0: using guessed type struct _OBJECT_ATTRIBUTES anonymous_1;

//----- (0000000180002D80) ----------------------------------------------------
_OWORD *__fastcall sub_180002D80(struct _KTHREAD *a1, unsigned __int8 a2, char a3, __int64 a4, int *a5, ULONG *a6)
{
  int v8; // r8d
  char *v9; // r15
  unsigned int v10; // edx
  unsigned int v12; // r9d
  unsigned int v13; // edx
  _OWORD *v14; // rax
  _OWORD *v15; // rbx
  char *v16; // rax
  __int64 v17; // rcx
  char *v18; // rax

  v8 = a2;
  v9 = (char *)(a5 + 2);
  v10 = 0xFFFF;
  v12 = 0xFFFF;
  if ( *a6 < 0xFFFF )
    v12 = *a6;
  *a6 = v12;
  if ( *(_QWORD *)v9 || !(_BYTE)v8 )
  {
    switch ( v8 )
    {
      case 0:
        if ( *a5 < 0 )
          goto LABEL_29;
        v13 = v12;
        goto LABEL_8;
      case 3:
        *a6 = 8;
        v13 = 8;
LABEL_8:
        v14 = DriverAllocateWithTag(NonPagedPool, v13, 50);
        v15 = v14;
        if ( !v14 )
          goto LABEL_29;
        sub_180002930(1, a1, a3, v14, v9, a6);
        break;
      case 5:
      case 10:
        if ( *(_DWORD *)(a4 + 24) < 0xFFFFu )
          v10 = *(_DWORD *)(a4 + 24);
        *a6 = v10;
        v15 = DriverAllocateWithTag(NonPagedPool, v10, 50);
        if ( !v15 )
          goto LABEL_29;
        v16 = *(char **)(a4 + 40);
        goto LABEL_26;
      case 12:
        if ( *(_BYTE *)(a4 + 5) != 1 )
          goto LABEL_29;
        if ( *(_DWORD *)(a4 + 24) < 0xFFFFu )
          v10 = *(_DWORD *)(a4 + 24);
        *a6 = v10;
        v15 = DriverAllocateWithTag(NonPagedPool, v10, 50);
        if ( !v15 )
          goto LABEL_29;
        v17 = *(_QWORD *)(a4 + 64);
        if ( v17 )
        {
          if ( (*(_BYTE *)(v17 + 10) & 5) != 0 )
          {
            sub_18000AC00(v15, *(char **)(v17 + 24), *a6);
          }
          else
          {
            v18 = (char *)MmMapLockedPagesSpecifyCache((PMDL)v17, 0, MmCached, 0i64, 0, 0x10u);
            sub_18000AC00(v15, v18, *a6);
          }
        }
        else
        {
          v16 = *(char **)(a4 + 56);
LABEL_26:
          sub_180002930(0, a1, a3, v15, v16, a6);
        }
        break;
      case 242:
        v15 = DriverAllocateWithTag(NonPagedPool, v12, 50);
        if ( !v15 )
          goto LABEL_29;
        v16 = *(char **)(a4 + 32);
        goto LABEL_26;
      default:
        goto LABEL_29;
    }
    if ( *a6 )
      return v15;
  }
LABEL_29:
  *a6 = 0;
  return 0i64;
}

//----- (0000000180003060) ----------------------------------------------------
_OWORD *__fastcall sub_180003060(__int64 a1, __int64 a2, unsigned int *a3)
{
  int v3; // eax
  _OWORD *v6; // rbx
  char **v7; // r14
  unsigned __int8 v8; // bp
  void *v9; // rax
  void *v10; // rbx
  PSID *v11; // rax
  unsigned int v12; // edx
  _OWORD *v13; // rax
  __int64 *v14; // rax
  _OWORD *v15; // rax
  _OWORD *v16; // rax
  int v17; // eax
  unsigned int v18; // edx
  _OWORD *v19; // rax
  __int64 v20; // r8
  int Length; // ebp
  _OWORD *v22; // rax
  unsigned __int16 v23; // bp
  unsigned int v25; // edx
  _OWORD *v26; // rax
  int v27; // eax
  unsigned int v28; // edx
  _OWORD *v29; // rax
  unsigned __int16 *v30; // rax
  unsigned __int16 v31; // bp
  unsigned int v32; // edx
  char *v33; // rax
  __int16 v34; // bp
  PFLT_FILE_NAME_INFORMATION FileNameInformation; // [rsp+78h] [rbp+10h] BYREF
  __int64 v36; // [rsp+88h] [rbp+20h] BYREF

  v3 = *(unsigned __int8 *)(a2 + 4);
  FileNameInformation = 0i64;
  v6 = 0i64;
  v7 = 0i64;
  switch ( v3 )
  {
    case 0:
      v8 = 0;
      v9 = sub_180006430(1);
      v10 = v9;
      if ( v9 )
      {
        v11 = (PSID *)sub_180005D50(v9, 0i64, 0i64, 0i64);
        v7 = (char **)v11;
        if ( v11 )
          v8 = RtlLengthSid(*v11);
        ZwClose(v10);
      }
      v12 = v8 + 8;
      *a3 = v12;
      v13 = DriverAllocateWithTag(NonPagedPool, v12, 72);
      v6 = v13;
      if ( !v13 )
      {
        if ( !v8 )
          goto LABEL_31;
        ExFreePoolWithTag(v7, 0);
        goto LABEL_30;
      }
      sub_18000AC00(v13, (char *)(*(_QWORD *)(a2 + 24) + 16i64), *a3);
      *((_BYTE *)v6 + 4) = v8;
      if ( v8 )
      {
        sub_18000AC00((_OWORD *)((char *)v6 + 8), *v7, v8);
        ExFreePoolWithTag(v7, 0);
        goto LABEL_30;
      }
      break;
    case 6:
      v17 = *(_DWORD *)(a2 + 32);
      if ( v17 == 10 || (unsigned int)(v17 - 65) <= 1 )
      {
        v20 = *(_QWORD *)(a2 + 56);
        *a3 = *(_DWORD *)(a2 + 24) + 2;
        if ( FltGetDestinationFileNameInformation(
               *(PFLT_INSTANCE *)(a1 + 24),
               *(PFILE_OBJECT *)(a1 + 32),
               *(HANDLE *)(v20 + 8),
               (PWSTR)(v20 + 20),
               *(_DWORD *)(v20 + 16),
               0x101u,
               &FileNameInformation) )
        {
          FileNameInformation = 0i64;
          LOWORD(Length) = 0;
        }
        else
        {
          Length = FileNameInformation->Name.Length;
          *a3 += Length;
        }
        v22 = DriverAllocateWithTag(NonPagedPool, *a3, 72);
        v6 = v22;
        if ( v22 )
        {
          sub_18000AC00(v22, *(char **)(a2 + 56), *(unsigned int *)(a2 + 24));
          v23 = (unsigned __int16)Length >> 1;
          *(_WORD *)((char *)v6 + *(unsigned int *)(a2 + 24)) = v23;
          if ( v23 )
            sub_18000AC00(
              (_OWORD *)((char *)v6 + *(unsigned int *)(a2 + 24) + 2),
              (char *)FileNameInformation->Name.Buffer,
              2i64 * v23);
        }
        if ( FileNameInformation )
          FltReleaseFileNameInformation(FileNameInformation);
LABEL_30:
        if ( !v6 )
          goto LABEL_31;
      }
      else
      {
        v18 = *(_DWORD *)(a2 + 24);
        *a3 = v18;
        v19 = DriverAllocateWithTag(NonPagedPool, v18, 72);
        v6 = v19;
        if ( !v19 )
          goto LABEL_31;
        sub_18000AC00(v19, *(char **)(a2 + 56), *a3);
      }
      break;
    case 11:
      v25 = *(_DWORD *)(a2 + 24);
      *a3 = v25;
      v26 = DriverAllocateWithTag(NonPagedPool, v25, 72);
      v6 = v26;
      if ( !v26 )
        goto LABEL_31;
      sub_18000AC00(v26, *(char **)(a2 + 40), *a3);
      break;
    case 12:
      if ( *(_BYTE *)(a2 + 5) != 1 )
        goto LABEL_31;
      v30 = *(unsigned __int16 **)(a2 + 32);
      if ( !v30 || (v31 = *v30) == 0 )
        v31 = 0;
      v32 = v31 + 2;
      *a3 = v32;
      v33 = (char *)DriverAllocateWithTag(NonPagedPool, v32, 72);
      v6 = v33;
      if ( !v33 )
        goto LABEL_31;
      v34 = v31 >> 1;
      *(_WORD *)v33 = v34;
      if ( v34 )
        sub_18000AC00(v33 + 2, *(char **)(*(_QWORD *)(a2 + 32) + 8i64), *a3 - 2i64);
      break;
    case 13:
      v27 = *(_DWORD *)(a2 + 40);
      if ( v27 != 606820 && v27 != 623208 )
        goto LABEL_31;
      v28 = *(_DWORD *)(a2 + 32);
      *a3 = v28;
      v29 = DriverAllocateWithTag(NonPagedPool, v28, 72);
      v6 = v29;
      if ( !v29 )
        goto LABEL_31;
      sub_18000AC00(v29, *(char **)(a2 + 48), *a3);
      break;
    case 17:
      v14 = *(__int64 **)(a2 + 24);
      if ( v14 )
        v36 = *v14;
      else
        v36 = 0i64;
      *a3 = 8;
      v15 = DriverAllocateWithTag(NonPagedPool, 8u, 72);
      v6 = v15;
      if ( !v15 )
        goto LABEL_31;
      sub_18000AC00(v15, (char *)&v36, *a3);
      break;
    case 253:
      *a3 = 8;
      v16 = DriverAllocateWithTag(NonPagedPool, 8u, 72);
      v6 = v16;
      if ( !v16 )
        goto LABEL_31;
      sub_18000AC00(v16, *(char **)(a2 + 24), *a3);
      break;
    default:
LABEL_31:
      *a3 = 0;
      break;
  }
  return v6;
}

//----- (00000001800034E0) ----------------------------------------------------
__int64 __fastcall DriverStartUp(PDRIVER_OBJECT Driver)
{
  NTSTATUS started; // ebx
  struct _UNICODE_STRING DestinationString; // [rsp+48h] [rbp-50h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+58h] [rbp-40h] BYREF
  PSECURITY_DESCRIPTOR SecurityDescriptor; // [rsp+A8h] [rbp+10h] BYREF

  KeInitializeSpinLock(&SpinLock);
  started = FltRegisterFilter(Driver, &Registration, &Filter);
  if ( started >= 0 )
  {
    started = FltBuildDefaultSecurityDescriptor(&SecurityDescriptor, 0x1F0001u);
    if ( started >= 0 )
    {
      RtlInitUnicodeString(&DestinationString, L"\\ProcessMonitor24Port");
      ObjectAttributes.Length = 48;
      ObjectAttributes.RootDirectory = 0i64;
      ObjectAttributes.Attributes = 576;
      ObjectAttributes.ObjectName = &DestinationString;
      ObjectAttributes.SecurityDescriptor = SecurityDescriptor;
      ObjectAttributes.SecurityQualityOfService = 0i64;
      FltCreateCommunicationPort(
        Filter,
        &ServerPort,
        &ObjectAttributes,
        0i64,
        (PFLT_CONNECT_NOTIFY)ConnectNotifyCallback,
        (PFLT_DISCONNECT_NOTIFY)DisconnectNotifyCallback,
        (PFLT_MESSAGE_NOTIFY)MessageNotifyCallback,
        2);
      FltFreeSecurityDescriptor(SecurityDescriptor);
      started = FltStartFiltering(Filter);
    }
  }
  if ( started < 0 )
  {
    CloseDeviceAndLogging();
    if ( ServerPort )
      FltCloseCommunicationPort(ServerPort);
    if ( Filter )
      FltUnregisterFilter(Filter);
  }
  return (unsigned int)started;
}

//----- (0000000180003630) ----------------------------------------------------
__int64 sub_180003630()
{
  return sub_180004350((void (__fastcall *)(__int64, _QWORD))sub_180003850);
}

//----- (0000000180003640) ----------------------------------------------------
struct _UNICODE_STRING *__fastcall sub_180003640(__int64 a1)
{
  KIRQL v2; // di
  struct _UNICODE_STRING *v3; // rsi
  __int64 v4; // rdx

  v2 = 2;
  v3 = 0i64;
  if ( KeGetCurrentIrql() < 2u )
    v2 = KeAcquireSpinLockRaiseToDpc(&SpinLock);
  v4 = qword_18000F2D0;
  if ( qword_18000F2D0 )
  {
    while ( *(_QWORD *)(v4 + 8) != a1 )
    {
      v4 = *(_QWORD *)v4;
      if ( !v4 )
        goto LABEL_8;
    }
    v3 = sub_1800078F0(NonPagedPool, (const UNICODE_STRING *)(v4 + 16), 49);
  }
LABEL_8:
  if ( v2 != 2 )
    KeReleaseSpinLock(&SpinLock, v2);
  return v3;
}
// 18000F2D0: using guessed type __int64 qword_18000F2D0;

//----- (00000001800036D0) ----------------------------------------------------
__int64 __fastcall MessageNotifyCallback(
        PVOID PortCookie,
        char *InputBuffer,
        __int64 InputBufferLength,
        PVOID OutputBuffer)
{
  if ( (unsigned int)InputBufferLength >= 4 )
  {
    if ( *(_DWORD *)InputBuffer )
    {
      if ( *(_DWORD *)InputBuffer == 1 )
      {
        if ( (unsigned int)InputBufferLength >= 0xC )
        {
          sub_180007380(*(_QWORD *)(InputBuffer + 4));
          return 0i64;
        }
        return 3221225485i64;
      }
      return 0i64;
    }
    if ( (unsigned int)InputBufferLength >= 8 )
    {
      sub_180007950(*((_DWORD *)InputBuffer + 1), (__int64)InputBuffer, InputBufferLength);
      return 0i64;
    }
  }
  return 3221225485i64;
}

//----- (0000000180003720) ----------------------------------------------------
__int64 __fastcall sub_180003720(
        struct _KTHREAD *a1,
        unsigned __int8 a2,
        int *a3,
        __int64 a4,
        int a5,
        __int64 a6,
        char a7)
{
  ULONG v8; // eax
  char *v9; // rsi
  _OWORD *v10; // rax
  ULONG v12; // [rsp+48h] [rbp+10h] BYREF
  __int64 v13; // [rsp+50h] [rbp+18h] BYREF

  v8 = 8;
  if ( a2 )
    v8 = a3[2];
  v12 = v8;
  v9 = (char *)sub_180002D80(a1, a2, a7, a4, a3, &v12);
  v10 = (_OWORD *)sub_180003D20(a5, *a3, v12, (PSLIST_ENTRY *)&v13);
  if ( v10 && a6 )
    *((_QWORD *)v10 - 3) = a6;
  if ( v12 )
  {
    if ( v10 )
      sub_18000AC00(v10, v9, v12);
    ExFreePoolWithTag(v9, 0);
  }
  sub_180004460(v13);
  return 0i64;
}

//----- (00000001800037C0) ----------------------------------------------------
void __fastcall sub_1800037C0(__int64 a1)
{
  sub_180003720(
    *(struct _KTHREAD **)(a1 + 32),
    *(_BYTE *)(a1 + 40),
    (int *)(a1 + 56),
    0i64,
    *(_QWORD *)(a1 + 72),
    *(_QWORD *)(a1 + 48),
    *(_DWORD *)(a1 + 80));
  ExFreePoolWithTag((PVOID)a1, 0);
}

//----- (0000000180003810) ----------------------------------------------------
NTSTATUS __fastcall sub_180003810(PVOID SenderBuffer, ULONG SenderBufferLength, PVOID ReplyBuffer, PULONG ReplyLength)
{
  union _LARGE_INTEGER Timeout; // [rsp+40h] [rbp-18h] BYREF

  Timeout.QuadPart = -10000000i64;
  return FltSendMessage(Filter, &ClientPort, SenderBuffer, SenderBufferLength, ReplyBuffer, ReplyLength, &Timeout);
}

//----- (0000000180003850) ----------------------------------------------------
NTSTATUS __fastcall sub_180003850(PVOID SenderBuffer, ULONG SenderBufferLength)
{
  return FltSendMessage(Filter, &qword_180010AE8, SenderBuffer, SenderBufferLength, 0i64, 0i64, 0i64);
}

//----- (0000000180003890) ----------------------------------------------------
__int64 __fastcall sub_180003890(char a1, PVOID *a2, unsigned __int16 a3)
{
  __int64 v4; // r14
  unsigned __int16 v6; // di
  unsigned __int16 v7; // bx
  unsigned __int64 v8; // rcx
  struct _KTHREAD *CurrentThread; // rbx
  __int64 *v10; // rax
  PSLIST_ENTRY v11; // rax
  struct _SLIST_ENTRY *v12; // rax
  __int64 v13; // rcx
  unsigned __int64 HighLimit[5]; // [rsp+20h] [rbp-28h] BYREF
  unsigned __int64 LowLimit; // [rsp+68h] [rbp+20h] BYREF

  v4 = a3;
  v6 = RtlWalkFrameChain(a2, a3, 0);
  if ( qword_18000F388 )
  {
    v7 = 0;
    if ( v6 )
    {
      do
      {
        v8 = (unsigned __int64)a2[v7];
        if ( v8 <= qword_18000F388 )
          break;
        if ( v8 >= qword_18000F388 + (unsigned __int64)(unsigned int)dword_180010A78 )
          break;
        ++v7;
      }
      while ( v7 < v6 );
      if ( v7 )
      {
        sub_18000AC00(a2, (char *)&a2[v7], 8 * (v4 - v7));
        v6 -= v7;
      }
    }
  }
  if ( a1 )
  {
    CurrentThread = KeGetCurrentThread();
    ExAcquireFastMutex(&g_FastMutek2);
    v10 = (__int64 *)qword_1800109A0;
    if ( (__int64 *)qword_1800109A0 != &qword_1800109A0 )
    {
      while ( (struct _KTHREAD *)*(v10 - 1) != CurrentThread )
      {
        v10 = (__int64 *)*v10;
        if ( v10 == &qword_1800109A0 )
          goto LABEL_12;
      }
      ++*((_DWORD *)v10 - 4);
      goto LABEL_17;
    }
LABEL_12:
    ++dword_18000F3D4;
    v11 = ExpInterlockedPopEntrySList(&ListHead);
    if ( !v11 )
    {
      ++dword_18000F3D8;
      v11 = (PSLIST_ENTRY)qword_18000F3F0(
                            (unsigned int)dword_18000F3E4,
                            (unsigned int)dword_18000F3EC,
                            (unsigned int)dword_18000F3E8);
      if ( !v11 )
      {
LABEL_17:
        ExReleaseFastMutex(&g_FastMutek2);
LABEL_18:
        sub_180003A60();
        return 0i64;
      }
    }
    LODWORD(v11->Next) = 1;
    *((_QWORD *)&v11->Next + 1) = CurrentThread;
    v12 = v11 + 1;
    v13 = qword_1800109A0;
    if ( *(__int64 **)(qword_1800109A0 + 8) != &qword_1800109A0 )
      __fastfail(3u);
    v12->Next = (struct _SLIST_ENTRY *)qword_1800109A0;
    *((_QWORD *)&v12->Next + 1) = &qword_1800109A0;
    *(_QWORD *)(v13 + 8) = v12;
    qword_1800109A0 = (__int64)v12;
    ExReleaseFastMutex(&g_FastMutek2);
    IoGetStackLimits(&LowLimit, HighLimit);
    if ( (unsigned __int64)HighLimit - LowLimit < 0x1000 )
      goto LABEL_18;
    v6 += RtlWalkFrameChain(&a2[v6], v4 - v6, 1u);
    sub_180003A60();
  }
  return v6;
}
// 18000F388: using guessed type __int64 qword_18000F388;
// 18000F3D4: using guessed type int dword_18000F3D4;
// 18000F3D8: using guessed type int dword_18000F3D8;
// 18000F3E4: using guessed type int dword_18000F3E4;
// 18000F3E8: using guessed type int dword_18000F3E8;
// 18000F3EC: using guessed type int dword_18000F3EC;
// 18000F3F0: using guessed type __int64 (__fastcall *qword_18000F3F0)(_QWORD, _QWORD, _QWORD);
// 1800109A0: using guessed type __int64 qword_1800109A0;
// 180010A78: using guessed type int dword_180010A78;

//----- (0000000180003A60) ----------------------------------------------------
void sub_180003A60()
{
  struct _KTHREAD *CurrentThread; // rbx
  __int64 *v1; // rax
  struct _SLIST_ENTRY *v2; // rbx
  __int64 v4; // rdx
  __int64 *v5; // rcx

  CurrentThread = KeGetCurrentThread();
  ExAcquireFastMutex(&g_FastMutek2);
  v1 = (__int64 *)qword_1800109A0;
  if ( (__int64 *)qword_1800109A0 != &qword_1800109A0 )
  {
    while ( (struct _KTHREAD *)*(v1 - 1) != CurrentThread )
    {
      v1 = (__int64 *)*v1;
      if ( v1 == &qword_1800109A0 )
        goto LABEL_11;
    }
    v2 = (struct _SLIST_ENTRY *)(v1 - 2);
    if ( v1 != (__int64 *)16 && LODWORD(v2->Next)-- == 1 )
    {
      v4 = *v1;
      if ( *(__int64 **)(*v1 + 8) != v1 || (v5 = (__int64 *)v1[1], (__int64 *)*v5 != v1) )
        __fastfail(3u);
      *v5 = v4;
      *(_QWORD *)(v4 + 8) = v5;
      ++dword_18000F3DC;
      if ( ExQueryDepthSList(&ListHead) < (unsigned __int16)word_18000F3D0 )
      {
        ExpInterlockedPushEntrySList(&ListHead, v2);
      }
      else
      {
        ++dword_18000F3E0;
        qword_18000F3F8(v2);
      }
    }
  }
LABEL_11:
  ExReleaseFastMutex(&g_FastMutek2);
}
// 18000F3D0: using guessed type __int16 word_18000F3D0;
// 18000F3DC: using guessed type int dword_18000F3DC;
// 18000F3E0: using guessed type int dword_18000F3E0;
// 18000F3F8: using guessed type __int64 (__fastcall *qword_18000F3F8)(_QWORD);
// 1800109A0: using guessed type __int64 qword_1800109A0;

//----- (0000000180003B40) ----------------------------------------------------
void sub_180003B40()
{
  ExAcquireFastMutex(&g_FastMutek);
  byte_18000F384 = 0;
  byte_18000F385 = 0;
  KeClearEvent(&g_KeEvent);
  ExReleaseFastMutex(&g_FastMutek);
}
// 18000F384: using guessed type char byte_18000F384;
// 18000F385: using guessed type char byte_18000F385;

//----- (0000000180003B80) ----------------------------------------------------
void __fastcall sub_180003B80(char a1)
{
  __int64 **i; // rax
  __int64 *v2; // rcx
  struct _SLIST_ENTRY *v3; // rbx

  if ( a1 )
  {
    qword_1800109C0 = MEMORY[0xFFFFF78000000014];
    qword_1800109B8 = KeQueryPerformanceCounter(&PerformanceFrequency).QuadPart;
    KeCancelTimer(&g_KeTimer);
    byte_18000F384 = 0;
    byte_18000F385 = 0;
  }
  else
  {
    ExAcquireFastMutex(&g_FastMutek);
    for ( i = (__int64 **)qword_180010AC0; (__int64 *)qword_180010AC0 != &qword_180010AC0; i = (__int64 **)qword_180010AC0 )
    {
      if ( i[1] != &qword_180010AC0 || (v2 = *i, (__int64 **)(*i)[1] != i) )
        __fastfail(3u);
      qword_180010AC0 = (__int64)*i;
      v3 = (struct _SLIST_ENTRY *)(i - 1);
      v2[1] = (__int64)&qword_180010AC0;
      ++dword_18000F31C;
      if ( ExQueryDepthSList(&SListHead) < (unsigned __int16)word_18000F310 )
      {
        ExpInterlockedPushEntrySList(&SListHead, v3);
      }
      else
      {
        ++dword_18000F320;
        qword_18000F338(v3);
      }
    }
    ExReleaseFastMutex(&g_FastMutek);
  }
}
// 18000F310: using guessed type __int16 word_18000F310;
// 18000F31C: using guessed type int dword_18000F31C;
// 18000F320: using guessed type int dword_18000F320;
// 18000F338: using guessed type __int64 (__fastcall *qword_18000F338)(_QWORD);
// 18000F384: using guessed type char byte_18000F384;
// 18000F385: using guessed type char byte_18000F385;
// 1800109B8: using guessed type __int64 qword_1800109B8;
// 1800109C0: using guessed type __int64 qword_1800109C0;
// 180010AC0: using guessed type __int64 qword_180010AC0;

//----- (0000000180003C90) ----------------------------------------------------
__int64 __fastcall sub_180003C90(unsigned __int8 a1, __int16 a2, int a3, int a4, int a5, PSLIST_ENTRY *a6)
{
  unsigned __int16 v10; // ax
  PVOID v12[150]; // [rsp+40h] [rbp-4B8h] BYREF

  v10 = sub_180003890(1, v12, 0x96u);
  return sub_180003E30(a1, a2, a3, a4, a5, a6, v10, (char *)v12);
}
// 180003C90: using guessed type PVOID var_4B8[150];

//----- (0000000180003D20) ----------------------------------------------------
__int64 __fastcall sub_180003D20(int a1, int a2, int a3, PSLIST_ENTRY *a4)
{
  return sub_180003E30(0, 0, a1, a2, a3, a4, 0, 0i64);
}

//----- (0000000180003D60) ----------------------------------------------------
__int64 __fastcall sub_180003D60(
        char a1,
        unsigned __int8 a2,
        __int16 a3,
        int a4,
        int a5,
        int a6,
        _DWORD *a7,
        PSLIST_ENTRY *a8)
{
  unsigned __int16 v12; // bx
  __int64 result; // rax
  PVOID v14[150]; // [rsp+40h] [rbp-4B8h] BYREF

  IoGetTopLevelIrp();
  if ( (unsigned int)IoGetTopLevelIrp() >= 0xFFFF )
    v12 = 0;
  else
    v12 = sub_180003890(a1, v14, 0x96u);
  result = sub_180003E30(a2, a3, a4, a5, a6, a8, v12, (char *)v14);
  if ( result )
    *a7 = *(_DWORD *)(result - 8i64 * v12 - 36);
  return result;
}
// 180003D60: using guessed type PVOID var_4B8[150];

//----- (0000000180003E30) ----------------------------------------------------
__int64 __fastcall sub_180003E30(
        unsigned __int8 a1,
        __int16 a2,
        int a3,
        int a4,
        int a5,
        PSLIST_ENTRY *a6,
        unsigned __int16 a7,
        char *a8)
{
  __int16 v10; // bp
  unsigned int v11; // esi
  unsigned int v13; // edi
  __int64 v14; // rbx
  PSLIST_ENTRY v15; // rdx
  struct _SLIST_ENTRY *v16; // rax
  struct _SLIST_ENTRY *v17; // rcx
  __int64 v18; // rdi
  signed __int32 v19; // eax
  unsigned int CurrentThreadId; // eax
  __int64 v21; // r9
  LONGLONG v22; // rax
  LONGLONG v23; // rcx

  v10 = a1;
  v11 = (a5 + 3) & 0xFFFFFFFC;
  v13 = v11 + 8 * a7 + 52;
  v14 = 0i64;
  ExAcquireFastMutex(&g_FastMutek);
  if ( (__int64 *)qword_180010AC0 != &qword_180010AC0 )
  {
    v15 = (PSLIST_ENTRY)(qword_180010AC8 - 8);
    if ( 0x20000 - (unsigned __int64)*(unsigned int *)(qword_180010AC8 - 8 + 24) >= v13 )
      goto LABEL_10;
    if ( MEMORY[0xFFFFF78000000014] - *(_QWORD *)(qword_180010AC0 - 8) > qword_180010AD0 )
      goto LABEL_19;
  }
  ++dword_18000F314;
  v15 = ExpInterlockedPopEntrySList(&SListHead);
  if ( !v15 )
  {
    ++dword_18000F318;
    v15 = (PSLIST_ENTRY)qword_18000F330(
                          (unsigned int)dword_18000F324,
                          (unsigned int)dword_18000F32C,
                          (unsigned int)dword_18000F328);
  }
  if ( !v15 )
  {
LABEL_19:
    ExReleaseFastMutex(&g_FastMutek);
    *a6 = 0i64;
    return v14;
  }
  v15->Next = (struct _SLIST_ENTRY *)MEMORY[0xFFFFF78000000014];
  v16 = (struct _SLIST_ENTRY *)(&v15->Next + 1);
  *((_DWORD *)&v15[1].Next + 2) = 0;
  v17 = (struct _SLIST_ENTRY *)qword_180010AC8;
  if ( *(__int64 **)qword_180010AC8 != &qword_180010AC0 )
    __fastfail(3u);
  v16->Next = (struct _SLIST_ENTRY *)&qword_180010AC0;
  v15[1].Next = v17;
  v17->Next = v16;
  qword_180010AC8 = (__int64)(&v15->Next + 1);
LABEL_10:
  *((_DWORD *)&v15[1].Next + 2) += v13;
  *a6 = v15;
  v18 = (__int64)&v15[1].Next + *((_DWORD *)&v15[1].Next + 2) - v13 + 12;
  if ( v18 )
  {
    if ( (_BYTE)v10 != 1 || a2 )
    {
      if ( !(_BYTE)v10 )
      {
        *(_DWORD *)(v18 + 16) = a3;
LABEL_18:
        *(_WORD *)(v18 + 8) = v10;
        *(_WORD *)(v18 + 12) = a2;
        *(_WORD *)(v18 + 10) = 0;
        *(_DWORD *)v18 = a3;
        CurrentThreadId = (unsigned int)PsGetCurrentThreadId();
        *(_DWORD *)(v18 + 36) = a4;
        *(_DWORD *)(v18 + 4) = CurrentThreadId;
        *(_DWORD *)(v18 + 44) = v11;
        v21 = *(_QWORD *)&KeQueryPerformanceCounter(0i64) - qword_1800109B8;
        v22 = v21 / PerformanceFrequency.QuadPart;
        v23 = 10000000 * (v21 % PerformanceFrequency.QuadPart) / PerformanceFrequency.QuadPart + qword_1800109C0;
        *(_WORD *)(v18 + 40) = a7;
        *(_QWORD *)(v18 + 28) = v23 + 10000000 * v22;
        sub_18000AC00((_OWORD *)(v18 + 52), a8, 8i64 * a7);
        return v18 + 8i64 * a7 + 52;
      }
      v19 = _InterlockedIncrement(&dword_18000F380);
    }
    else
    {
      v19 = dword_18000F380;
    }
    *(_DWORD *)(v18 + 16) = v19;
    goto LABEL_18;
  }
  return v14;
}
// 18000F314: using guessed type int dword_18000F314;
// 18000F318: using guessed type int dword_18000F318;
// 18000F324: using guessed type int dword_18000F324;
// 18000F328: using guessed type int dword_18000F328;
// 18000F32C: using guessed type int dword_18000F32C;
// 18000F330: using guessed type __int64 (__fastcall *qword_18000F330)(_QWORD, _QWORD, _QWORD);
// 18000F380: using guessed type int dword_18000F380;
// 1800109B8: using guessed type __int64 qword_1800109B8;
// 1800109C0: using guessed type __int64 qword_1800109C0;
// 180010AC0: using guessed type __int64 qword_180010AC0;
// 180010AC8: using guessed type __int64 qword_180010AC8;
// 180010AD0: using guessed type __int64 qword_180010AD0;

//----- (0000000180004080) ----------------------------------------------------
LONGLONG sub_180004080()
{
  __int64 v0; // r9

  v0 = *(_QWORD *)&KeQueryPerformanceCounter(0i64) - qword_1800109B8;
  return 10000000 * (v0 % PerformanceFrequency.QuadPart) / PerformanceFrequency.QuadPart
       + qword_1800109C0
       + 10000000 * (v0 / PerformanceFrequency.QuadPart);
}
// 1800109B8: using guessed type __int64 qword_1800109B8;
// 1800109C0: using guessed type __int64 qword_1800109C0;

//----- (00000001800040E0) ----------------------------------------------------
__int64 DriverKeInitialize()
{
  unsigned int *v0; // rbx
  unsigned int v1; // edx
  unsigned int *v2; // rcx
  unsigned __int64 v3; // r8
  __int64 v4; // rcx
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+40h] [rbp-38h] BYREF
  ULONG ReturnLength; // [rsp+80h] [rbp+8h] BYREF
  void *ThreadHandle; // [rsp+88h] [rbp+10h] BYREF

  KeInitializeEvent(&g_KeEvent, SynchronizationEvent, 0);
  KeInitializeTimer(&g_KeTimer);
  KeInitializeDpc(&g_KeDpc, (PKDEFERRED_ROUTINE)sub_180004580, 0i64);
  qword_180010AC8 = (__int64)&qword_180010AC0;
  qword_180010AC0 = (__int64)&qword_180010AC0;
  ExInitializeNPagedLookasideList((PNPAGED_LOOKASIDE_LIST)&SListHead, 0i64, 0i64, 0, 0x20020ui64, 0x6E6D50u, 0);
  g_FastMutek.Count = 1;
  g_FastMutek.Owner = 0i64;
  g_FastMutek.Contention = 0;
  KeInitializeEvent(&g_FastMutek.Event, SynchronizationEvent, 0);
  qword_1800109A8 = (__int64)&qword_1800109A0;
  qword_1800109A0 = (__int64)&qword_1800109A0;
  ExInitializeNPagedLookasideList((PNPAGED_LOOKASIDE_LIST)&ListHead, 0i64, 0i64, 0, 0x20ui64, 0x6E6D50u, 0);
  g_FastMutek2.Count = 1;
  g_FastMutek2.Owner = 0i64;
  g_FastMutek2.Contention = 0;
  KeInitializeEvent(&g_FastMutek2.Event, SynchronizationEvent, 0);
  ReturnLength = 1000;
  v0 = (unsigned int *)DriverAllocateWithTag(PagedPool, 0x3E8u, 71);
  if ( v0 )
  {
    while ( ZwQuerySystemInformation(SystemModuleInformation, v0, ReturnLength, &ReturnLength) )
    {
      ExFreePoolWithTag(v0, 0);
      ReturnLength += 1000;
      v0 = (unsigned int *)DriverAllocateWithTag(PagedPool, ReturnLength, 71);
      if ( !v0 )
        goto LABEL_13;
    }
    v1 = 0;
    if ( *v0 )
    {
      v2 = v0 + 8;
      while ( 1 )
      {
        v3 = *((_QWORD *)v2 - 1);
        if ( (unsigned __int64)DriverKeInitialize > v3 && (unsigned __int64)DriverKeInitialize < v3 + *v2 )
          break;
        ++v1;
        v2 += 74;
        if ( v1 >= *v0 )
          goto LABEL_12;
      }
      v4 = 74i64 * v1;
      qword_18000F388 = *(_QWORD *)&v0[v4 + 6];
      dword_180010A78 = v0[v4 + 8];
    }
LABEL_12:
    ExFreePoolWithTag(v0, 0);
  }
LABEL_13:
  qword_180010AD0 = 100000000i64;
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 512;
  ObjectAttributes.ObjectName = 0i64;
  *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0i64;
  PsCreateSystemThread(&ThreadHandle, 0x1FFFFFu, &ObjectAttributes, 0i64, 0i64, (PKSTART_ROUTINE)StartRoutine, 0i64);
  return 0i64;
}
// 18000F388: using guessed type __int64 qword_18000F388;
// 1800109A0: using guessed type __int64 qword_1800109A0;
// 1800109A8: using guessed type __int64 qword_1800109A8;
// 180010A78: using guessed type int dword_180010A78;
// 180010AC0: using guessed type __int64 qword_180010AC0;
// 180010AC8: using guessed type __int64 qword_180010AC8;
// 180010AD0: using guessed type __int64 qword_180010AD0;

//----- (0000000180004350) ----------------------------------------------------
__int64 __fastcall sub_180004350(void (__fastcall *a1)(__int64, _QWORD))
{
  __int64 v2; // rdi
  __int64 v3; // rax
  int v4; // ebx

  v2 = 0i64;
  ExAcquireFastMutex(&g_FastMutek);
  if ( (__int64 *)qword_180010AC0 == &qword_180010AC0 )
  {
    v4 = -1073741807;
LABEL_10:
    byte_18000F384 = 0;
    byte_18000F385 = 0;
    KeClearEvent(&g_KeEvent);
    goto LABEL_11;
  }
  v2 = qword_180010AC0;
  v3 = *(_QWORD *)qword_180010AC0;
  if ( *(__int64 **)(qword_180010AC0 + 8) != &qword_180010AC0 || *(_QWORD *)(v3 + 8) != qword_180010AC0 )
    __fastfail(3u);
  qword_180010AC0 = *(_QWORD *)qword_180010AC0;
  v4 = -1073741807;
  *(_QWORD *)(v3 + 8) = &qword_180010AC0;
  if ( (__int64 *)qword_180010AC0 != &qword_180010AC0 )
    v4 = 0;
  if ( v4 < 0 )
    goto LABEL_10;
LABEL_11:
  ExReleaseFastMutex(&g_FastMutek);
  if ( v2 )
  {
    a1(v2 + 16, (unsigned int)(*(_DWORD *)(v2 + 16) + 4));
    ++dword_18000F31C;
    if ( ExQueryDepthSList(&SListHead) < (unsigned __int16)word_18000F310 )
    {
      ExpInterlockedPushEntrySList(&SListHead, (PSLIST_ENTRY)(v2 - 8));
    }
    else
    {
      ++dword_18000F320;
      qword_18000F338(v2 - 8);
    }
  }
  return (unsigned int)v4;
}
// 18000F310: using guessed type __int16 word_18000F310;
// 18000F31C: using guessed type int dword_18000F31C;
// 18000F320: using guessed type int dword_18000F320;
// 18000F338: using guessed type __int64 (__fastcall *qword_18000F338)(_QWORD);
// 18000F384: using guessed type char byte_18000F384;
// 18000F385: using guessed type char byte_18000F385;
// 180010AC0: using guessed type __int64 qword_180010AC0;

//----- (0000000180004460) ----------------------------------------------------
void __fastcall sub_180004460(__int64 a1)
{
  if ( a1 )
  {
    if ( byte_18000F384 )
    {
      if ( !byte_18000F385 && qword_180010AC0 == a1 + 8 && *(_DWORD *)(a1 + 24) > 0x10000u )
      {
        KeCancelTimer(&g_KeTimer);
        KeSetEvent(&g_KeEvent, 0, 0);
        byte_18000F385 = 1;
      }
    }
    else
    {
      KeSetTimer(&g_KeTimer, (LARGE_INTEGER)-2500000i64, &g_KeDpc);
    }
    byte_18000F384 = 1;
    ExReleaseFastMutex(&g_FastMutek);
  }
}
// 18000F384: using guessed type char byte_18000F384;
// 18000F385: using guessed type char byte_18000F385;
// 180010AC0: using guessed type __int64 qword_180010AC0;

//----- (0000000180004500) ----------------------------------------------------
LONG __fastcall sub_180004500(__int64 (*a1)(void))
{
  qword_180010948 = a1;
  return KeSetEvent(&g_KeEvent, 0, 0);
}
// 180010948: using guessed type __int64 (*qword_180010948)(void);

//----- (0000000180004520) ----------------------------------------------------
void __fastcall StartRoutine(PVOID StartContext)
{
  while ( !KeWaitForSingleObject(&g_KeEvent, Executive, 0, 0, 0i64) )
  {
    while ( (int)qword_180010948() >= 0 )
      ;
  }
}
// 180010948: invalid function type '?' has been ignored
// 180010948: using guessed type __int64 (*qword_180010948)(void);

//----- (0000000180004580) ----------------------------------------------------
void __fastcall sub_180004580(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
  KeSetEvent(&g_KeEvent, 0, 0);
}

//----- (00000001800045A0) ----------------------------------------------------
_OWORD *__fastcall sub_1800045A0(__int64 a1, __int64 a2, char a3)
{
  unsigned __int16 v5; // di
  _OWORD *result; // rax

  v5 = *(_WORD *)a2 >> 1;
  result = DriverAllocateWithTag(NonPagedPool, 2 * (unsigned int)v5 + 2, a3);
  *(_QWORD *)(a1 + 8) = result;
  if ( result )
  {
    sub_18000AC00(result, *(char **)(a2 + 8), 2i64 * v5);
    result = *(_OWORD **)(a1 + 8);
    *((_WORD *)result + v5) = 0;
    *(_WORD *)a1 = 2 * v5;
  }
  return result;
}

//----- (0000000180004620) ----------------------------------------------------
void __fastcall sub_180004620(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rcx
  _QWORD *v4; // rdx

  if ( a1 && _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 8), 0xFFFFFFFF) == 1 )
  {
    ExAcquireFastMutex(&g_KeMutek3);
    if ( *(_DWORD *)(a1 + 8) )
    {
      ExReleaseFastMutex(&g_KeMutek3);
    }
    else
    {
      v2 = *(_QWORD *)(a1 + 40);
      v3 = a1 + 40;
      if ( v2 )
      {
        if ( *(_QWORD *)(v2 + 8) != v3 || (v4 = *(_QWORD **)(a1 + 48), *v4 != v3) )
          __fastfail(3u);
        *v4 = v2;
        *(_QWORD *)(v2 + 8) = v4;
      }
      ExReleaseFastMutex(&g_KeMutek3);
      ExFreePoolWithTag((PVOID)a1, 0);
    }
  }
}

//----- (00000001800046B0) ----------------------------------------------------
__int64 *__fastcall sub_1800046B0(__int64 a1, char a2)
{
  __int64 *v5; // rbx
  __int64 *v6; // rax
  __int64 *v7; // rdi
  signed __int32 v8; // ecx
  __int64 v9; // rcx
  _QWORD *v10; // rax

  ExAcquireFastMutex(&g_KeMutek3);
  if ( !dword_18000F524 )
  {
    ExReleaseFastMutex(&g_KeMutek3);
    return 0i64;
  }
  v5 = sub_180004830(a1);
  ExReleaseFastMutex(&g_KeMutek3);
  if ( v5 )
    goto LABEL_15;
  v6 = (__int64 *)DriverAllocateWithTag(NonPagedPool, 0x48u, 55);
  v7 = v6;
  if ( v6 )
  {
    v8 = _InterlockedExchangeAdd(&dword_18000F440, 1u);
    v6[2] = a1;
    *((_DWORD *)v6 + 3) = v8 + 1;
    *((_DWORD *)v6 + 2) = 1;
    *((_BYTE *)v6 + 24) = 0;
    v6[4] = 0i64;
    *v6 = 0i64;
    ExAcquireFastMutex(&g_KeMutek3);
    v5 = sub_180004830(a1);
    if ( v5 || !dword_18000F524 )
    {
      ExReleaseFastMutex(&g_KeMutek3);
      if ( v5 != v7 )
      {
        ExFreePoolWithTag(v7, 0);
        goto LABEL_14;
      }
    }
    else
    {
      v9 = qword_180010930;
      v5 = v7;
      v10 = v7 + 5;
      if ( *(__int64 **)(qword_180010930 + 8) != &qword_180010930 )
        __fastfail(3u);
      *v10 = qword_180010930;
      v7[6] = (__int64)&qword_180010930;
      *(_QWORD *)(v9 + 8) = v10;
      qword_180010930 = (__int64)(v7 + 5);
      _InterlockedIncrement((volatile signed __int32 *)v7 + 2);
      ExReleaseFastMutex(&g_KeMutek3);
    }
    if ( a2 )
      sub_180004ED0((__int64)v5);
LABEL_14:
    if ( v5 )
    {
LABEL_15:
      if ( v5[4] || a2 && !*((_BYTE *)v5 + 24) )
        sub_180004ED0((__int64)v5);
    }
  }
  return v5;
}
// 18000F440: using guessed type int dword_18000F440;
// 18000F524: using guessed type int dword_18000F524;
// 180010930: using guessed type __int64 qword_180010930;

//----- (0000000180004830) ----------------------------------------------------
__int64 *__fastcall sub_180004830(__int64 a1)
{
  __int64 *v1; // rax
  __int64 v3; // rcx
  __int64 *v4; // r8
  __int64 v5; // rcx

  v1 = (__int64 *)qword_180010930;
  if ( (__int64 *)qword_180010930 == &qword_180010930 )
    return 0i64;
  while ( *(v1 - 3) != a1 )
  {
    v1 = (__int64 *)*v1;
    if ( v1 == &qword_180010930 )
      return 0i64;
  }
  _InterlockedIncrement((volatile signed __int32 *)v1 - 8);
  if ( (__int64 *)qword_180010930 != v1 )
  {
    v3 = *v1;
    if ( *(__int64 **)(*v1 + 8) != v1
      || (v4 = (__int64 *)v1[1], (__int64 *)*v4 != v1)
      || (*v4 = v3,
          *(_QWORD *)(v3 + 8) = v4,
          v5 = qword_180010930,
          *(__int64 **)(qword_180010930 + 8) != &qword_180010930) )
    {
      __fastfail(3u);
    }
    *v1 = qword_180010930;
    v1[1] = (__int64)&qword_180010930;
    *(_QWORD *)(v5 + 8) = v1;
    qword_180010930 = (__int64)v1;
  }
  return v1 - 5;
}
// 180010930: using guessed type __int64 qword_180010930;

//----- (00000001800048B0) ----------------------------------------------------
__int64 __fastcall sub_1800048B0(char a1, PVOID *a2, _OWORD *a3, _OWORD *a4)
{
  void *v8; // rbx
  unsigned int v9; // edi
  struct _CLIENT_ID ClientId; // [rsp+30h] [rbp-98h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+40h] [rbp-88h] BYREF
  unsigned int ProcessInformation[22]; // [rsp+70h] [rbp-58h] BYREF
  void *ProcessHandle; // [rsp+D8h] [rbp+10h] BYREF

  ObjectAttributes.Length = 48;
  ObjectAttributes.Attributes = 512;
  *a3 = 0i64;
  a3[1] = 0i64;
  *a4 = 0i64;
  a4[1] = 0i64;
  ClientId.UniqueThread = 0i64;
  a4[2] = 0i64;
  ObjectAttributes.RootDirectory = 0i64;
  a4[3] = 0i64;
  ObjectAttributes.ObjectName = 0i64;
  a4[4] = 0i64;
  *((_QWORD *)a4 + 10) = 0i64;
  ClientId.UniqueProcess = a2[2];
  *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0i64;
  if ( ZwOpenProcess(&ProcessHandle, 0, &ObjectAttributes, &ClientId) < 0 )
    return 0i64;
  v8 = ProcessHandle;
  if ( !ProcessHandle )
    return 0i64;
  v9 = 0;
  if ( ZwQueryInformationProcess(ProcessHandle, ProcessBasicInformation, ProcessInformation, 0x30u, 0i64) >= 0 )
    v9 = ProcessInformation[0];
  ZwQueryInformationProcess(v8, ProcessTimes, a3, 0x20u, 0i64);
  ZwQueryInformationProcess(v8, ProcessVmCounters, a4, 0x58u, 0i64);
  if ( a1 )
    ObReferenceObjectByHandle(v8, 0, 0i64, 0, a2, 0i64);
  ZwClose(v8);
  return v9;
}
// 1800048B0: using guessed type unsigned int ProcessInformation[22];

//----- (0000000180004A30) ----------------------------------------------------
void __fastcall sub_180004A30(void *a1)
{
  ExFreePoolWithTag(a1, 0);
}

//----- (0000000180004A40) ----------------------------------------------------
void __fastcall sub_180004A40(__int64 a1, __int64 a2, __int64 a3)
{
  int v4; // ebp
  __int64 *v5; // rax
  __int64 v6; // rsi
  __int64 v7; // rdx
  unsigned __int16 *v8; // rdi
  int SenderBuffer; // [rsp+30h] [rbp-18h] BYREF
  __int64 v10; // [rsp+34h] [rbp-14h]
  ULONG ReplyLength; // [rsp+58h] [rbp+10h] BYREF

  v4 = a3;
  v5 = sub_1800046B0(a3, 1);
  v6 = (__int64)v5;
  if ( v5 )
  {
    v7 = *(_QWORD *)(a2 + 40);
    if ( v7 )
    {
      sub_180004B60(
        *((_DWORD *)v5 + 3),
        (unsigned __int16 *)(v7 + 8),
        *(_QWORD *)(a2 + 8),
        *(_QWORD *)(a2 + 24),
        *(_WORD *)(a2 + 48),
        (char *)(a2 + 56));
      FltReleaseFileNameInformation(*(PFLT_FILE_NAME_INFORMATION *)(a2 + 40));
    }
    else
    {
      v8 = (unsigned __int16 *)DriverAllocateWithTag(NonPagedPool, 0x8010u, 57);
      if ( v8 )
      {
        v10 = *(_QWORD *)(a2 + 8);
        SenderBuffer = v4;
        *v8 = 0;
        ReplyLength = 32784;
        if ( sub_180003810(&SenderBuffer, 0xCu, v8, &ReplyLength) >= 0 && *v8 )
        {
          *((_QWORD *)v8 + 1) = v8 + 8;
          sub_180004B60(
            *(_DWORD *)(v6 + 12),
            v8,
            *(_QWORD *)(a2 + 8),
            *(_QWORD *)(a2 + 24),
            *(_WORD *)(a2 + 48),
            (char *)(a2 + 56));
        }
        ExFreePoolWithTag(v8, 0);
      }
    }
    sub_180004620(v6);
  }
  ExFreePoolWithTag((PVOID)a2, 0);
}

//----- (0000000180004B60) ----------------------------------------------------
void __fastcall sub_180004B60(int a1, unsigned __int16 *a2, __int64 a3, int a4, unsigned __int16 a5, char *a6)
{
  __int64 v9; // rax
  __int64 v10; // [rsp+58h] [rbp+10h] BYREF

  v9 = sub_180003E30(1u, 5, a1, 0, (unsigned int)*a2 + 16, (PSLIST_ENTRY *)&v10, a5, a6);
  if ( v9 )
  {
    *(_QWORD *)v9 = a3;
    *(_DWORD *)(v9 + 8) = a4;
    *(_WORD *)(v9 + 12) = *a2 >> 1;
    sub_18000AC00((_OWORD *)(v9 + 16), *((char **)a2 + 1), *a2);
    sub_180004460(v10);
  }
}

//----- (0000000180004C00) ----------------------------------------------------
void __fastcall sub_180004C00(PCUNICODE_STRING SourceString, __int64 a2, __int64 a3)
{
  PEPROCESS CurrentProcess; // rax
  __int64 v7; // rcx
  USHORT Length; // ax
  PVOID v9; // rsi
  _QWORD *v10; // rax
  _QWORD *v11; // rbx
  WCHAR *v12; // rax
  HANDLE CurrentProcessId; // rcx
  __int64 *v14; // rax
  __int64 v15; // rbx
  __int64 v16; // rax
  struct _UNICODE_STRING DestinationString; // [rsp+40h] [rbp-78h] BYREF
  struct _WORK_QUEUE_ITEM WorkItem; // [rsp+50h] [rbp-68h] BYREF
  int v19; // [rsp+70h] [rbp-48h]
  __int64 v20; // [rsp+78h] [rbp-40h]
  __int64 v21; // [rsp+80h] [rbp-38h]
  struct _KEVENT Event; // [rsp+88h] [rbp-30h] BYREF
  __int64 v23; // [rsp+C0h] [rbp+8h] BYREF

  if ( !SourceString )
    return;
  CurrentProcess = IoGetCurrentProcess();
  v7 = qword_18000F2C8;
  if ( CurrentProcess == (PEPROCESS)qword_18000F2C8 || (dword_18000F524 & 1) == 0 )
    return;
  Length = SourceString->Length;
  if ( !SourceString->Length )
  {
    Length = SourceString->MaximumLength;
    SourceString->Length = Length;
    v7 = qword_18000F2C8;
  }
  if ( (*(_DWORD *)a3 & 0x100) != 0 )
  {
    if ( v7 )
    {
      v12 = (WCHAR *)DriverAllocateWithTag(NonPagedPool, Length, 67);
      DestinationString.MaximumLength = SourceString->Length;
      DestinationString.Buffer = v12;
      if ( !v12 )
        return;
      RtlCopyUnicodeString(&DestinationString, SourceString);
      goto LABEL_20;
    }
  }
  else if ( v7 )
  {
    v9 = DriverAllocateWithTag(NonPagedPool, 0x58u, 65);
    if ( v9 )
    {
      v10 = DriverAllocateWithTag(NonPagedPool, 0x4E8u, 66);
      v11 = v10;
      if ( v10 )
      {
        v10[5] = 0i64;
        if ( (*(_DWORD *)a3 & 0x400) != 0 )
        {
          KeInitializeEvent(&Event, NotificationEvent, 0);
          v20 = *(_QWORD *)(a3 + 40);
          WorkItem.List.Flink = 0i64;
          WorkItem.WorkerRoutine = (PWORKER_THREAD_ROUTINE)sub_180005D10;
          WorkItem.Parameter = &WorkItem;
          ExQueueWorkItem(&WorkItem, DelayedWorkQueue);
          KeWaitForSingleObject(&Event, Executive, 0, 0, 0i64);
          if ( v19 >= 0 )
            v11[5] = v21;
        }
        *(_OWORD *)v11 = *(_OWORD *)a3;
        *((_OWORD *)v11 + 1) = *(_OWORD *)(a3 + 16);
        v11[4] = *(_QWORD *)(a3 + 32);
        *((_WORD *)v11 + 24) = sub_180003890(1, (PVOID *)v11 + 7, 0x96u);
        KeInitializeApc(v9, KeGetCurrentThread(), 0i64, sub_180004A30, 0i64, sub_180004A40, 0, 0i64);
        KeInsertQueueApc(v9, v11, a2, 0i64);
      }
      else
      {
        ExFreePoolWithTag(v9, 0);
      }
    }
    return;
  }
  sub_180001490((__int64)SourceString, (__int64)&DestinationString);
LABEL_20:
  if ( DestinationString.Buffer )
  {
    if ( (*(_DWORD *)a3 & 0x100) != 0 )
      CurrentProcessId = (HANDLE)qword_180010940;
    else
      CurrentProcessId = PsGetCurrentProcessId();
    v14 = sub_1800046B0((__int64)CurrentProcessId, 1);
    v15 = (__int64)v14;
    if ( v14 )
    {
      v16 = sub_180003C90(
              1u,
              5,
              *((_DWORD *)v14 + 3),
              0,
              (unsigned int)DestinationString.Length + 16,
              (PSLIST_ENTRY *)&v23);
      if ( v16 )
      {
        *(_QWORD *)v16 = *(_QWORD *)(a3 + 8);
        *(_DWORD *)(v16 + 8) = *(_DWORD *)(a3 + 24);
        *(_WORD *)(v16 + 12) = DestinationString.Length >> 1;
        sub_18000AC00((_OWORD *)(v16 + 16), (char *)DestinationString.Buffer, DestinationString.Length);
        sub_180004460(v23);
      }
      sub_180004620(v15);
    }
    ExFreePoolWithTag(DestinationString.Buffer, 0);
  }
}
// 18000C2C8: using guessed type __int64 __fastcall KeInsertQueueApc(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000C2D0: using guessed type __int64 __fastcall KeInitializeApc(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD);
// 18000F2C8: using guessed type __int64 qword_18000F2C8;
// 18000F524: using guessed type int dword_18000F524;
// 180010940: using guessed type __int64 qword_180010940;

//----- (0000000180004ED0) ----------------------------------------------------
void __fastcall sub_180004ED0(__int64 a1)
{
  int v1; // r13d
  void *v2; // rax
  int v3; // edi
  PSID *v5; // r12
  PSID *v6; // r15
  ULONG v7; // ecx
  void *v8; // rcx
  __int64 v9; // rax
  __int64 *p_ProcessInformation; // r8
  NTSTATUS InformationProcess; // eax
  NTSTATUS v12; // eax
  void *v13; // rbx
  NTSTATUS v14; // eax
  int v15; // ecx
  ULONG v16; // eax
  NTSTATUS v17; // eax
  __int64 v18; // rcx
  __int64 *v19; // rsi
  unsigned __int16 v20; // di
  unsigned __int16 v21; // di
  WCHAR *v22; // rax
  unsigned __int16 v23; // di
  unsigned __int16 v24; // di
  _OWORD *v25; // rax
  unsigned int *v26; // r8
  PVOID *v27; // rdx
  PVOID *v28; // rcx
  PVOID *v29; // rax
  struct _UNICODE_STRING *p_DestinationString; // r9
  PCHAR Buffer; // rdx
  __int64 v32; // rax
  LONGLONG v33; // rax
  ULONG Length; // ecx
  ULONG v35; // edx
  int v36; // r8d
  __int64 v37; // rbx
  __int64 v38; // rcx
  __int64 *v39; // rax
  _OWORD *v40; // rdi
  unsigned __int8 v41; // cl
  bool v42; // zf
  __int64 v43; // rbx
  unsigned int v44; // ecx
  unsigned int v45; // edi
  ULONG v46; // eax
  __int64 v47; // rax
  __int64 v48; // r14
  _OWORD *v49; // r13
  char *v50; // r15
  unsigned int v51; // ebx
  unsigned __int64 v52; // r8
  unsigned int v53; // eax
  char *v54; // r13
  unsigned int v55; // ebx
  char *v56; // rcx
  unsigned int v57; // ebx
  void *ProcessHandle; // [rsp+40h] [rbp-C0h] BYREF
  ULONG v59; // [rsp+48h] [rbp-B8h]
  struct _UNICODE_STRING DestinationString; // [rsp+50h] [rbp-B0h] BYREF
  PVOID v61[2]; // [rsp+60h] [rbp-A0h] BYREF
  int v62; // [rsp+70h] [rbp-90h] BYREF
  ULONG v63; // [rsp+74h] [rbp-8Ch]
  struct _STRING P; // [rsp+78h] [rbp-88h] BYREF
  __int64 v65; // [rsp+88h] [rbp-78h] BYREF
  __int64 v66; // [rsp+90h] [rbp-70h] BYREF
  PVOID Object; // [rsp+98h] [rbp-68h] BYREF
  PVOID v68[2]; // [rsp+A0h] [rbp-60h] BYREF
  void *TokenHandle; // [rsp+B0h] [rbp-50h] BYREF
  PSID *v70; // [rsp+B8h] [rbp-48h]
  PVOID v71; // [rsp+C0h] [rbp-40h] BYREF
  union _LARGE_INTEGER Timeout; // [rsp+C8h] [rbp-38h] BYREF
  __int64 ProcessInformation; // [rsp+D0h] [rbp-30h] BYREF
  __int64 v74; // [rsp+D8h] [rbp-28h] BYREF
  __int128 v75; // [rsp+E0h] [rbp-20h]
  __int128 v76; // [rsp+F0h] [rbp-10h]
  __int64 v77; // [rsp+100h] [rbp+0h]
  __int64 v78; // [rsp+108h] [rbp+8h]
  struct _CLIENT_ID ClientId; // [rsp+110h] [rbp+10h] BYREF
  __int64 v80[4]; // [rsp+120h] [rbp+20h] BYREF
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+140h] [rbp+40h] BYREF
  char v82[32]; // [rsp+170h] [rbp+70h] BYREF
  char TokenInformation[8]; // [rsp+190h] [rbp+90h] BYREF
  __int64 v84; // [rsp+198h] [rbp+98h]
  __int64 SystemInformation[15]; // [rsp+1C8h] [rbp+C8h] BYREF
  ULONG TokenInformationLength; // [rsp+250h] [rbp+150h] BYREF
  ULONG ReturnLength; // [rsp+258h] [rbp+158h] BYREF
  unsigned int v88; // [rsp+260h] [rbp+160h] BYREF
  int v89; // [rsp+268h] [rbp+168h] BYREF

  v2 = *(void **)(a1 + 16);
  ProcessInformation = 0i64;
  LOBYTE(v1) = 0;
  v74 = 0i64;
  v75 = 0i64;
  v76 = 0i64;
  v3 = -1;
  v78 = 0i64;
  ProcessHandle = 0i64;
  v71 = 0i64;
  v5 = 0i64;
  v88 = 0;
  v6 = 0i64;
  Timeout.QuadPart = 0i64;
  v70 = 0i64;
  v89 = -1;
  LOBYTE(v59) = 0;
  v63 = v1;
  v65 = 0i64;
  *(_BYTE *)(a1 + 24) = 1;
  v62 = 0;
  v77 = 0i64;
  v84 = 0i64;
  DestinationString = 0i64;
  *(_OWORD *)v61 = 0i64;
  *(_OWORD *)v68 = 0i64;
  if ( !v2 )
    goto LABEL_37;
  ClientId.UniqueThread = 0i64;
  ClientId.UniqueProcess = v2;
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 512;
  ObjectAttributes.ObjectName = 0i64;
  *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0i64;
  if ( ZwOpenProcess(&ProcessHandle, 0, &ObjectAttributes, &ClientId) < 0 )
  {
LABEL_8:
    *(_BYTE *)(a1 + 24) = 0;
    return;
  }
  if ( !*(_QWORD *)(a1 + 16) )
    goto LABEL_9;
  v7 = BuildNumber;
  if ( BuildNumber < 0x1770 )
  {
    if ( ZwWaitForSingleObject(ProcessHandle, 0, &Timeout) != 258 )
    {
      v8 = ProcessHandle;
LABEL_7:
      ZwClose(v8);
      goto LABEL_8;
    }
LABEL_9:
    v7 = BuildNumber;
  }
  v9 = 64i64;
  p_ProcessInformation = &v74;
  if ( v7 >= 0x1770 )
    p_ProcessInformation = &ProcessInformation;
  else
    v9 = 48i64;
  ProcessInformation = v9;
  InformationProcess = ZwQueryInformationProcess(ProcessHandle, ProcessBasicInformation, p_ProcessInformation, v9, 0i64);
  v8 = ProcessHandle;
  if ( InformationProcess < 0 )
    goto LABEL_7;
  ZwQueryInformationProcess(ProcessHandle, ProcessSessionInformation, &v62, 4u, 0i64);
  if ( DriverZwOpenProcessTokenEx )
    v12 = ((__int64 (__fastcall *)(void *, __int64, __int64, void **))DriverZwOpenProcessTokenEx)(
            ProcessHandle,
            131080i64,
            512i64,
            &TokenHandle);
  else
    v12 = ZwOpenProcessToken(ProcessHandle, 0x20008u, &TokenHandle);
  if ( v12 >= 0 )
  {
    v13 = TokenHandle;
    if ( ZwQueryInformationToken(TokenHandle, TokenUser, 0i64, 0, &TokenInformationLength) == -1073741789 )
    {
      v5 = (PSID *)DriverAllocateWithTag(NonPagedPool, TokenInformationLength, 51);
      if ( v5 )
      {
        if ( ZwQueryInformationToken(v13, TokenUser, v5, TokenInformationLength, &TokenInformationLength) < 0 )
        {
          ExFreePoolWithTag(v5, 0);
          v5 = 0i64;
        }
        TokenInformationLength = 56;
        ZwQueryInformationToken(v13, TokenStatistics, TokenInformation, 0x38u, &TokenInformationLength);
        v14 = ZwQueryInformationToken(v13, TokenVirtualizationEnabled, &v89, 4u, &TokenInformationLength);
        v15 = v89;
        if ( v14 < 0 )
          v15 = -1;
        v89 = v15;
        if ( ZwQueryInformationToken(v13, TokenIntegrityLevel, 0i64, 0, &TokenInformationLength) == -1073741789 )
        {
          v70 = (PSID *)DriverAllocateWithTag(NonPagedPool, TokenInformationLength, 51);
          v6 = v70;
          if ( v70 )
          {
            if ( ZwQueryInformationToken(v13, TokenIntegrityLevel, v70, TokenInformationLength, &TokenInformationLength) < 0 )
            {
              ExFreePoolWithTag(v6, 0);
              v6 = 0i64;
              v70 = 0i64;
            }
          }
        }
        if ( v5 )
          v59 = RtlLengthSid(*v5);
        if ( v6 )
        {
          v16 = RtlLengthSid(*v6);
          LOBYTE(v1) = v16;
          v63 = v16;
        }
      }
      else
      {
        v5 = 0i64;
      }
    }
    ZwClose(TokenHandle);
  }
  v17 = ZwQueryInformationProcess(ProcessHandle, ProcessWow64Information, &v65, 8u, &ReturnLength);
  v18 = v65;
  if ( v17 < 0 )
    v18 = 0i64;
  v65 = v18;
LABEL_37:
  v19 = (__int64 *)_InterlockedExchange64((volatile __int64 *)(a1 + 32), 0i64);
  if ( v19 )
  {
    v20 = *((_WORD *)v19 + 608);
    if ( v20 )
    {
      v21 = v20 >> 1;
      v22 = (WCHAR *)DriverAllocateWithTag(NonPagedPool, 2 * (unsigned int)v21 + 2, 53);
      DestinationString.Buffer = v22;
      if ( v22 )
      {
        sub_18000AC00(v22, (char *)v19[153], 2i64 * v21);
        DestinationString.Buffer[v21] = 0;
        DestinationString.Length = 2 * v21;
      }
    }
    v23 = *((_WORD *)v19 + 616);
    if ( v23 )
    {
      v24 = v23 >> 1;
      v25 = DriverAllocateWithTag(NonPagedPool, 2 * (unsigned int)v24 + 2, 54);
      v61[1] = v25;
      if ( v25 )
      {
        sub_18000AC00(v25, (char *)v19[155], 2i64 * v24);
        *((_WORD *)v61[1] + v24) = 0;
        LOWORD(v61[0]) = 2 * v24;
      }
    }
    v3 = -1;
  }
  if ( (v78 & 0x100) != 0 )
  {
    if ( !DestinationString.Length && ObReferenceObjectByHandle(ProcessHandle, 0, 0i64, 0, &Object, 0i64) >= 0 )
    {
      if ( (int)DriverSeLocateProcessImageName(Object, &P) >= 0 && *(_QWORD *)&P.Length )
      {
        sub_1800045A0((__int64)&DestinationString, *(__int64 *)&P.Length, 53);
        ExFreePoolWithTag(*(PVOID *)&P.Length, 0);
      }
      ObfDereferenceObject(Object);
    }
  }
  else
  {
    v26 = &v88;
    v27 = &v71;
    v28 = v68;
    if ( !v19 )
      v26 = 0i64;
    v29 = v61;
    if ( !v19 )
      v27 = 0i64;
    p_DestinationString = &DestinationString;
    if ( !v19 )
      v28 = 0i64;
    if ( LOWORD(v61[0]) )
      v29 = 0i64;
    if ( DestinationString.Length )
      p_DestinationString = 0i64;
    if ( !sub_180006820(
            ProcessHandle,
            *(_QWORD *)(a1 + 16),
            v75,
            (__int64)p_DestinationString,
            (__int64)v29,
            (__int64)v28,
            v27,
            v26) )
    {
      Buffer = v82;
      DestinationString.Length = 0;
      P.Buffer = v82;
      if ( ProcessHandle )
      {
        if ( ObReferenceObjectByHandle(ProcessHandle, 0, 0i64, 0, &Object, 0i64) < 0 )
          *P.Buffer = 0;
        else
          strncpy(P.Buffer, (const char *)Object + (unsigned int)dword_180010858, 0x1Fui64);
        Buffer = P.Buffer;
      }
      else
      {
        strcpy(v82, "Idle");
      }
      if ( *Buffer )
      {
        Buffer[31] = 0;
        v32 = -1i64;
        do
          ++v32;
        while ( P.Buffer[v32] );
        P.Length = v32;
        DestinationString.MaximumLength = 2 * (v32 + 1);
        DestinationString.Buffer = (PWSTR)DriverAllocateWithTag(NonPagedPool, DestinationString.MaximumLength, 71);
        if ( DestinationString.Buffer )
          RtlAnsiStringToUnicodeString(&DestinationString, &P, 0);
      }
    }
  }
  if ( v19 )
  {
    v33 = sub_180004080();
  }
  else
  {
    v80[0] = 0i64;
    if ( ProcessHandle )
    {
      ZwQueryInformationProcess(ProcessHandle, ProcessTimes, v80, 0x20u, 0i64);
      if ( v80[0] )
        goto LABEL_81;
    }
    ReturnLength = 48;
    if ( ZwQuerySystemInformation(SystemTimeOfDayInformation, SystemInformation, 0x30u, &ReturnLength) < 0 )
      goto LABEL_81;
    v33 = SystemInformation[0] - SystemInformation[4];
  }
  v80[0] = v33;
LABEL_81:
  if ( ProcessHandle )
    ZwClose(ProcessHandle);
  Length = 0;
  ReturnLength = 0;
  v35 = 0;
  if ( DestinationString.Length )
  {
    Length = DestinationString.Length;
    ReturnLength = DestinationString.Length;
    v35 = DestinationString.Length;
  }
  if ( LOWORD(v61[0]) )
  {
    Length = v35 + LOWORD(v61[0]);
    ReturnLength = Length;
    v35 = Length;
  }
  if ( v5 )
  {
    Length = v35 + (unsigned __int8)v59;
    ReturnLength = Length;
    v35 = Length;
  }
  if ( v6 )
  {
    Length = v35 + (unsigned __int8)v1;
    ReturnLength = Length;
    v35 = Length;
  }
  if ( v19 )
  {
    if ( *v19 )
      v36 = *(_DWORD *)(*v19 + 12);
    else
      v36 = -1;
    v37 = sub_180003E30(1u, 1, v36, 0, Length + 52, (PSLIST_ENTRY *)&v66, *((_WORD *)v19 + 4), (char *)v19 + 16);
    sub_180004620(*v19);
  }
  else
  {
    v37 = sub_180003E30(1u, 0, *(_DWORD *)(a1 + 12), 0, v35 + 52, (PSLIST_ENTRY *)&v66, 0, 0i64);
  }
  if ( v37 )
  {
    *(_DWORD *)v37 = *(_DWORD *)(a1 + 12);
    v38 = (unsigned int)v77;
    *(_DWORD *)(v37 + 12) = v77;
    v39 = sub_1800046B0(v38, 0);
    if ( v39 )
      v3 = *((_DWORD *)v39 + 3);
    *(_DWORD *)(v37 + 8) = v3;
    sub_180004620((__int64)v39);
    v40 = (_OWORD *)(v37 + 52);
    v41 = v59;
    *(_QWORD *)(v37 + 24) = v80[0];
    *(_DWORD *)(v37 + 4) = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(v37 + 16) = v62;
    *(_DWORD *)(v37 + 40) = v89;
    v42 = v65 == 0;
    *(_BYTE *)(v37 + 44) = v41;
    *(_BYTE *)(v37 + 45) = v1;
    *(_DWORD *)(v37 + 20) = v42;
    *(_QWORD *)(v37 + 32) = v84;
    *(_WORD *)(v37 + 48) = LOWORD(v61[0]) >> 1;
    *(_WORD *)(v37 + 46) = DestinationString.Length >> 1;
    if ( v41 )
    {
      v43 = v41;
      sub_18000AC00(v40, (char *)*v5, v41);
      v40 = (_OWORD *)((char *)v40 + v43);
    }
    if ( (_BYTE)v1 )
    {
      sub_18000AC00(v40, (char *)*v6, (unsigned __int8)v1);
      v40 = (_OWORD *)((char *)v40 + (unsigned __int8)v1);
    }
    if ( DestinationString.Buffer )
    {
      sub_18000AC00(v40, (char *)DestinationString.Buffer, DestinationString.Length);
      v40 = (_OWORD *)((char *)v40 + DestinationString.Length);
    }
    if ( v61[1] )
      sub_18000AC00(v40, (char *)v61[1], LOWORD(v61[0]));
    sub_180004460(v66);
  }
  else
  {
    *(_BYTE *)(a1 + 24) = 0;
  }
  v44 = 0;
  if ( LOWORD(v61[0]) )
    v44 = LOWORD(v61[0]);
  if ( LOWORD(v68[0]) )
    v44 += LOWORD(v68[0]);
  if ( v88 )
    v44 += v88;
  v45 = 129808;
  v46 = 129808;
  if ( v44 < 0x1FB10 )
    v46 = v44;
  ReturnLength = v46;
  if ( v19 )
  {
    v47 = sub_180003C90(1u, 7, *(_DWORD *)(a1 + 12), 0, v46 + 12, (PSLIST_ENTRY *)&v66);
    v48 = v47;
    if ( v47 )
    {
      v49 = (_OWORD *)(v47 + 12);
      *(_DWORD *)v47 = v77;
      v50 = (char *)(v47 + 12);
      *(_QWORD *)(v47 + 4) = 0i64;
      if ( v61[1] )
      {
        v51 = LOWORD(v61[0]);
        v45 = 129808 - LOWORD(v61[0]);
        v50 = (char *)v49 + LOWORD(v61[0]);
        sub_18000AEC0((char *)(v47 + 12), 0, LOWORD(v61[0]));
        v52 = v51 - 2;
        *(_WORD *)(v48 + 4) = (unsigned __int16)v51 >> 1;
        if ( v51 >= LOWORD(v61[0]) )
          v52 = v51;
        sub_18000AC00(v49, (char *)v61[1], v52);
      }
      if ( v68[1] )
      {
        v53 = v45;
        v54 = v50;
        if ( v45 >= LOWORD(v68[0]) )
          v53 = LOWORD(v68[0]);
        v55 = v53;
        v56 = v50;
        v50 += v53;
        v45 -= v53;
        sub_18000AEC0(v56, 0, v53);
        *(_WORD *)(v48 + 6) = (unsigned __int16)v55 >> 1;
        if ( v55 < LOWORD(v68[0]) )
          v55 -= 2;
        sub_18000AC00(v54, (char *)v68[1], v55);
      }
      v57 = v88;
      if ( v88 )
      {
        if ( v45 < v88 )
          v57 = v45;
        sub_18000AEC0(v50, 0, v57);
        *(_DWORD *)(v48 + 8) = v57 >> 1;
        if ( v57 < v88 )
          v57 -= 2;
        sub_18000AC00(v50, (char *)v71, v57);
      }
      sub_180004460(v66);
      v6 = v70;
    }
    ExFreePoolWithTag(v19, 0);
  }
  if ( (_BYTE)v59 )
    ExFreePoolWithTag(v5, 0);
  if ( DestinationString.Length )
    ExFreePoolWithTag(DestinationString.Buffer, 0);
  if ( LOWORD(v61[0]) )
    ExFreePoolWithTag(v61[1], 0);
  if ( v88 )
    ExFreePoolWithTag(v71, 0);
  if ( LOWORD(v68[0]) )
    ExFreePoolWithTag(v68[1], 0);
  if ( (_BYTE)v63 )
    ExFreePoolWithTag(v6, 0);
}
// 180004F44: variable 'v1' is possibly undefined
// 18000F460: using guessed type __int64 qword_18000F460;
// 18000F508: using guessed type __int64 (__fastcall *qword_18000F508)(_QWORD, _QWORD);
// 180010858: using guessed type int dword_180010858;
// 180004ED0: using guessed type char TokenInformation[8];
// 180004ED0: using guessed type LONGLONG var_120[4];

//----- (0000000180005940) ----------------------------------------------------
__int64 __fastcall sub_180005940(char a1, __int64 a2, __int64 a3)
{
  NTSTATUS ThreadNotifyRoutine; // ebp
  NTSTATUS ProcessNotifyRoutine; // eax
  __int64 *v6; // rdi
  _QWORD *v7; // rax
  __int64 *v8; // rax
  NTSTATUS (__stdcall *v9)(PLOAD_IMAGE_NOTIFY_ROUTINE); // rax
  __int64 *v10; // rbx
  void *v11; // rcx
  __int64 *v12; // rsi
  __int64 v13; // rdx
  __int64 **v14; // rcx
  __int64 *v15; // rax
  __int64 **v16; // rcx
  __int64 *v17; // rax
  __int64 **v18; // rcx
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+40h] [rbp-48h] BYREF
  NTSTATUS v21; // [rsp+90h] [rbp+8h]

  if ( a1 == byte_18000F520 )
  {
    ThreadNotifyRoutine = v21;
  }
  else
  {
    if ( a1 )
    {
      if ( !DriverPsSetCreateThreadNotifyRoutineEx || (ThreadNotifyRoutine = DriverPsSetCreateThreadNotifyRoutineEx(1i64, NotifyRoutine), ThreadNotifyRoutine < 0) )
      {
        ThreadNotifyRoutine = PsSetCreateThreadNotifyRoutine((PCREATE_THREAD_NOTIFY_ROUTINE)NotifyRoutine);
        byte_18000F520 = a1;
        goto LABEL_9;
      }
    }
    else
    {
      ThreadNotifyRoutine = PsRemoveCreateThreadNotifyRoutine((PCREATE_THREAD_NOTIFY_ROUTINE)NotifyRoutine);
    }
    byte_18000F520 = a1;
  }
LABEL_9:
  if ( a1 != byte_18000F521 )
  {
    if ( DriverPsSetCreateProcessNotifyRoutineEx2 )
    {
      LOBYTE(a3) = a1 == 0;
      ProcessNotifyRoutine = DriverPsSetCreateProcessNotifyRoutineEx2(0i64, sub_180006400, a3);
    }
    else
    {
      ProcessNotifyRoutine = PsSetCreateProcessNotifyRoutine((PCREATE_PROCESS_NOTIFY_ROUTINE)sub_180006150, a1 == 0);
    }
    ThreadNotifyRoutine = ProcessNotifyRoutine;
    byte_18000F521 = a1;
  }
  if ( a1 != byte_18000F523 )
  {
    if ( a1 )
    {
      ObjectAttributes.Length = 48;
      ObjectAttributes.RootDirectory = 0i64;
      ObjectAttributes.Attributes = 512;
      ObjectAttributes.ObjectName = 0i64;
      *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0i64;
      PsCreateSystemThread(
        &ThreadHandle,
        0x1FFFFFu,
        &ObjectAttributes,
        0i64,
        0i64,
        (PKSTART_ROUTINE)sub_180006F10,
        0i64);
      ObjectAttributes.Length = 48;
      ObjectAttributes.RootDirectory = 0i64;
      ObjectAttributes.Attributes = 512;
      ObjectAttributes.ObjectName = 0i64;
      *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0i64;
      PsCreateSystemThread(
        &qword_1800107B8,
        0x1FFFFFu,
        &ObjectAttributes,
        0i64,
        0i64,
        (PKSTART_ROUTINE)sub_180007630,
        0i64);
    }
    else
    {
      KeSetEvent(&g_KeEvent3, 0, 0);
      ZwWaitForSingleObject(ThreadHandle, 0, 0i64);
      ZwClose(ThreadHandle);
      ZwWaitForSingleObject(qword_1800107B8, 0, 0i64);
      ZwClose(qword_1800107B8);
    }
    byte_18000F523 = a1;
  }
  if ( a1 )
  {
    if ( !qword_18000F2C8 )
    {
      v6 = sub_1800046B0(qword_180010940, 0);
      if ( v6 )
      {
        v7 = DriverAllocateWithTag(NonPagedPool, 0x4E0u, 56);
        v6[4] = (__int64)v7;
        if ( v7 )
        {
          *v7 = 0i64;
          *(_WORD *)(v6[4] + 8) = 0;
          *(_WORD *)(v6[4] + 1218) = 0;
          *(_WORD *)(v6[4] + 1216) = 0;
          *(_WORD *)(v6[4] + 1234) = 0;
          *(_WORD *)(v6[4] + 1232) = 0;
        }
        sub_180004620((__int64)v6);
      }
    }
    v8 = sub_1800046B0(qword_180010940, 1);
    sub_180004620((__int64)v8);
  }
  if ( a1 != byte_18000F522 )
  {
    v9 = PsRemoveLoadImageNotifyRoutine;
    if ( a1 )
      v9 = PsSetLoadImageNotifyRoutine;
    ThreadNotifyRoutine = ((__int64 (__fastcall *)(void (__fastcall *)(PCUNICODE_STRING, __int64, __int64)))v9)(sub_180004C00);
    byte_18000F522 = a1;
  }
  if ( !a1 && !qword_18000F2C8 )
  {
    ExAcquireFastMutex(&g_KeMutek3);
    v10 = (__int64 *)qword_180010930;
    if ( (__int64 *)qword_180010930 != &qword_180010930 )
    {
      do
      {
        v11 = (void *)*(v10 - 5);
        v12 = (__int64 *)*v10;
        if ( v11 )
        {
          ObfDereferenceObject(v11);
          *(v10 - 5) = 0i64;
          v13 = v10[2];
          if ( *(__int64 **)(v13 + 8) != v10 + 2 || (v14 = (__int64 **)v10[3], *v14 != v10 + 2) )
LABEL_49:
            __fastfail(3u);
          *v14 = (__int64 *)v13;
          *(_QWORD *)(v13 + 8) = v14;
        }
        v15 = (__int64 *)*v10;
        if ( *(__int64 **)(*v10 + 8) != v10 )
          goto LABEL_49;
        v16 = (__int64 **)v10[1];
        if ( *v16 != v10 )
          goto LABEL_49;
        *v16 = v15;
        v15[1] = (__int64)v16;
        *v10 = 0i64;
        if ( _InterlockedExchangeAdd((volatile signed __int32 *)v10 - 8, 0xFFFFFFFF) == 1 && !*((_DWORD *)v10 - 8) )
        {
          v17 = (__int64 *)*v10;
          if ( *v10 )
          {
            if ( (__int64 *)v17[1] != v10 )
              goto LABEL_49;
            v18 = (__int64 **)v10[1];
            if ( *v18 != v10 )
              goto LABEL_49;
            *v18 = v17;
            v17[1] = (__int64)v18;
          }
          ExFreePoolWithTag(v10 - 5, 0);
        }
        v10 = v12;
      }
      while ( v12 != &qword_180010930 );
    }
    ExReleaseFastMutex(&g_KeMutek3);
  }
  return (unsigned int)ThreadNotifyRoutine;
}
// 1800059D0: variable 'a3' is possibly undefined
// 18000F2C8: using guessed type __int64 qword_18000F2C8;
// 18000F510: using guessed type __int64 (__fastcall *qword_18000F510)(_QWORD, _QWORD, _QWORD);
// 18000F518: using guessed type __int64 (__fastcall *qword_18000F518)(_QWORD, _QWORD);
// 18000F520: using guessed type char byte_18000F520;
// 18000F521: using guessed type char byte_18000F521;
// 18000F522: using guessed type char byte_18000F522;
// 18000F523: using guessed type char byte_18000F523;
// 180010930: using guessed type __int64 qword_180010930;
// 180010940: using guessed type __int64 qword_180010940;

//----- (0000000180005D10) ----------------------------------------------------
LONG __fastcall sub_180005D10(__int64 a1)
{
  *(_DWORD *)(a1 + 32) = FltGetFileNameInformationUnsafe(
                           *(PFILE_OBJECT *)(a1 + 40),
                           0i64,
                           0x101u,
                           (PFLT_FILE_NAME_INFORMATION *)(a1 + 48));
  return KeSetEvent((PRKEVENT)(a1 + 56), 0, 0);
}

//----- (0000000180005D50) ----------------------------------------------------
PVOID __fastcall sub_180005D50(HANDLE TokenHandle, PVOID TokenInformation, _DWORD *a3, PVOID *a4)
{
  PVOID v8; // rbx
  PVOID v9; // rax
  ULONG TokenInformationLength[6]; // [rsp+30h] [rbp-18h] BYREF

  if ( ZwQueryInformationToken(TokenHandle, TokenUser, 0i64, 0, TokenInformationLength) != -1073741789 )
    return 0i64;
  v8 = DriverAllocateWithTag(NonPagedPool, TokenInformationLength[0], 51);
  if ( !v8 )
    return 0i64;
  if ( ZwQueryInformationToken(TokenHandle, TokenUser, v8, TokenInformationLength[0], TokenInformationLength) < 0 )
  {
    ExFreePoolWithTag(v8, 0);
    v8 = 0i64;
  }
  if ( TokenInformation )
  {
    TokenInformationLength[0] = 56;
    ZwQueryInformationToken(TokenHandle, TokenStatistics, TokenInformation, 0x38u, TokenInformationLength);
  }
  if ( a3 && ZwQueryInformationToken(TokenHandle, TokenVirtualizationEnabled, a3, 4u, TokenInformationLength) < 0 )
    *a3 = -1;
  if ( a4 )
  {
    if ( ZwQueryInformationToken(TokenHandle, TokenIntegrityLevel, 0i64, 0, TokenInformationLength) == -1073741789 )
    {
      v9 = DriverAllocateWithTag(NonPagedPool, TokenInformationLength[0], 51);
      *a4 = v9;
      if ( v9 )
      {
        if ( ZwQueryInformationToken(
               TokenHandle,
               TokenIntegrityLevel,
               v9,
               TokenInformationLength[0],
               TokenInformationLength) < 0 )
        {
          ExFreePoolWithTag(*a4, 0);
          *a4 = 0i64;
        }
      }
    }
  }
  return v8;
}

//----- (0000000180005EE0) ----------------------------------------------------
HANDLE DriverKeInitialize2()
{
  PEPROCESS CurrentProcess; // rbx
  unsigned int i; // ecx
  _QWORD *v2; // rax
  __int64 v3; // rcx
  HANDLE result; // rax
  struct _UNICODE_STRING DestinationString; // [rsp+40h] [rbp-18h] BYREF

  CurrentProcess = IoGetCurrentProcess();
  dword_180010858 = 0;
  for ( i = 0; i < 0x3000; dword_180010858 = i )
  {
    if ( !strncmp("System", (const char *)CurrentProcess + i, 6ui64) )
      break;
    i = dword_180010858 + 1;
  }
  ExInitializeNPagedLookasideList(&Lookaside, 0i64, 0i64, 0, 0x550ui64, 0x6E6D50u, 0);
  g_KeMutek3.Count = 1;
  qword_180010938 = (__int64)&qword_180010930;
  qword_180010930 = (__int64)&qword_180010930;
  g_KeMutek3.Owner = 0i64;
  qword_180010928 = (__int64)&qword_180010920;
  qword_180010920 = (__int64)&qword_180010920;
  g_KeMutek3.Contention = 0;
  KeInitializeEvent(&g_KeMutek3.Event, SynchronizationEvent, 0);
  RtlInitUnicodeString(&DestinationString, L"ZwQueryInformationThread");
  DriverZwQueryInformationThread = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&DestinationString);
  RtlInitUnicodeString(&DestinationString, L"SeLocateProcessImageName");
  DriverSeLocateProcessImageName = (__int64 (__fastcall *)(_QWORD, _QWORD))MmGetSystemRoutineAddress(&DestinationString);
  RtlInitUnicodeString(&DestinationString, L"PsSetCreateProcessNotifyRoutineEx2");
  DriverPsSetCreateProcessNotifyRoutineEx2 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&DestinationString);
  RtlInitUnicodeString(&DestinationString, L"PsSetCreateThreadNotifyRoutineEx");
  DriverPsSetCreateThreadNotifyRoutineEx = (__int64 (__fastcall *)(_QWORD, _QWORD))MmGetSystemRoutineAddress(&DestinationString);
  KeInitializeEvent(&g_KeEvent2, NotificationEvent, 0);
  InitializeSListHead(&g_SListHeader);
  KeInitializeSpinLock(&g_KSpinLock);
  if ( BuildNumber >= 0xECE )
  {
    RtlInitUnicodeString(&DestinationString, L"ZwOpenProcessTokenEx");
    DriverZwOpenProcessTokenEx = (__int64)MmGetSystemRoutineAddress(&DestinationString);
  }
  KeInitializeTimer(&g_KeTimer2);
  KeInitializeDpc(&g_KeDpc2, (PKDEFERRED_ROUTINE)sub_180006B20, 0i64);
  KeInitializeEvent(&g_KeEvent3, NotificationEvent, 0);
  KeInitializeEvent(&g_KeEvent4, SynchronizationEvent, 0);
  KeInitializeTimerEx(&g_KeTimer3, SynchronizationTimer);
  KeInitializeTimerEx(&g_KeTimer4, SynchronizationTimer);
  v2 = &unk_18000F760;
  v3 = 256i64;
  do
  {
    v2[1] = v2;
    *v2 = v2;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  result = PsGetCurrentProcessId();
  qword_180010940 = (__int64)result;
  return result;
}
// 18000F460: using guessed type __int64 qword_18000F460;
// 18000F500: using guessed type __int64 (__fastcall *qword_18000F500)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18000F508: using guessed type __int64 (__fastcall *qword_18000F508)(_QWORD, _QWORD);
// 18000F510: using guessed type __int64 (__fastcall *qword_18000F510)(_QWORD, _QWORD, _QWORD);
// 18000F518: using guessed type __int64 (__fastcall *qword_18000F518)(_QWORD, _QWORD);
// 180010858: using guessed type int dword_180010858;
// 180010920: using guessed type __int64 qword_180010920;
// 180010928: using guessed type __int64 qword_180010928;
// 180010930: using guessed type __int64 qword_180010930;
// 180010938: using guessed type __int64 qword_180010938;
// 180010940: using guessed type __int64 qword_180010940;

//----- (0000000180006150) ----------------------------------------------------
void __fastcall sub_180006150(__int64 ParentId, __int64 ProcessId, char Create)
{
  sub_180006160(ParentId, ProcessId, Create, 0i64);
}

//----- (0000000180006160) ----------------------------------------------------
void __fastcall sub_180006160(__int64 a1, __int64 a2, char a3, __int64 a4)
{
  __int64 v4; // rsi
  unsigned __int16 v7; // r14
  unsigned __int16 v8; // di
  __int64 *v9; // r12
  __int64 *v10; // r15
  unsigned __int16 *v11; // rcx
  unsigned __int16 *v12; // rax
  PVOID *v13; // rax
  PVOID *v14; // rbx
  _OWORD *v15; // rcx
  __int64 *v16; // rax
  __int64 v17; // rbx
  int v18; // edi
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 *v21; // rbx
  struct _WORK_QUEUE_ITEM *v22; // rax
  __int64 v23; // [rsp+30h] [rbp-A8h] BYREF
  __int128 v24; // [rsp+38h] [rbp-A0h] BYREF
  __int64 v25; // [rsp+48h] [rbp-90h]
  __int64 v26; // [rsp+50h] [rbp-88h]
  __int128 v27; // [rsp+60h] [rbp-78h] BYREF
  __int64 v28; // [rsp+78h] [rbp-60h]
  __int64 v29; // [rsp+80h] [rbp-58h]
  __int64 v30; // [rsp+A8h] [rbp-30h]
  __int64 v31; // [rsp+B0h] [rbp-28h]

  v4 = 0i64;
  v7 = 0;
  v8 = 0;
  if ( a3 )
  {
    v9 = sub_1800046B0(a1, 1);
    v10 = sub_1800046B0(a2, 0);
    if ( v10 )
    {
      if ( a4 )
      {
        v11 = *(unsigned __int16 **)(a4 + 48);
        if ( v11 )
          v7 = *v11;
        else
          v7 = 0;
        v12 = *(unsigned __int16 **)(a4 + 56);
        if ( v12 )
          v8 = *v12;
        else
          v8 = 0;
      }
      v13 = (PVOID *)DriverAllocateWithTag(NonPagedPool, v8 + 1248 + (unsigned int)v7, 56);
      v14 = v13;
      if ( v13 )
      {
        *v13 = v9;
        *((_WORD *)v13 + 4) = sub_180003890(1, v13 + 2, 0x96u);
        v14[153] = v14 + 156;
        *((_WORD *)v14 + 609) = v7;
        *((_WORD *)v14 + 608) = v7;
        if ( v7 )
        {
          v4 = v7;
          sub_18000AC00((_OWORD *)v14 + 78, *(char **)(*(_QWORD *)(a4 + 48) + 8i64), v7);
        }
        v15 = (char *)v14[153] + v4;
        *((_WORD *)v14 + 617) = v8;
        v14[155] = v15;
        *((_WORD *)v14 + 616) = v8;
        if ( v8 )
          sub_18000AC00(v15, *(char **)(*(_QWORD *)(a4 + 56) + 8i64), v8);
        v10[4] = (__int64)v14;
      }
    }
    else
    {
      v10 = v9;
    }
    sub_180004620((__int64)v10);
  }
  else
  {
    v16 = sub_1800046B0(a2, 1);
    v17 = (__int64)v16;
    if ( v16 )
    {
      v18 = sub_1800048B0(1, (PVOID *)v16, &v24, &v27);
      v19 = sub_180003C90(1u, 2, *(_DWORD *)(v17 + 12), 0, 52, (PSLIST_ENTRY *)&v23);
      if ( v19 )
      {
        *(_DWORD *)v19 = v18;
        *(_QWORD *)(v19 + 4) = v25;
        *(_QWORD *)(v19 + 12) = v26;
        *(_QWORD *)(v19 + 36) = v30;
        *(_QWORD *)(v19 + 44) = v31;
        *(_QWORD *)(v19 + 20) = v29;
        *(_QWORD *)(v19 + 28) = v28;
        sub_180004460(v23);
      }
      sub_180004620(v17);
      if ( *(_QWORD *)v17 )
      {
        ExAcquireFastMutex(&g_KeMutek3);
        v20 = qword_180010920;
        v21 = (__int64 *)(v17 + 56);
        if ( *(__int64 **)(qword_180010920 + 8) != &qword_180010920 )
          __fastfail(3u);
        v21[1] = (__int64)&qword_180010920;
        *v21 = v20;
        *(_QWORD *)(v20 + 8) = v21;
        qword_180010920 = (__int64)v21;
        ExReleaseFastMutex(&g_KeMutek3);
        v22 = (struct _WORK_QUEUE_ITEM *)DriverAllocateWithTag(NonPagedPool, 0x20u, 77);
        if ( v22 )
        {
          v22->Parameter = v22;
          v22->WorkerRoutine = (PWORKER_THREAD_ROUTINE)sub_180006B70;
          v22->List.Flink = 0i64;
          ExQueueWorkItem(v22, DelayedWorkQueue);
        }
      }
    }
  }
}
// 180010920: using guessed type __int64 qword_180010920;
// 180006160: using guessed type __int128 var_78;

//----- (0000000180006400) ----------------------------------------------------
void __fastcall sub_180006400(__int64 a1, __int64 a2, __int64 a3)
{
  if ( a3 )
    sub_180006160(*(_QWORD *)(a3 + 16), a2, a3 != 0, a3);
  else
    sub_180006160(0i64, a2, 0, 0i64);
}

//----- (0000000180006430) ----------------------------------------------------
void *__fastcall sub_180006430(char a1)
{
  PACCESS_TOKEN v2; // rbx
  struct _KPROCESS *CurrentProcess; // rax
  void *Handle; // [rsp+40h] [rbp-18h] BYREF
  unsigned __int8 EffectiveOnly; // [rsp+68h] [rbp+10h] BYREF
  unsigned __int8 CopyOnOpen; // [rsp+70h] [rbp+18h] BYREF
  enum _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel; // [rsp+78h] [rbp+20h] BYREF

  Handle = 0i64;
  v2 = PsReferenceImpersonationToken(KeGetCurrentThread(), &CopyOnOpen, &EffectiveOnly, &ImpersonationLevel);
  if ( v2 || !a1 && (CurrentProcess = IoGetCurrentProcess(), (v2 = PsReferencePrimaryToken(CurrentProcess)) != 0i64) )
  {
    ObOpenObjectByPointer(v2, 0x200u, 0i64, 8u, 0i64, 0, &Handle);
    ObfDereferenceObject(v2);
  }
  return Handle;
}

//----- (00000001800064D0) ----------------------------------------------------
void __fastcall sub_1800064D0(bool a1)
{
  unsigned int v1; // ebp
  bool v2; // r13
  bool v3; // di
  ULONG v4; // ebx
  unsigned int *v5; // r15
  unsigned int *v6; // r14
  __int64 *v7; // rax
  __int64 v8; // rbx
  _QWORD *v9; // rax
  __int64 v10; // rax
  __int64 v11; // rdi
  char *v12; // rsi
  char *v13; // rax
  char *v14; // rbx
  char **v15; // rax
  char *v16; // rcx
  __int64 v17; // rdx
  __int64 v18; // rcx
  int v19; // r9d
  int v20; // r8d
  __int64 v21; // rax
  __int128 v22; // [rsp+40h] [rbp-58h] BYREF
  bool v23; // [rsp+A0h] [rbp+8h]
  ULONG ReturnLength; // [rsp+A8h] [rbp+10h] BYREF
  union _LARGE_INTEGER v25; // [rsp+B0h] [rbp+18h] BYREF
  __int64 v26; // [rsp+B8h] [rbp+20h] BYREF

  v1 = 0;
  v2 = a1;
  v25.QuadPart = 0i64;
  v3 = !a1;
  v23 = !a1;
  if ( a1 )
  {
    if ( KeWaitForSingleObject(&g_KeTimer4, Executive, 0, 0, &v25) != 258 )
    {
      v3 = 1;
      v23 = 1;
    }
  }
  else
  {
    v2 = KeWaitForSingleObject(&g_KeTimer3, Executive, 0, 0, &v25) != 258;
  }
  v4 = 0x10000;
  v5 = (unsigned int *)DriverAllocateWithTag(PagedPool, 0x10000u, 53);
  if ( v5 )
  {
    while ( ZwQuerySystemInformation(SystemProcessInformation, v5, v4, &ReturnLength) < 0 )
    {
      ExFreePoolWithTag(v5, 0);
      v4 = ReturnLength;
      v5 = (unsigned int *)DriverAllocateWithTag(PagedPool, ReturnLength, 53);
      if ( !v5 )
        return;
    }
    v6 = v5;
    do
    {
      if ( v3 )
      {
        v7 = sub_1800046B0(*((_QWORD *)v6 + 10), 1);
        v8 = (__int64)v7;
        if ( v7 )
        {
          if ( !v7[4] )
          {
            v9 = (_QWORD *)sub_180003E30(4u, 1, *((_DWORD *)v7 + 3), 0, 32, (PSLIST_ENTRY *)&v26, 0, 0i64);
            if ( v9 )
            {
              *v9 = *((_QWORD *)v6 + 5);
              v9[1] = *((_QWORD *)v6 + 6);
              v9[2] = *((_QWORD *)v6 + 18);
              v9[3] = *((_QWORD *)v6 + 23);
              sub_180004460(v26);
            }
            sub_180004620(v8);
          }
        }
      }
      if ( v2 )
      {
        v10 = *((_QWORD *)v6 + 10);
        if ( v10 )
        {
          if ( v10 != qword_180010B00 )
          {
            if ( v6[1] )
            {
              do
              {
                v11 = (__int64)&v6[20 * v1 + 64];
                v12 = (char *)&unk_18000F760
                    + 16 * (unsigned __int8)((unsigned __int64)*(unsigned int *)(v11 + 48) >> 4);
                v13 = *(char **)v12;
                if ( *(char **)v12 == v12 )
                {
LABEL_23:
                  v14 = (char *)DriverAllocateWithTag(PagedPool, 0x38u, 78);
                  *(_OWORD *)v14 = 0i64;
                  *((_OWORD *)v14 + 1) = 0i64;
                  *((_OWORD *)v14 + 2) = 0i64;
                  *((_QWORD *)v14 + 6) = 0i64;
                  v15 = (char **)(v14 + 40);
                  *(_OWORD *)v14 = *(_OWORD *)(v11 + 40);
                  *((_QWORD *)v14 + 6) = v14 + 40;
                  *((_QWORD *)v14 + 5) = v14 + 40;
                  v16 = *(char **)v12;
                  if ( *(char **)(*(_QWORD *)v12 + 8i64) != v12 )
                    __fastfail(3u);
                  *v15 = v16;
                  *((_QWORD *)v14 + 6) = v12;
                  *((_QWORD *)v16 + 1) = v15;
                  *(_QWORD *)v12 = v15;
                }
                else
                {
                  while ( 1 )
                  {
                    v14 = v13 - 40;
                    if ( *((_QWORD *)v13 - 4) == *(_QWORD *)(v11 + 48) )
                      break;
                    v13 = *(char **)v13;
                    if ( v13 == v12 )
                      goto LABEL_23;
                  }
                }
                if ( v14 )
                {
                  if ( *(_QWORD *)v14 == *(_QWORD *)(v11 + 40) )
                  {
                    v17 = *((_QWORD *)v14 + 3);
                    v18 = *(_QWORD *)v11;
                    if ( (v17 != *(_QWORD *)v11
                       || *((_QWORD *)v14 + 4) != *(_QWORD *)(v11 + 8)
                       || *((_DWORD *)v14 + 4) != *(_DWORD *)(v11 + 64))
                      && (v17 || *((_QWORD *)v14 + 4) || *((_DWORD *)v14 + 4)) )
                    {
                      v19 = *(_DWORD *)(v11 + 64) - *((_DWORD *)v14 + 4);
                      v20 = *(_DWORD *)(v11 + 8) - *((_DWORD *)v14 + 8);
                      v22 = *(_OWORD *)(v11 + 40);
                      sub_1800073E0((__int64)&v22, v18 - v17, v20, v19);
                    }
                  }
                  *(_QWORD *)v14 = *(_QWORD *)(v11 + 40);
                  *((_QWORD *)v14 + 3) = *(_QWORD *)v11;
                  *((_QWORD *)v14 + 4) = *(_QWORD *)(v11 + 8);
                  *((_DWORD *)v14 + 4) = *(_DWORD *)(v11 + 64);
                }
                ++v1;
              }
              while ( v1 < v6[1] );
              v3 = v23;
            }
            v1 = 0;
          }
        }
      }
      v21 = *v6;
      if ( !(_DWORD)v21 )
        break;
      v6 = (unsigned int *)((char *)v6 + v21);
    }
    while ( v6 );
    ExFreePoolWithTag(v5, 0);
  }
}
// 180010B00: using guessed type __int64 qword_180010B00;
// 1800064D0: using guessed type __int128 var_58;

//----- (0000000180006820) ----------------------------------------------------
bool __fastcall sub_180006820(
        void *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        _QWORD *a7,
        _DWORD *a8)
{
  unsigned int v10; // ebx
  __int64 *v12; // rsi
  __int64 v13; // rcx
  __int64 v14; // rax
  char v15; // al
  __int64 v16; // rcx
  __int64 v17; // rax
  __int64 v18; // rcx
  __int64 v19; // rax
  __int64 v20; // rdi
  __int64 v21; // rax
  _OWORD *v22; // rax
  bool v23; // [rsp+30h] [rbp-78h]
  PVOID Object; // [rsp+40h] [rbp-68h] BYREF
  __int16 v25; // [rsp+48h] [rbp-60h] BYREF
  __int64 v26; // [rsp+50h] [rbp-58h]
  struct _KAPC_STATE ApcState; // [rsp+58h] [rbp-50h] BYREF

  v10 = 0;
  Object = 0i64;
  v23 = a4 == 0;
  if ( a6 )
  {
    *(_QWORD *)(a6 + 8) = 0i64;
    *(_WORD *)a6 = 0;
  }
  if ( a7 )
  {
    *a7 = 0i64;
    *a8 = 0;
  }
  if ( a1 && a3 )
  {
    if ( ObReferenceObjectByHandle(a1, 0, 0i64, 0, &Object, 0i64) < 0 )
      return 0;
    KeStackAttachProcess((PRKPROCESS)Object, &ApcState);
    v12 = (__int64 *)(a3 + 32);
    v13 = *v12;
    if ( *v12 )
    {
      if ( a4 )
      {
        v14 = *(_QWORD *)(v13 + 104);
        if ( (*(_BYTE *)(v13 + 8) & 1) == 0 )
          v14 += v13;
        v26 = v14;
        v25 = *(_WORD *)(v13 + 96);
        sub_1800045A0(a4, (__int64)&v25, 53);
        v15 = v23;
        if ( *(_QWORD *)(a4 + 8) )
          v15 = 1;
        v23 = v15;
      }
      if ( a5 )
      {
        v16 = *v12;
        v17 = *(_QWORD *)(*v12 + 120);
        if ( (*(_BYTE *)(*v12 + 8) & 1) == 0 )
          v17 += v16;
        v26 = v17;
        v25 = *(_WORD *)(v16 + 112);
        sub_1800045A0(a5, (__int64)&v25, 54);
      }
      if ( a6 )
      {
        v18 = *v12;
        v19 = *(_QWORD *)(*v12 + 64);
        if ( (*(_BYTE *)(*v12 + 8) & 1) == 0 )
          v19 += v18;
        v26 = v19;
        v25 = *(_WORD *)(v18 + 56);
        sub_1800045A0(a6, (__int64)&v25, 55);
      }
      if ( a7 )
      {
        while ( 1 )
        {
          v20 = 2i64 * v10;
          v21 = -1i64;
          do
            ++v21;
          while ( *(_WORD *)(v20 + *(_QWORD *)(*v12 + 128) + 2 * v21) );
          if ( !(_DWORD)v21 )
            break;
          v10 += v21 + 1;
        }
        v22 = DriverAllocateWithTag(NonPagedPool, 2 * v10, 56);
        *a7 = v22;
        if ( v22 )
        {
          sub_18000AC00(v22, *(char **)(*v12 + 128), 2i64 * v10);
          *a8 = v20;
        }
      }
    }
    KeUnstackDetachProcess(&ApcState);
    ObfDereferenceObject(Object);
  }
  return v23;
}

//----- (0000000180006B20) ----------------------------------------------------
void __fastcall sub_180006B20(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
  struct _WORK_QUEUE_ITEM *v4; // rax

  v4 = (struct _WORK_QUEUE_ITEM *)DriverAllocateWithTag(NonPagedPool, 0x20u, 77);
  if ( v4 )
  {
    v4->Parameter = v4;
    v4->WorkerRoutine = (PWORKER_THREAD_ROUTINE)sub_180006B70;
    v4->List.Flink = 0i64;
    ExQueueWorkItem(v4, DelayedWorkQueue);
  }
}

//----- (0000000180006B70) ----------------------------------------------------
void __fastcall sub_180006B70(PVOID P)
{
  __int64 *v2; // rbx
  void *v3; // rbp
  __int64 *v4; // rsi
  __int64 *v5; // rcx
  __int64 **v6; // rax
  __int64 v7; // rax
  __int64 *v8; // rdx
  __int64 **v9; // r8
  union _LARGE_INTEGER Timeout; // [rsp+68h] [rbp+10h] BYREF

  Timeout.QuadPart = 0i64;
  ExAcquireFastMutex(&g_KeMutek3);
  v2 = (__int64 *)qword_180010920;
  if ( (__int64 *)qword_180010920 != &qword_180010920 )
  {
    do
    {
      v3 = (void *)*(v2 - 7);
      v4 = (__int64 *)*v2;
      if ( KeWaitForSingleObject(v3, Executive, 0, 0, &Timeout) != 258 )
      {
        v5 = (__int64 *)*v2;
        if ( *(__int64 **)(*v2 + 8) != v2 || (v6 = (__int64 **)v2[1], *v6 != v2) )
LABEL_17:
          __fastfail(3u);
        *v6 = v5;
        v5[1] = (__int64)v6;
        *(v2 - 7) = 0i64;
        if ( _InterlockedExchangeAdd((volatile signed __int32 *)v2 - 12, 0xFFFFFFFF) == 1 && !*((_DWORD *)v2 - 12) )
        {
          v7 = *(v2 - 2);
          v8 = v2 - 2;
          if ( v7 )
          {
            if ( *(__int64 **)(v7 + 8) != v8 )
              goto LABEL_17;
            v9 = (__int64 **)v8[1];
            if ( *v9 != v8 )
              goto LABEL_17;
            *v9 = (__int64 *)v7;
            *(_QWORD *)(v7 + 8) = v9;
          }
          ExFreePoolWithTag(v2 - 7, 0);
        }
        ObfDereferenceObject(v3);
      }
      v2 = v4;
    }
    while ( v4 != &qword_180010920 );
    if ( (__int64 *)qword_180010920 != &qword_180010920 )
      KeSetTimer(&g_KeTimer2, (LARGE_INTEGER)-5000000i64, &g_KeDpc2);
  }
  ExReleaseFastMutex(&g_KeMutek3);
  ExFreePoolWithTag(P, 0);
}
// 180010920: using guessed type __int64 qword_180010920;

//----- (0000000180006CD0) ----------------------------------------------------
void sub_180006CD0()
{
  __int64 *i; // rbx
  __int64 v1; // rax
  HANDLE CurrentProcessId; // rax
  __int64 *v3; // rdi
  __int64 v4; // rbx
  _DWORD *v5; // rax
  _DWORD *v6; // rcx
  char *v7; // rax
  __int128 v8; // xmm0
  __int128 v9; // [rsp+40h] [rbp-1D8h] BYREF
  __int64 v10; // [rsp+50h] [rbp-1C8h]
  __int64 v11; // [rsp+58h] [rbp-1C0h]
  __int128 v12; // [rsp+60h] [rbp-1B8h] BYREF
  __int64 v13; // [rsp+78h] [rbp-1A0h]
  __int64 v14; // [rsp+80h] [rbp-198h]
  __int64 v15; // [rsp+A8h] [rbp-170h]
  __int64 v16; // [rsp+B0h] [rbp-168h]
  char SystemInformation[320]; // [rsp+C0h] [rbp-158h] BYREF
  ULONG ReturnLength; // [rsp+220h] [rbp+8h] BYREF
  __int64 v19; // [rsp+228h] [rbp+10h] BYREF

  ExAcquireFastMutex(&g_KeMutek3);
  for ( i = (__int64 *)qword_180010930; i != &qword_180010930; i = (__int64 *)*i )
  {
    if ( *(i - 3) )
    {
      if ( (int)sub_1800048B0(0, (PVOID *)i - 5, &v9, &v12) >= 0 )
      {
        v1 = sub_180003E30(1u, 8, *((_DWORD *)i - 7), 0, 52, (PSLIST_ENTRY *)&v19, 0, 0i64);
        if ( v1 )
        {
          *(_DWORD *)v1 = 0;
          *(_QWORD *)(v1 + 4) = v10;
          *(_QWORD *)(v1 + 12) = v11;
          *(_QWORD *)(v1 + 36) = v15;
          *(_QWORD *)(v1 + 44) = v16;
          *(_QWORD *)(v1 + 20) = v14;
          *(_QWORD *)(v1 + 28) = v13;
          sub_180004460(v19);
        }
      }
    }
  }
  ExReleaseFastMutex(&g_KeMutek3);
  CurrentProcessId = PsGetCurrentProcessId();
  v3 = sub_1800046B0((__int64)CurrentProcessId, 1);
  if ( v3 )
  {
    v4 = 2i64;
    ReturnLength = 312;
    if ( ZwQuerySystemInformation(SystemPerformanceInformation, SystemInformation, 0x138u, &ReturnLength) >= 0 )
    {
      v5 = (_DWORD *)sub_180003C90(1u, 9, *((_DWORD *)v3 + 3), 0, 316, (PSLIST_ENTRY *)&v19);
      if ( v5 )
      {
        *v5 = 4096;
        v6 = v5 + 1;
        v7 = SystemInformation;
        do
        {
          v6 += 32;
          v8 = *(_OWORD *)v7;
          v7 += 128;
          *((_OWORD *)v6 - 8) = v8;
          *((_OWORD *)v6 - 7) = *((_OWORD *)v7 - 7);
          *((_OWORD *)v6 - 6) = *((_OWORD *)v7 - 6);
          *((_OWORD *)v6 - 5) = *((_OWORD *)v7 - 5);
          *((_OWORD *)v6 - 4) = *((_OWORD *)v7 - 4);
          *((_OWORD *)v6 - 3) = *((_OWORD *)v7 - 3);
          *((_OWORD *)v6 - 2) = *((_OWORD *)v7 - 2);
          *((_OWORD *)v6 - 1) = *((_OWORD *)v7 - 1);
          --v4;
        }
        while ( v4 );
        *(_OWORD *)v6 = *(_OWORD *)v7;
        *((_OWORD *)v6 + 1) = *((_OWORD *)v7 + 1);
        *((_OWORD *)v6 + 2) = *((_OWORD *)v7 + 2);
        *((_QWORD *)v6 + 6) = *((_QWORD *)v7 + 6);
        sub_180004460(v19);
      }
    }
    sub_180004620((__int64)v3);
  }
}
// 180010930: using guessed type __int64 qword_180010930;
// 180006CD0: using guessed type __int128 var_1B8;

//----- (0000000180006F10) ----------------------------------------------------
void __fastcall sub_180006F10(PVOID StartContext)
{
  unsigned int v1; // ebx
  _QWORD **v2; // rsi
  NTSTATUS v3; // eax
  int v4; // eax
  int v5; // eax
  unsigned int v6; // ebp
  _QWORD **v7; // rdi
  _QWORD *v8; // rax
  _QWORD *v9; // rcx
  _QWORD *v10; // rax
  _QWORD *v11; // rcx
  PVOID Object[4]; // [rsp+40h] [rbp-E8h] BYREF
  struct _KWAIT_BLOCK WaitBlockArray; // [rsp+60h] [rbp-C8h] BYREF

  v1 = 0;
  KeSetTimerEx(&g_KeTimer4, 0i64, 1000, 0i64);
  KeResetEvent(&g_KeEvent3);
  Object[1] = &g_KeTimer4;
  Object[2] = &g_KeTimer3;
  v2 = (_QWORD **)&unk_18000F760;
  Object[0] = &g_KeEvent3;
  Object[3] = &g_KeEvent4;
LABEL_2:
  while ( 1 )
  {
    v3 = KeWaitForMultipleObjects(4u, Object, WaitAny, Executive, 0, 0, 0i64, &WaitBlockArray);
    if ( !v3 )
      break;
    v4 = v3 - 1;
    if ( v4 )
    {
      v5 = v4 - 1;
      if ( v5 )
      {
        if ( v5 == 1 )
        {
          v6 = 0;
          v7 = (_QWORD **)&unk_18000F760;
          while ( 1 )
          {
            v8 = *v7;
            if ( *v7 != v7 )
              break;
LABEL_11:
            ++v6;
            v7 += 2;
            if ( v6 >= 0x100 )
              goto LABEL_2;
          }
          while ( (_QWORD **)v8[1] == v7 )
          {
            v9 = (_QWORD *)*v8;
            if ( *(_QWORD **)(*v8 + 8i64) != v8 )
              break;
            *v7 = v9;
            v9[1] = v7;
            ExFreePoolWithTag(v8 - 5, 0);
            v8 = *v7;
            if ( *v7 == v7 )
              goto LABEL_11;
          }
          goto LABEL_21;
        }
      }
      else
      {
        sub_1800064D0(1);
      }
    }
    else
    {
      sub_1800064D0(0);
    }
  }
  do
  {
    v10 = *v2;
    if ( *v2 != v2 )
    {
      while ( (_QWORD **)v10[1] == v2 )
      {
        v11 = (_QWORD *)*v10;
        if ( *(_QWORD **)(*v10 + 8i64) != v10 )
          break;
        *v2 = v11;
        v11[1] = v2;
        ExFreePoolWithTag(v10 - 5, 0);
        v10 = *v2;
        if ( *v2 == v2 )
          goto LABEL_19;
      }
LABEL_21:
      __fastfail(3u);
    }
LABEL_19:
    ++v1;
    v2 += 2;
  }
  while ( v1 < 0x100 );
}

//----- (0000000180007090) ----------------------------------------------------
void __fastcall NotifyRoutine(HANDLE ProcessId, HANDLE ThreadId, BOOLEAN Create)
{
  __int64 *v6; // rax
  __int64 v7; // rbx
  _DWORD *v8; // rax
  int v9; // edi
  void *v10; // rsi
  __int64 v11; // rax
  void *ThreadHandle; // [rsp+30h] [rbp-B8h] BYREF
  struct _CLIENT_ID ClientId; // [rsp+38h] [rbp-B0h] BYREF
  __int128 v14; // [rsp+48h] [rbp-A0h] BYREF
  __int128 v15; // [rsp+58h] [rbp-90h]
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+68h] [rbp-80h] BYREF
  int v17[20]; // [rsp+98h] [rbp-50h] BYREF
  __int64 v18; // [rsp+108h] [rbp+20h] BYREF

  if ( (dword_18000F524 & 1) != 0 )
  {
    v6 = sub_1800046B0((__int64)ProcessId, 1);
    v7 = (__int64)v6;
    if ( v6 )
    {
      if ( Create )
      {
        v8 = (_DWORD *)sub_180003C90(1u, 3, *((_DWORD *)v6 + 3), 0, 4, (PSLIST_ENTRY *)&v18);
        if ( !v8 )
        {
LABEL_15:
          sub_180004620(v7);
          return;
        }
        *v8 = (_DWORD)ThreadId;
      }
      else
      {
        v9 = 0;
        v14 = 0i64;
        v15 = 0i64;
        if ( DriverZwQueryInformationThread )
        {
          ClientId.UniqueThread = ThreadId;
          ClientId.UniqueProcess = ProcessId;
          ObjectAttributes.Length = 48;
          ObjectAttributes.RootDirectory = 0i64;
          ObjectAttributes.Attributes = 512;
          ObjectAttributes.ObjectName = 0i64;
          *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0i64;
          if ( ZwOpenThread(&ThreadHandle, 0, &ObjectAttributes, &ClientId) >= 0 )
          {
            v10 = ThreadHandle;
            if ( ThreadHandle )
            {
              if ( (int)DriverZwQueryInformationThread(ThreadHandle, 0i64, v17, 48i64, 0i64) >= 0 )
                v9 = v17[0];
              DriverZwQueryInformationThread(v10, 1i64, &v14, 32i64, 0i64);
              ZwClose(v10);
            }
          }
        }
        v11 = sub_180003C90(1u, 4, *(_DWORD *)(v7 + 12), 0, 20, (PSLIST_ENTRY *)&v18);
        if ( !v11 )
          goto LABEL_15;
        *(_DWORD *)v11 = v9;
        *(_OWORD *)(v11 + 4) = v15;
      }
      sub_180004460(v18);
      goto LABEL_15;
    }
  }
}
// 18000F500: using guessed type __int64 (__fastcall *qword_18000F500)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18000F524: using guessed type int dword_18000F524;
// 180007090: using guessed type int var_50[20];

//----- (0000000180007250) ----------------------------------------------------
void __fastcall sub_180007250(PSLIST_ENTRY ListEntry, _QWORD *a2)
{
  __int64 *v4; // rax
  __int64 v5; // rdi
  _DWORD *v6; // rax
  struct _LOOKASIDE_LIST_EX *v7; // rdx
  __int64 v8; // [rsp+40h] [rbp+8h] BYREF

  if ( *((_BYTE *)&ListEntry[5].Next + 8) )
  {
    *((_WORD *)&ListEntry[9].Next + 4) = sub_180003890(0, (PVOID *)&ListEntry[10].Next, 0x96u);
    ExpInterlockedPushEntrySList(&g_SListHeader, ListEntry + 8);
    KeSetEvent(&g_KeEvent2, 0, 0);
    *a2 = 0i64;
  }
  else
  {
    v4 = sub_1800046B0((__int64)ListEntry[6].Next, 1);
    v5 = (__int64)v4;
    if ( v4 )
    {
      v6 = (_DWORD *)sub_180003C90(4u, 0, *((_DWORD *)v4 + 3), 0, 12, (PSLIST_ENTRY *)&v8);
      if ( v6 )
      {
        *v6 = ListEntry[7].Next;
        v6[1] = *((_DWORD *)&ListEntry[6].Next + 3);
        v6[2] = *((_DWORD *)&ListEntry[6].Next + 2);
        sub_180004460(v8);
      }
      sub_180004620(v5);
    }
    ++Lookaside.L.TotalFrees;
    if ( ExQueryDepthSList(&Lookaside.L.ListHead) < Lookaside.L.Depth )
    {
      ExpInterlockedPushEntrySList(&Lookaside.L.ListHead, ListEntry);
    }
    else
    {
      ++Lookaside.L.FreeMisses;
      Lookaside.L.FreeEx(ListEntry, v7);
    }
    *a2 = 0i64;
  }
}
// 180007345: variable 'v7' is possibly undefined

//----- (0000000180007380) ----------------------------------------------------
BOOLEAN __fastcall sub_180007380(__int64 a1)
{
  if ( a1 )
    return KeSetTimerEx(&g_KeTimer3, 0i64, (int)a1 / 10000, 0i64);
  KeSetEvent(&g_KeEvent4, 0, 0);
  return KeCancelTimer(&g_KeTimer3);
}

//----- (00000001800073E0) ----------------------------------------------------
NTSTATUS __fastcall sub_1800073E0(__int64 a1, int a2, int a3, int a4)
{
  NTSTATUS result; // eax
  __int64 *v9; // rdi
  PSLIST_ENTRY v10; // rbx
  struct _LOOKASIDE_LIST_EX *v11; // r9
  struct _LOOKASIDE_LIST_EX *v12; // rdx
  PSLIST_ENTRY v13; // rbx
  struct _LOOKASIDE_LIST_EX *v14; // r9
  struct _LOOKASIDE_LIST_EX *v15; // rdx
  char v16; // [rsp+30h] [rbp-28h]
  char v17; // [rsp+30h] [rbp-28h]
  PETHREAD Thread; // [rsp+60h] [rbp+8h] BYREF

  result = PsLookupThreadByThreadId(*(HANDLE *)(a1 + 8), &Thread);
  if ( result >= 0 )
  {
    if ( PsIsSystemThread(Thread) )
    {
      v9 = sub_1800046B0(*(_QWORD *)a1, 1);
      if ( v9 )
      {
        ++Lookaside.L.TotalAllocates;
        v10 = ExpInterlockedPopEntrySList(&Lookaside.L.ListHead);
        if ( !v10 )
        {
          ++Lookaside.L.AllocateMisses;
          v10 = (PSLIST_ENTRY)Lookaside.L.AllocateEx(Lookaside.L.Type, Lookaside.L.Size, Lookaside.L.Tag, v11);
        }
        if ( v10 )
        {
          *((_BYTE *)&v10[5].Next + 8) = 1;
          v16 = 0;
          v10[9].Next = (struct _SLIST_ENTRY *)v9;
          KeInitializeApc(v10, Thread, 0i64, sub_180007250, 0i64, sub_180007250, v16, 0i64);
          if ( !(unsigned __int8)KeInsertQueueApc(v10, 0i64, 0i64, 0i64) )
          {
            ++Lookaside.L.TotalFrees;
            if ( ExQueryDepthSList(&Lookaside.L.ListHead) < Lookaside.L.Depth )
            {
              ExpInterlockedPushEntrySList(&Lookaside.L.ListHead, v10);
            }
            else
            {
              ++Lookaside.L.FreeMisses;
              Lookaside.L.FreeEx(v10, v12);
            }
            sub_180004620((__int64)v9);
          }
        }
      }
    }
    else
    {
      ++Lookaside.L.TotalAllocates;
      v13 = ExpInterlockedPopEntrySList(&Lookaside.L.ListHead);
      if ( !v13 )
      {
        ++Lookaside.L.AllocateMisses;
        v13 = (PSLIST_ENTRY)Lookaside.L.AllocateEx(Lookaside.L.Type, Lookaside.L.Size, Lookaside.L.Tag, v14);
      }
      if ( v13 )
      {
        v13[6].Next = *(struct _SLIST_ENTRY **)a1;
        *((_BYTE *)&v13[5].Next + 8) = 0;
        v17 = 0;
        *((_DWORD *)&v13[6].Next + 3) = a2;
        LODWORD(v13[7].Next) = a3;
        *((_DWORD *)&v13[6].Next + 2) = a4;
        KeInitializeApc(v13, Thread, 0i64, sub_180007250, 0i64, sub_180007250, v17, 0i64);
        if ( !(unsigned __int8)KeInsertQueueApc(v13, 0i64, 0i64, 0i64) )
        {
          ++Lookaside.L.TotalFrees;
          if ( ExQueryDepthSList(&Lookaside.L.ListHead) < Lookaside.L.Depth )
          {
            ExpInterlockedPushEntrySList(&Lookaside.L.ListHead, v13);
          }
          else
          {
            ++Lookaside.L.FreeMisses;
            Lookaside.L.FreeEx(v13, v15);
          }
        }
      }
    }
    return ObfDereferenceObject(Thread);
  }
  return result;
}
// 180007472: variable 'v11' is possibly undefined
// 1800074FA: variable 'v12' is possibly undefined
// 18000755E: variable 'v14' is possibly undefined
// 1800075EC: variable 'v15' is possibly undefined
// 18000C2C8: using guessed type __int64 __fastcall KeInsertQueueApc(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000C2D0: using guessed type __int64 __fastcall KeInitializeApc(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD);

//----- (0000000180007630) ----------------------------------------------------
void __fastcall sub_180007630(PVOID StartContext)
{
  char v1; // si
  NTSTATUS v2; // eax
  PSLIST_ENTRY v3; // rax
  PSLIST_ENTRY v4; // rbx
  _DWORD *v5; // rax
  struct _SLIST_ENTRY *Next; // rdi
  __int64 v7; // rcx
  struct _SLIST_ENTRY **v8; // rax
  struct _SLIST_ENTRY *v9; // rdx
  struct _LOOKASIDE_LIST_EX *v10; // rdx
  PVOID Object[2]; // [rsp+40h] [rbp-78h] BYREF
  struct _KWAIT_BLOCK WaitBlockArray; // [rsp+50h] [rbp-68h] BYREF
  __int64 v13; // [rsp+C8h] [rbp+10h] BYREF

  v1 = 0;
  Object[0] = &g_KeEvent3;
  Object[1] = &g_KeEvent2;
  do
  {
    v2 = KeWaitForMultipleObjects(2u, Object, WaitAny, Executive, 0, 0, 0i64, &WaitBlockArray);
    if ( v2 )
    {
      if ( v2 != 1 )
        continue;
    }
    else
    {
      v1 = 1;
    }
    while ( ExQueryDepthSList(&g_SListHeader) )
    {
      v3 = ExpInterlockedPopEntrySList(&g_SListHeader);
      v4 = v3;
      if ( !v1 )
      {
        v5 = (_DWORD *)sub_180003E30(
                         4u,
                         0,
                         *((_DWORD *)&v3[1].Next->Next + 3),
                         0,
                         12,
                         (PSLIST_ENTRY *)&v13,
                         *((_WORD *)&v3[1].Next + 4),
                         (char *)&v3[2]);
        if ( v5 )
        {
          *v5 = v4[-1].Next;
          v5[1] = *((_DWORD *)&v4[-2].Next + 3);
          v5[2] = *((_DWORD *)&v4[-2].Next + 2);
          sub_180004460(v13);
        }
      }
      Next = v4[1].Next;
      if ( Next && _InterlockedExchangeAdd((volatile signed __int32 *)&Next->Next + 2, 0xFFFFFFFF) == 1 )
      {
        ExAcquireFastMutex(&g_KeMutek3);
        if ( *((_DWORD *)&Next->Next + 2) )
        {
          ExReleaseFastMutex(&g_KeMutek3);
        }
        else
        {
          v7 = *((_QWORD *)&Next[2].Next + 1);
          v8 = &Next[2].Next + 1;
          if ( v7 )
          {
            if ( *(struct _SLIST_ENTRY ***)(v7 + 8) != v8 || (v9 = Next[3].Next, (struct _SLIST_ENTRY **)v9->Next != v8) )
              __fastfail(3u);
            v9->Next = (struct _SLIST_ENTRY *)v7;
            *(_QWORD *)(v7 + 8) = v9;
          }
          ExReleaseFastMutex(&g_KeMutek3);
          ExFreePoolWithTag(Next, 0);
        }
      }
      ++Lookaside.L.TotalFrees;
      if ( ExQueryDepthSList(&Lookaside.L.ListHead) < Lookaside.L.Depth )
      {
        ExpInterlockedPushEntrySList(&Lookaside.L.ListHead, v4 - 8);
      }
      else
      {
        ++Lookaside.L.FreeMisses;
        Lookaside.L.FreeEx(&v4[-8], v10);
      }
    }
  }
  while ( !v1 );
}
// 1800077E5: variable 'v10' is possibly undefined

//----- (0000000180007840) ----------------------------------------------------
__int64 __fastcall DriverInitialize(PDRIVER_OBJECT Driver, struct _UNICODE_STRING *a2)
{
  __int64 result; // rax
  unsigned int v5; // ebx

  PsGetVersion(0i64, 0i64, &BuildNumber, 0i64);
  if ( BuildNumber < 0xA28 )
    return 3221225659i64;
  qword_18000F740 = (__int64)Driver;
  result = DriverStartUp(Driver);
  v5 = result;
  if ( (int)result >= 0 )
  {
    DriverKeInitialize();
    DriverKeInitialize2();
    DriverKeInitialize3();
    IntializeLogger(Driver);
    sub_180001B10(a2);
    return v5;
  }
  return result;
}
// 18000F740: using guessed type __int64 qword_18000F740;

//----- (00000001800078D0) ----------------------------------------------------
PVOID __fastcall DriverAllocateWithTag(POOL_TYPE PoolType, unsigned int NumberOfBytes, char Tag)
{
  return ExAllocatePoolWithTag(PoolType, NumberOfBytes, (Tag << 24) | 0x6E6D50u);
}

//----- (00000001800078F0) ----------------------------------------------------
struct _UNICODE_STRING *__fastcall sub_1800078F0(POOL_TYPE a1, const UNICODE_STRING *a2, char a3)
{
  struct _UNICODE_STRING *result; // rax
  struct _UNICODE_STRING *v5; // rbx

  result = (struct _UNICODE_STRING *)ExAllocatePoolWithTag(a1, a2->Length + 16i64, (a3 << 24) | 0x6E6D50u);
  v5 = result;
  if ( result )
  {
    result->MaximumLength = a2->Length;
    result->Buffer = &result[1].Length;
    RtlCopyUnicodeString(result, a2);
    return v5;
  }
  return result;
}

//----- (0000000180007950) ----------------------------------------------------
void __fastcall sub_180007950(int a1, __int64 a2, __int64 a3)
{
  if ( a1 )
    sub_180003B80(1);
  sub_180005940(a1 & 1, a2, a3);
  sub_1800085B0(a1 & 0xC);
  if ( (a1 & 2) != 0 )
    sub_180002BA0(1);
  sub_180001FD0(a1 & 0x10);
  if ( !a1 )
    sub_180003B80(0);
  dword_18000F524 = a1;
}
// 180007969: variable 'a2' is possibly undefined
// 180007969: variable 'a3' is possibly undefined
// 18000F524: using guessed type int dword_18000F524;

//----- (00000001800079B0) ----------------------------------------------------
UNICODE_STRING *__fastcall sub_1800079B0(char a1, void *a2, const UNICODE_STRING *a3)
{
  UNICODE_STRING *p_Name; // rbx
  const UNICODE_STRING *v6; // rdi
  struct _UNICODE_STRING *v7; // rax
  unsigned __int16 v8; // si
  struct _UNICODE_STRING *v9; // rax
  USHORT v10; // si
  struct _OBJECT_NAME_INFORMATION *v11; // rax
  struct _UNICODE_STRING *v12; // rax
  struct _UNICODE_STRING *v13; // rsi
  UNICODE_STRING *result; // rax
  PWSTR Buffer; // r8
  _DWORD v16[2]; // [rsp+20h] [rbp-58h] BYREF
  PUNICODE_STRING Destination; // [rsp+28h] [rbp-50h]
  struct _UNICODE_STRING *v18; // [rsp+30h] [rbp-48h]
  PCUNICODE_STRING SourceString; // [rsp+38h] [rbp-40h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+40h] [rbp-38h] BYREF
  ULONG ReturnLength; // [rsp+98h] [rbp+20h] BYREF

  p_Name = 0i64;
  Destination = 0i64;
  wcscpy((wchar_t *)v16, L"\\");
  SourceString = 0i64;
  v6 = 0i64;
  v18 = 0i64;
  if ( a3 )
  {
    if ( a3->Length )
    {
      v6 = a3;
      v18 = (struct _UNICODE_STRING *)a3;
    }
    else
    {
      v7 = &stru_18000F700;
      if ( a1 )
        v7 = 0i64;
      v6 = v7;
      v18 = v7;
    }
  }
  if ( a2 )
  {
    if ( DriverCmCallbackGetKeyObjectID
      && (int)DriverCmCallbackGetKeyObjectID(&qword_18000F6F0, a2, 0i64, &SourceString, v16[0], Destination, v18) >= 0 )
    {
      v8 = SourceString->Length + 16;
      if ( v6 )
        v8 += v6->Length + 4;
      v9 = (struct _UNICODE_STRING *)DriverAllocateWithTag(NonPagedPool, v8, 68);
      p_Name = v9;
      Destination = v9;
      if ( v9 )
      {
        v9->Length = 0;
        v9->MaximumLength = v8 - 16;
        v9->Buffer = &v9[1].Length;
        RtlCopyUnicodeString(v9, SourceString);
      }
    }
    else if ( ObQueryNameString(a2, 0i64, 0, &ReturnLength) == -1073741820 )
    {
      v10 = ReturnLength;
      if ( v6 )
        v10 = v6->Length + ReturnLength + 4;
      v11 = (struct _OBJECT_NAME_INFORMATION *)DriverAllocateWithTag(NonPagedPool, v10, 68);
      p_Name = &v11->Name;
      Destination = &v11->Name;
      if ( v11 )
      {
        if ( ObQueryNameString(a2, v11, ReturnLength, &ReturnLength) >= 0 )
        {
          if ( a3 )
            p_Name->MaximumLength = v10;
        }
        else
        {
          ExFreePoolWithTag(p_Name, 0);
          p_Name = &::Destination;
          Destination = &::Destination;
        }
      }
    }
    if ( p_Name && !RtlCompareUnicodeString(p_Name, &String2, 1u) )
    {
      if ( p_Name != &::Destination )
        ExFreePoolWithTag(p_Name, 0);
      p_Name = 0i64;
      Destination = 0i64;
    }
  }
  if ( v6 )
  {
    if ( p_Name )
    {
      if ( p_Name != &::Destination )
      {
        RtlInitUnicodeString(&DestinationString, (PCWSTR)v16);
        RtlAppendUnicodeStringToString(p_Name, &DestinationString);
        RtlAppendUnicodeStringToString(p_Name, v6);
      }
    }
    else
    {
      v12 = (struct _UNICODE_STRING *)DriverAllocateWithTag(NonPagedPool, (unsigned int)v6->Length + 16, 69);
      v13 = v12;
      Destination = v12;
      if ( v12 )
      {
        v12->Buffer = &v12[1].Length;
        v12->MaximumLength = v6->Length;
        RtlCopyUnicodeString(v12, v6);
      }
      p_Name = &::Destination;
      if ( v13 )
        p_Name = v13;
    }
  }
  result = &Source;
  if ( p_Name )
    result = p_Name;
  if ( !result )
    return 0i64;
  Buffer = result->Buffer;
  if ( !Buffer )
    return 0i64;
  if ( !v6 && Buffer[((unsigned __int64)result->Length >> 1) - 1] == 92 )
    result->Length -= 2;
  return result;
}
// 18000F558: invalid function type '?' has been ignored
// 18000F558: using guessed type __int64 (__fastcall *qword_18000F558)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD);
// 18000F6F0: using guessed type __int64 qword_18000F6F0;

//----- (0000000180007D00) ----------------------------------------------------
int __fastcall sub_180007D00(int a1, struct _SLIST_ENTRY *a2)
{
  PSLIST_ENTRY v4; // rax
  PSLIST_ENTRY v5; // rbx
  __int64 v6; // rax
  __int64 *v7; // rbx

  ++dword_18000F594;
  v4 = ExpInterlockedPopEntrySList(&stru_18000F580);
  v5 = v4;
  if ( !v4 )
  {
    ++dword_18000F598;
    v4 = (PSLIST_ENTRY)qword_18000F5B0(
                         (unsigned int)dword_18000F5A4,
                         (unsigned int)dword_18000F5AC,
                         (unsigned int)dword_18000F5A8);
    v5 = v4;
  }
  if ( v5 )
  {
    *((_QWORD *)&v5->Next + 1) = KeGetCurrentThread();
    v5->Next = a2;
    LODWORD(v5[1].Next) = a1;
    KeWaitForSingleObject(&Mutex, Executive, 0, 0, 0i64);
    v6 = qword_18000F6E0;
    v7 = (__int64 *)(&v5[1].Next + 1);
    if ( *(__int64 **)(qword_18000F6E0 + 8) != &qword_18000F6E0 )
      __fastfail(3u);
    v7[1] = (__int64)&qword_18000F6E0;
    *v7 = v6;
    *(_QWORD *)(v6 + 8) = v7;
    qword_18000F6E0 = (__int64)v7;
    LODWORD(v4) = KeReleaseMutex(&Mutex, 0);
  }
  return (int)v4;
}
// 18000F594: using guessed type int dword_18000F594;
// 18000F598: using guessed type int dword_18000F598;
// 18000F5A4: using guessed type int dword_18000F5A4;
// 18000F5A8: using guessed type int dword_18000F5A8;
// 18000F5AC: using guessed type int dword_18000F5AC;
// 18000F5B0: using guessed type __int64 (__fastcall *qword_18000F5B0)(_QWORD, _QWORD, _QWORD);
// 18000F6E0: using guessed type __int64 qword_18000F6E0;

//----- (0000000180007DE0) ----------------------------------------------------
__int64 __fastcall sub_180007DE0(__int64 a1, int a2, __int64 a3)
{
  int v4; // eax
  __int16 v5; // di
  int v6; // ecx
  int v7; // eax
  _QWORD *v8; // rax
  _QWORD *v9; // rsi
  __int64 v10; // rax
  unsigned int *v11; // rdx
  unsigned int v12; // r12d
  unsigned int v13; // r15d
  int v14; // ecx
  int v15; // r14d
  unsigned int v16; // ebx
  _OWORD *v17; // rax
  struct _SLIST_ENTRY *v18; // rcx
  int v19; // eax
  int v20; // eax
  int v21; // esi
  void *v22; // r15
  void *v23; // r14
  HANDLE CurrentProcessId; // rax
  __int64 *v25; // r13
  UNICODE_STRING *v26; // r14
  UNICODE_STRING *v27; // rax
  __int16 v28; // r8
  UNICODE_STRING *v29; // r15
  __int64 v30; // rax
  __int64 v31; // rdi
  __int64 v32; // rcx
  void *v33; // r15
  void *v34; // r14
  HANDLE v35; // rax
  unsigned __int16 *v36; // r12
  unsigned __int16 *v37; // rsi
  void *v38; // rdi
  HANDLE v39; // rax
  __int64 *v40; // r15
  UNICODE_STRING *v41; // r14
  __int64 v42; // rax
  __int64 v43; // rdi
  unsigned __int8 v44; // r8
  int v45; // eax
  int v46; // eax
  int *v47; // rax
  struct _SLIST_ENTRY *v48; // rdi
  int v49; // eax
  int *v50; // rax
  int v51; // eax
  int v52; // eax
  int *v53; // rax
  int v54; // eax
  int *v55; // rax
  int v56; // eax
  int v57; // eax
  __int64 v58; // rax
  int v59; // ecx
  __int64 v61; // [rsp+88h] [rbp+20h] BYREF
  PVOID Object; // [rsp+90h] [rbp+28h] BYREF
  __int64 v63; // [rsp+98h] [rbp+30h] BYREF

  switch ( a2 )
  {
    case 0:
      v44 = 9;
      goto LABEL_68;
    case 1:
      v51 = sub_18000A480(
              0i64,
              *(void **)a3,
              *(const UNICODE_STRING **)(a3 + 8),
              *(unsigned int *)(a3 + 16),
              *(_DWORD *)(a3 + 20),
              *(char **)(a3 + 24),
              *(_DWORD *)(a3 + 32));
      sub_180007D00(v51, (struct _SLIST_ENTRY *)a3);
      return 0i64;
    case 2:
      v45 = sub_180008DF0(0i64, *(void **)a3, *(const UNICODE_STRING **)(a3 + 8));
      sub_180007D00(v45, (struct _SLIST_ENTRY *)a3);
      return 0i64;
    case 3:
      v4 = sub_18000A1C0(0i64, *(void **)a3, *(_DWORD *)(a3 + 8), *(char **)(a3 + 16), *(_DWORD *)(a3 + 24));
      sub_180007D00(v4, (struct _SLIST_ENTRY *)a3);
      return 0i64;
    case 4:
      v56 = sub_180009F40(0i64, *(void **)a3, *(unsigned __int16 **)(a3 + 8));
      sub_180007D00(v56, (struct _SLIST_ENTRY *)a3);
      return 0i64;
    case 5:
      v52 = sub_180009010(0i64, *(void **)a3, *(_DWORD *)(a3 + 8), *(_DWORD *)(a3 + 12), *(_DWORD *)(a3 + 24));
      sub_180007D00(v52, (struct _SLIST_ENTRY *)a3);
      return 0i64;
    case 6:
      v49 = sub_180009240(0i64, *(void **)a3, *(_DWORD *)(a3 + 8), *(_DWORD *)(a3 + 12), *(_DWORD *)(a3 + 24));
      sub_180007D00(v49, (struct _SLIST_ENTRY *)a3);
      return 0i64;
    case 7:
      v54 = sub_180009AE0(0i64, *(void **)a3, *(_DWORD *)(a3 + 8), *(_DWORD *)(a3 + 24));
      sub_180007D00(v54, (struct _SLIST_ENTRY *)a3);
      return 0i64;
    case 8:
      v46 = sub_180009D10(
              0i64,
              *(void **)a3,
              *(const UNICODE_STRING **)(a3 + 8),
              *(_DWORD *)(a3 + 16),
              *(_QWORD *)(a3 + 24),
              *(_DWORD *)(a3 + 32));
      sub_180007D00(v46, (struct _SLIST_ENTRY *)a3);
      return 0i64;
    case 9:
      v44 = 15;
      goto LABEL_68;
    case 13:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 24:
    case 25:
    case 31:
    case 33:
    case 35:
    case 37:
    case 39:
    case 42:
    case 44:
    case 46:
      v58 = sub_180008B40();
      v48 = (struct _SLIST_ENTRY *)v58;
      if ( !v58 )
        return 0i64;
      v59 = *(_DWORD *)(v58 + 16);
      if ( v59 != -1 )
      {
        sub_180003D20(v59, *(_DWORD *)(a3 + 8), 0, (PSLIST_ENTRY *)&v61);
        sub_180004460(v61);
      }
      goto LABEL_72;
    case 14:
      v44 = 2;
      goto LABEL_68;
    case 20:
      v53 = (int *)sub_180008B40();
      v48 = (struct _SLIST_ENTRY *)v53;
      if ( !v53 )
        return 0i64;
      sub_180008CB0(
        v53[4],
        *(_DWORD *)(a3 + 8),
        *(unsigned int *)(*(_QWORD *)v53 + 12i64),
        *(char **)(*(_QWORD *)v53 + 16i64),
        *(unsigned __int16 **)(*(_QWORD *)v53 + 32i64));
      goto LABEL_72;
    case 21:
      v50 = (int *)sub_180008B40();
      v48 = (struct _SLIST_ENTRY *)v50;
      if ( !v50 )
        return 0i64;
      sub_180008BE0(
        v50[4],
        *(_DWORD *)(a3 + 8),
        *(_DWORD *)(*(_QWORD *)v50 + 12i64),
        *(_QWORD *)(*(_QWORD *)v50 + 16i64),
        *(unsigned int **)(*(_QWORD *)v50 + 32i64));
      goto LABEL_72;
    case 22:
      v55 = (int *)sub_180008B40();
      v48 = (struct _SLIST_ENTRY *)v55;
      if ( !v55 )
        return 0i64;
      sub_180008CB0(
        v55[4],
        *(_DWORD *)(a3 + 8),
        *(unsigned int *)(*(_QWORD *)v55 + 8i64),
        *(char **)(*(_QWORD *)v55 + 16i64),
        *(unsigned __int16 **)(*(_QWORD *)v55 + 32i64));
      goto LABEL_72;
    case 23:
      v47 = (int *)sub_180008B40();
      v48 = (struct _SLIST_ENTRY *)v47;
      if ( !v47 )
        return 0i64;
      sub_180008BE0(
        v47[4],
        *(_DWORD *)(a3 + 8),
        *(_DWORD *)(*(_QWORD *)v47 + 16i64),
        *(_QWORD *)(*(_QWORD *)v47 + 24i64),
        *(unsigned int **)(*(_QWORD *)v47 + 40i64));
LABEL_72:
      v18 = v48;
      goto LABEL_73;
    case 26:
    case 28:
      HIBYTE(v5) = 0;
      if ( BuildNumber <= 0xECE )
        v6 = 0;
      else
        v6 = *(_DWORD *)(a3 + 56);
      LOBYTE(v5) = a2 != 28;
      v7 = sub_180009910(v5, v6, 0i64, *(void **)(a3 + 8), *(const UNICODE_STRING **)a3);
      sub_180007D00(v7, (struct _SLIST_ENTRY *)a3);
      return 0i64;
    case 27:
    case 29:
      v8 = (_QWORD *)sub_180008B40();
      v9 = v8;
      if ( !v8 )
        return 0i64;
      v10 = *v8;
      if ( BuildNumber > 0xECE && (v11 = *(unsigned int **)(v10 + 64)) != 0i64 )
        v12 = *v11;
      else
        v12 = 0;
      if ( BuildNumber <= 0xECE )
        v13 = 0;
      else
        v13 = *(_DWORD *)(v10 + 60);
      v14 = *((_DWORD *)v9 + 4);
      v15 = *(_DWORD *)(a3 + 8);
      Object = 0i64;
      if ( v14 != -1 )
      {
        v16 = 8;
        if ( v15 )
          v16 = 0;
        v17 = (_OWORD *)sub_180003D20(v14, v15, v16, (PSLIST_ENTRY *)&Object);
        if ( v17 && !v15 )
        {
          v61 = __PAIR64__(v12, v13);
          sub_18000AC00(v17, (char *)&v61, v16);
        }
        sub_180004460((__int64)Object);
      }
      v18 = (struct _SLIST_ENTRY *)v9;
LABEL_73:
      sub_1800087B0(v18);
      return 0i64;
    case 30:
      v44 = 11;
      goto LABEL_68;
    case 32:
      v19 = sub_1800097D0(*(void **)a3, *(const UNICODE_STRING **)(a3 + 8), *(unsigned __int16 **)(a3 + 16));
      sub_180007D00(v19, (struct _SLIST_ENTRY *)a3);
      return 0i64;
    case 34:
      v20 = sub_18000A740(0i64, *(void **)a3);
      sub_180007D00(v20, (struct _SLIST_ENTRY *)a3);
      return 0i64;
    case 36:
      v44 = 17;
      goto LABEL_68;
    case 38:
      v44 = 16;
LABEL_68:
      v57 = sub_180008D90(0i64, *(void **)a3, v44, 2u);
      sub_180007D00(v57, (struct _SLIST_ENTRY *)a3);
      return 0i64;
    case 41:
      v21 = *(_DWORD *)(a3 + 16);
      v22 = *(void **)(a3 + 8);
      v23 = *(void **)a3;
      Object = 0i64;
      LODWORD(v61) = -1;
      CurrentProcessId = PsGetCurrentProcessId();
      v25 = sub_1800046B0((__int64)CurrentProcessId, 1);
      if ( !v25 )
        goto LABEL_37;
      v26 = sub_1800079B0(1, v23, 0i64);
      ObReferenceObjectByHandle(v22, 0, 0i64, 0, &Object, 0i64);
      v27 = sub_1800079B0(1, Object, 0i64);
      v28 = 19;
      goto LABEL_27;
    case 43:
      v21 = *(_DWORD *)(a3 + 16);
      v33 = *(void **)(a3 + 8);
      v34 = *(void **)a3;
      Object = 0i64;
      LODWORD(v61) = -1;
      v35 = PsGetCurrentProcessId();
      v25 = sub_1800046B0((__int64)v35, 1);
      if ( !v25 )
        goto LABEL_37;
      v26 = sub_1800079B0(1, v34, 0i64);
      ObReferenceObjectByHandle(v33, 0, 0i64, 0, &Object, 0i64);
      v27 = sub_1800079B0(1, Object, 0i64);
      v28 = 20;
LABEL_27:
      v29 = v27;
      v30 = sub_180003D60(
              1,
              2u,
              v28,
              *((_DWORD *)v25 + 3),
              259,
              v27->Length + 8 + (unsigned int)v26->Length,
              &v61,
              (PSLIST_ENTRY *)&v63);
      v31 = v30;
      if ( v30 )
      {
        *(_DWORD *)(v30 + 4) = v21;
        *(_WORD *)v30 = v26->Length >> 1;
        sub_18000AC00((_OWORD *)(v30 + 8), (char *)v26->Buffer, v26->Length);
        *(_WORD *)(v31 + 2) = v29->Length >> 1;
        sub_18000AC00((_OWORD *)(v31 + v26->Length + 8i64), (char *)v29->Buffer, v29->Length);
        sub_180004460(v63);
      }
      if ( v26 != &Source && v26 != &Destination )
        ExFreePoolWithTag(v26, 0);
      if ( v29 != &Source && v29 != &Destination )
        ExFreePoolWithTag(v29, 0);
      v32 = (__int64)v25;
      break;
    case 45:
      v36 = *(unsigned __int16 **)(a3 + 16);
      v37 = *(unsigned __int16 **)(a3 + 8);
      v38 = *(void **)a3;
      LODWORD(v61) = -1;
      v39 = PsGetCurrentProcessId();
      v40 = sub_1800046B0((__int64)v39, 1);
      if ( !v40 )
        goto LABEL_37;
      v41 = sub_1800079B0(1, v38, 0i64);
      v42 = sub_180003D60(
              1,
              2u,
              21,
              *((_DWORD *)v40 + 3),
              259,
              *v37 + *v36 + 8 + (unsigned int)v41->Length,
              &v61,
              (PSLIST_ENTRY *)&Object);
      v43 = v42;
      if ( v42 )
      {
        *(_WORD *)v42 = v41->Length >> 1;
        sub_18000AC00((_OWORD *)(v42 + 6), (char *)v41->Buffer, v41->Length);
        *(_WORD *)(v43 + 2) = *v37 >> 1;
        *(_WORD *)(v43 + 4) = *v36 >> 1;
        sub_18000AC00((_OWORD *)(v43 + v41->Length + 8i64), *((char **)v37 + 1), *v37);
        sub_18000AC00((_OWORD *)(v43 + *v37 + v41->Length + 8i64), *((char **)v36 + 1), *v36);
        sub_180004460((__int64)Object);
      }
      if ( v41 != &Source && v41 != &Destination )
        ExFreePoolWithTag(v41, 0);
      v32 = (__int64)v40;
      break;
    default:
      return 0i64;
  }
  sub_180004620(v32);
LABEL_37:
  sub_180007D00(v61, (struct _SLIST_ENTRY *)a3);
  return 0i64;
}

//----- (00000001800085B0) ----------------------------------------------------
__int64 __fastcall sub_1800085B0(int a1)
{
  __int64 result; // rax
  __int64 **v2; // rax
  __int64 *v3; // rdx
  __int64 **v4; // rax
  __int64 *v5; // rcx
  __int64 **v6; // rbx
  struct _UNICODE_STRING DestinationString; // [rsp+30h] [rbp-18h] BYREF

  if ( !a1 )
  {
    if ( !byte_18000F600 || !DriverCmUnRegisterCallback )
      return 0i64;
    KeWaitForSingleObject(&Mutex, Executive, 0, 0, 0i64);
    v2 = (__int64 **)qword_18000F6E0;
    if ( (__int64 *)qword_18000F6E0 == &qword_18000F6E0 )
    {
LABEL_16:
      KeReleaseMutex(&Mutex, 0);
      DriverCmUnRegisterCallback(qword_18000F6F0);
      KeWaitForSingleObject(&g_KeMutek4, Executive, 0, 0, 0i64);
      v4 = (__int64 **)qword_18000F680;
      if ( (__int64 *)qword_18000F680 == &qword_18000F680 )
      {
LABEL_20:
        KeReleaseMutex(&g_KeMutek4, 0);
        byte_18000F600 = 0;
        return 0i64;
      }
      while ( v4[1] == &qword_18000F680 )
      {
        v5 = *v4;
        if ( (__int64 **)(*v4)[1] != v4 )
          break;
        qword_18000F680 = (__int64)*v4;
        v6 = v4 - 2;
        v5[1] = (__int64)&qword_18000F680;
        ExFreePoolWithTag(*(v4 - 1), 0);
        ExFreePoolWithTag(v6, 0);
        v4 = (__int64 **)qword_18000F680;
        if ( (__int64 *)qword_18000F680 == &qword_18000F680 )
          goto LABEL_20;
      }
    }
    else
    {
      while ( v2[1] == &qword_18000F6E0 )
      {
        v3 = *v2;
        if ( (__int64 **)(*v2)[1] != v2 )
          break;
        qword_18000F6E0 = (__int64)*v2;
        v3[1] = (__int64)&qword_18000F6E0;
        ExFreePoolWithTag(v2 - 3, 0);
        v2 = (__int64 **)qword_18000F6E0;
        if ( (__int64 *)qword_18000F6E0 == &qword_18000F6E0 )
          goto LABEL_16;
      }
    }
    __fastfail(3u);
  }
  if ( byte_18000F600 )
    return 0i64;
  if ( (DriverCmRegisterCallback || DriverCmRegisterCallbackEx) && (a1 & 8) == 0 )
  {
    if ( DriverCmRegisterCallbackEx )
    {
      RtlInitUnicodeString(&DestinationString, L"500000");
      DriverCmRegisterCallbackEx(sub_180007DE0, &DestinationString, qword_18000F740, 0i64, &qword_18000F6F0, 0i64);
      result = 0i64;
      byte_18000F600 = 1;
      return result;
    }
    DriverCmRegisterCallback(sub_180007DE0, 0i64, &qword_18000F6F0);
  }
  byte_18000F600 = 1;
  return 0i64;
}
// 18000F550: invalid function type '?' has been ignored
// 18000F548: invalid function type '?' has been ignored
// 18000F540: invalid function type '?' has been ignored
// 18000F540: using guessed type __int64 (__fastcall *qword_18000F540)(_QWORD);
// 18000F548: using guessed type __int64 (__fastcall *qword_18000F548)(_QWORD, _QWORD, _QWORD);
// 18000F550: using guessed type __int64 (__fastcall *qword_18000F550)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18000F600: using guessed type char byte_18000F600;
// 18000F680: using guessed type __int64 qword_18000F680;
// 18000F6E0: using guessed type __int64 qword_18000F6E0;
// 18000F6F0: using guessed type __int64 qword_18000F6F0;
// 18000F740: using guessed type __int64 qword_18000F740;

//----- (00000001800087B0) ----------------------------------------------------
PSLIST_ENTRY __fastcall sub_1800087B0(struct _SLIST_ENTRY *a1)
{
  ++dword_18000F59C;
  if ( ExQueryDepthSList(&stru_18000F580) < (unsigned __int16)word_18000F590 )
    return ExpInterlockedPushEntrySList(&stru_18000F580, a1);
  ++dword_18000F5A0;
  return (PSLIST_ENTRY)qword_18000F5B8(a1);
}
// 18000F590: using guessed type __int16 word_18000F590;
// 18000F59C: using guessed type int dword_18000F59C;
// 18000F5A0: using guessed type int dword_18000F5A0;
// 18000F5B8: using guessed type __int64 (__fastcall *qword_18000F5B8)(_QWORD);

//----- (0000000180008800) ----------------------------------------------------
__int16 __fastcall sub_180008800(int a1, __int64 a2, unsigned int a3)
{
  __int16 result; // ax

  switch ( a1 )
  {
    case 0:
    case 3:
      result = 16;
      if ( a3 < 0x10 )
        result = a3;
      break;
    case 1:
    case 2:
    case 7:
      result = 2048;
      if ( a3 < 0x800 )
        result = a3;
      break;
    case 4:
      result = 4;
      break;
    case 11:
      result = 8;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (0000000180008880) ----------------------------------------------------
unsigned __int16 __fastcall sub_180008880(int a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  int v6; // ecx
  unsigned __int16 result; // ax
  unsigned int v8; // ecx
  unsigned int v9; // r8d
  __int64 v10; // rbx
  unsigned __int16 v11; // ax

  *a4 = 0i64;
  if ( a1 )
  {
    v6 = a1 - 1;
    if ( v6 )
    {
      if ( v6 == 1 )
      {
        result = sub_180008800(*(_DWORD *)(a2 + 4), a2 + 12, *(_DWORD *)(a2 + 8));
        v8 = result + 12;
        goto LABEL_7;
      }
    }
    else
    {
      v9 = *(_DWORD *)(a2 + 12);
      if ( v9 )
      {
        v10 = *(unsigned int *)(a2 + 8);
        result = sub_180008800(*(_DWORD *)(a2 + 4), a2 + v10, v9);
        v8 = v10 + result;
LABEL_7:
        if ( !v8 )
          return result;
        goto LABEL_11;
      }
    }
    return 0;
  }
  v8 = 16;
LABEL_11:
  v11 = -1;
  if ( v8 < 0xFFFF )
    v11 = v8;
  return sub_180008AB0((char *)a2, v11, a4);
}

//----- (0000000180008930) ----------------------------------------------------
void DriverKeInitialize3()
{
  struct _UNICODE_STRING DestinationString; // [rsp+40h] [rbp-18h] BYREF

  RtlInitUnicodeString(&Destination, aInsufficientRe);
  RtlInitUnicodeString(&Source, aInvalidName);
  RtlInitUnicodeString(&stru_18000F700, L"(Default)");
  RtlInitUnicodeString(&String2, aRegistry);
  if ( BuildNumber >= 0xECE )
  {
    RtlInitUnicodeString(&DestinationString, L"CmRegisterCallback");
    DriverCmRegisterCallback = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&DestinationString);
    RtlInitUnicodeString(&DestinationString, L"CmRegisterCallbackEx");
    DriverCmRegisterCallbackEx = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&DestinationString);
    RtlInitUnicodeString(&DestinationString, L"CmUnRegisterCallback");
    DriverCmUnRegisterCallback = (__int64 (__fastcall *)(_QWORD))MmGetSystemRoutineAddress(&DestinationString);
    RtlInitUnicodeString(&DestinationString, L"CmCallbackGetKeyObjectID");
    DriverCmCallbackGetKeyObjectID = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&DestinationString);
    ExInitializePagedLookasideList((PPAGED_LOOKASIDE_LIST)&stru_18000F580, 0i64, 0i64, 0, 0x28ui64, 0x6D676552u, 0x100u);
    qword_18000F6E8 = (__int64)&qword_18000F6E0;
    qword_18000F6E0 = (__int64)&qword_18000F6E0;
    KeInitializeMutex(&Mutex, 0);
  }
  qword_18000F688 = (__int64)&qword_18000F680;
  qword_18000F680 = (__int64)&qword_18000F680;
  KeInitializeMutex(&g_KeMutek4, 0);
}
// 18000F540: using guessed type __int64 (__fastcall *qword_18000F540)(_QWORD);
// 18000F548: using guessed type __int64 (__fastcall *qword_18000F548)(_QWORD, _QWORD, _QWORD);
// 18000F550: using guessed type __int64 (__fastcall *qword_18000F550)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18000F558: using guessed type __int64 (__fastcall *qword_18000F558)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD);
// 18000F680: using guessed type __int64 qword_18000F680;
// 18000F688: using guessed type __int64 qword_18000F688;
// 18000F6E0: using guessed type __int64 qword_18000F6E0;
// 18000F6E8: using guessed type __int64 qword_18000F6E8;

//----- (0000000180008AB0) ----------------------------------------------------
__int64 __fastcall sub_180008AB0(char *a1, unsigned __int16 a2, _QWORD *a3)
{
  unsigned __int64 v4; // rbx
  _OWORD *v6; // rax

  v4 = a2;
  if ( a2 )
  {
    v6 = DriverAllocateWithTag(NonPagedPool, a2, 74);
    *a3 = v6;
    if ( v6 )
      sub_18000AC00(v6, a1, v4);
    else
      LOWORD(v4) = 0;
  }
  return (unsigned __int16)v4;
}

//----- (0000000180008B40) ----------------------------------------------------
__int64 sub_180008B40()
{
  struct _KTHREAD *CurrentThread; // rbx
  __int64 v1; // rdi
  __int64 v2; // rax
  __int64 *v3; // rcx
  __int64 **v5; // rdx

  CurrentThread = KeGetCurrentThread();
  v1 = 0i64;
  KeWaitForSingleObject(&Mutex, Executive, 0, 0, 0i64);
  v2 = qword_18000F6E0;
  if ( (__int64 *)qword_18000F6E0 != &qword_18000F6E0 )
  {
    while ( 1 )
    {
      v3 = *(__int64 **)v2;
      if ( *(struct _KTHREAD **)(v2 - 16) == CurrentThread )
        break;
      v2 = *(_QWORD *)v2;
      if ( v3 == &qword_18000F6E0 )
        goto LABEL_4;
    }
    if ( v3[1] != v2 || (v5 = *(__int64 ***)(v2 + 8), *v5 != (__int64 *)v2) )
      __fastfail(3u);
    *v5 = v3;
    v1 = v2 - 24;
    v3[1] = (__int64)v5;
  }
LABEL_4:
  KeReleaseMutex(&Mutex, 0);
  return v1;
}
// 18000F6E0: using guessed type __int64 qword_18000F6E0;

//----- (0000000180008BE0) ----------------------------------------------------
void __fastcall sub_180008BE0(int a1, int a2, int a3, __int64 a4, unsigned int *a5)
{
  unsigned int v7; // ebp
  char *v8; // rax
  PVOID v9; // rbx
  __int64 v10; // [rsp+20h] [rbp-18h] BYREF
  PVOID P[2]; // [rsp+28h] [rbp-10h] BYREF

  if ( a1 != -1 )
  {
    v10 = 0i64;
    if ( a2 < 0 )
    {
      sub_180003D20(a1, a2, 0, (PSLIST_ENTRY *)&v10);
    }
    else
    {
      v7 = sub_180008880(a3, a4, *a5, P);
      v8 = (char *)sub_180003D20(a1, a2, v7, (PSLIST_ENTRY *)&v10);
      v9 = P[0];
      if ( v8 && (_WORD)v7 )
      {
        if ( P[0] )
          sub_18000AC00(v8, (char *)P[0], v7);
        else
          sub_18000AEC0(v8, 0, v7);
      }
      if ( v9 )
        ExFreePoolWithTag(v9, 0);
    }
    sub_180004460(v10);
  }
}
// 180008BE0: using guessed type PVOID P[2];

//----- (0000000180008CB0) ----------------------------------------------------
void __fastcall sub_180008CB0(int a1, int a2, __int64 a3, char *a4, unsigned __int16 *a5)
{
  char *v5; // rbx
  unsigned __int16 v8; // di
  unsigned __int16 v9; // ax
  char *v10; // rax
  __int64 v11; // [rsp+20h] [rbp-18h] BYREF
  char *v12; // [rsp+28h] [rbp-10h] BYREF

  if ( a1 != -1 )
  {
    v5 = 0i64;
    v11 = 0i64;
    if ( a2 < 0 )
    {
      sub_180003D20(a1, a2, 0, (PSLIST_ENTRY *)&v11);
    }
    else
    {
      v12 = 0i64;
      v8 = *a5;
      if ( *a5 )
      {
        v9 = sub_180008AB0(a4, v8, &v12);
        v5 = v12;
        v8 = v9;
      }
      v10 = (char *)sub_180003D20(a1, a2, v8, (PSLIST_ENTRY *)&v11);
      if ( v10 && v8 )
      {
        if ( v5 )
          sub_18000AC00(v10, v5, v8);
        else
          sub_18000AEC0(v10, 0, v8);
      }
      if ( v5 )
        ExFreePoolWithTag(v5, 0);
    }
    sub_180004460(v11);
  }
}

//----- (0000000180008D90) ----------------------------------------------------
__int64 __fastcall sub_180008D90(void *a1, void *a2, unsigned __int8 a3, unsigned int a4)
{
  __int64 v5; // [rsp+40h] [rbp-18h] BYREF
  __int64 Object; // [rsp+48h] [rbp-10h] BYREF

  LODWORD(v5) = -1;
  if ( sub_180009470(a1, a2, 0i64, a3, a4, 0, (PSLIST_ENTRY *)&Object, &v5) )
    sub_180004460(Object);
  return (unsigned int)v5;
}

//----- (0000000180008DF0) ----------------------------------------------------
__int64 __fastcall sub_180008DF0(HANDLE Handle, void *a2, const UNICODE_STRING *a3)
{
  __int64 v3; // rdi
  HANDLE CurrentProcessId; // rax
  __int64 *v8; // r14
  UNICODE_STRING *v9; // rbx
  __int64 *v10; // rax
  PVOID v11; // rsi
  NTSTATUS v12; // eax
  char v13; // si
  __int64 v14; // rax
  PVOID Object; // [rsp+40h] [rbp-28h] BYREF
  __int64 v17; // [rsp+48h] [rbp-20h] BYREF
  unsigned int v18; // [rsp+88h] [rbp+20h] BYREF

  v3 = 0i64;
  v18 = -1;
  v17 = 0i64;
  if ( (dword_18000F524 & 0xC) != 0 )
  {
    CurrentProcessId = PsGetCurrentProcessId();
    v8 = sub_1800046B0((__int64)CurrentProcessId, 1);
    if ( !v8 )
      return v18;
    v9 = 0i64;
    if ( a2 )
    {
      KeWaitForSingleObject(&g_KeMutek4, Executive, 0, 0, 0i64);
      v10 = (__int64 *)qword_18000F680;
      if ( (__int64 *)qword_18000F680 != &qword_18000F680 )
      {
        while ( (void *)*(v10 - 2) != a2 )
        {
          v10 = (__int64 *)*v10;
          if ( v10 == &qword_18000F680 )
            goto LABEL_9;
        }
        v9 = (UNICODE_STRING *)*(v10 - 1);
      }
LABEL_9:
      KeReleaseMutex(&g_KeMutek4, 0);
    }
    if ( v9 )
    {
      v13 = 1;
    }
    else
    {
      if ( Handle )
      {
        Object = 0i64;
        if ( (int)Handle < 0 && ExGetPreviousMode() )
        {
          v11 = 0i64;
        }
        else
        {
          v12 = ObReferenceObjectByHandle(Handle, 0, 0i64, 0, &Object, 0i64);
          v11 = Object;
          if ( v12 < 0 )
            v11 = 0i64;
          Object = v11;
        }
        v9 = sub_1800079B0(0, v11, a3);
        if ( v11 )
          ObfDereferenceObject(v11);
      }
      else
      {
        v9 = sub_1800079B0(0, a2, a3);
      }
      v13 = 0;
      if ( !v9 )
        goto LABEL_30;
    }
    v14 = sub_180003D60(1, 2u, 10, *((_DWORD *)v8 + 3), 259, (unsigned int)v9->Length + 2, &v18, (PSLIST_ENTRY *)&v17);
    v3 = v14;
    if ( v14 )
    {
      *(_WORD *)v14 = v9->Length >> 1;
      sub_18000AC00((_OWORD *)(v14 + 2), (char *)v9->Buffer, v9->Length);
    }
    if ( !v13 && v9 != &Source && v9 != &Destination )
      ExFreePoolWithTag(v9, 0);
LABEL_30:
    sub_180004620((__int64)v8);
    if ( v3 )
      sub_180004460(v17);
    return v18;
  }
  return 0xFFFFFFFFi64;
}
// 18000F524: using guessed type int dword_18000F524;
// 18000F680: using guessed type __int64 qword_18000F680;

//----- (0000000180009010) ----------------------------------------------------
__int64 __fastcall sub_180009010(HANDLE Handle, void *a2, int a3, int a4, int a5)
{
  _DWORD *v5; // rdi
  HANDLE CurrentProcessId; // rax
  __int64 *v11; // r14
  UNICODE_STRING *v12; // rbx
  __int64 *v13; // rax
  PVOID v14; // rsi
  NTSTATUS v15; // eax
  char v16; // si
  __int64 v17; // rax
  unsigned int v19; // [rsp+40h] [rbp-38h] BYREF
  PVOID Object; // [rsp+48h] [rbp-30h] BYREF
  __int64 v21; // [rsp+50h] [rbp-28h] BYREF

  v5 = 0i64;
  v19 = -1;
  v21 = 0i64;
  if ( (dword_18000F524 & 0xC) != 0 )
  {
    CurrentProcessId = PsGetCurrentProcessId();
    v11 = sub_1800046B0((__int64)CurrentProcessId, 1);
    if ( !v11 )
      return v19;
    v12 = 0i64;
    if ( a2 )
    {
      KeWaitForSingleObject(&g_KeMutek4, Executive, 0, 0, 0i64);
      v13 = (__int64 *)qword_18000F680;
      if ( (__int64 *)qword_18000F680 != &qword_18000F680 )
      {
        while ( (void *)*(v13 - 2) != a2 )
        {
          v13 = (__int64 *)*v13;
          if ( v13 == &qword_18000F680 )
            goto LABEL_9;
        }
        v12 = (UNICODE_STRING *)*(v13 - 1);
      }
LABEL_9:
      KeReleaseMutex(&g_KeMutek4, 0);
    }
    if ( v12 )
    {
      v16 = 1;
    }
    else
    {
      if ( Handle )
      {
        Object = 0i64;
        if ( (int)Handle < 0 && ExGetPreviousMode() )
        {
          v14 = 0i64;
        }
        else
        {
          v15 = ObReferenceObjectByHandle(Handle, 0, 0i64, 0, &Object, 0i64);
          v14 = Object;
          if ( v15 < 0 )
            v14 = 0i64;
          Object = v14;
        }
        v12 = sub_1800079B0(0, v14, 0i64);
        if ( v14 )
          ObfDereferenceObject(v14);
      }
      else
      {
        v12 = sub_1800079B0(0, a2, 0i64);
      }
      v16 = 0;
      if ( !v12 )
        goto LABEL_30;
    }
    v17 = sub_180003D60(1, 2u, 7, *((_DWORD *)v11 + 3), 259, (unsigned int)v12->Length + 16, &v19, (PSLIST_ENTRY *)&v21);
    v5 = (_DWORD *)v17;
    if ( v17 )
    {
      *(_WORD *)v17 = v12->Length >> 1;
      sub_18000AC00((_OWORD *)(v17 + 16), (char *)v12->Buffer, v12->Length);
    }
    if ( !v16 && v12 != &Source && v12 != &Destination )
      ExFreePoolWithTag(v12, 0);
LABEL_30:
    sub_180004620((__int64)v11);
    if ( v5 )
    {
      v5[1] = a5;
      v5[2] = a3;
      v5[3] = a4;
      sub_180004460(v21);
    }
    return v19;
  }
  return 0xFFFFFFFFi64;
}
// 18000F524: using guessed type int dword_18000F524;
// 18000F680: using guessed type __int64 qword_18000F680;

//----- (0000000180009240) ----------------------------------------------------
__int64 __fastcall sub_180009240(HANDLE Handle, void *a2, int a3, int a4, int a5)
{
  _DWORD *v5; // rdi
  HANDLE CurrentProcessId; // rax
  __int64 *v11; // r14
  UNICODE_STRING *v12; // rbx
  __int64 *v13; // rax
  PVOID v14; // rsi
  NTSTATUS v15; // eax
  char v16; // si
  __int64 v17; // rax
  unsigned int v19; // [rsp+40h] [rbp-38h] BYREF
  PVOID Object; // [rsp+48h] [rbp-30h] BYREF
  __int64 v21; // [rsp+50h] [rbp-28h] BYREF

  v5 = 0i64;
  v19 = -1;
  v21 = 0i64;
  if ( (dword_18000F524 & 0xC) != 0 )
  {
    CurrentProcessId = PsGetCurrentProcessId();
    v11 = sub_1800046B0((__int64)CurrentProcessId, 1);
    if ( !v11 )
      return v19;
    v12 = 0i64;
    if ( a2 )
    {
      KeWaitForSingleObject(&g_KeMutek4, Executive, 0, 0, 0i64);
      v13 = (__int64 *)qword_18000F680;
      if ( (__int64 *)qword_18000F680 != &qword_18000F680 )
      {
        while ( (void *)*(v13 - 2) != a2 )
        {
          v13 = (__int64 *)*v13;
          if ( v13 == &qword_18000F680 )
            goto LABEL_9;
        }
        v12 = (UNICODE_STRING *)*(v13 - 1);
      }
LABEL_9:
      KeReleaseMutex(&g_KeMutek4, 0);
    }
    if ( v12 )
    {
      v16 = 1;
    }
    else
    {
      if ( Handle )
      {
        Object = 0i64;
        if ( (int)Handle < 0 && ExGetPreviousMode() )
        {
          v14 = 0i64;
        }
        else
        {
          v15 = ObReferenceObjectByHandle(Handle, 0, 0i64, 0, &Object, 0i64);
          v14 = Object;
          if ( v15 < 0 )
            v14 = 0i64;
          Object = v14;
        }
        v12 = sub_1800079B0(0, v14, 0i64);
        if ( v14 )
          ObfDereferenceObject(v14);
      }
      else
      {
        v12 = sub_1800079B0(0, a2, 0i64);
      }
      v16 = 0;
      if ( !v12 )
        goto LABEL_30;
    }
    v17 = sub_180003D60(1, 2u, 6, *((_DWORD *)v11 + 3), 259, (unsigned int)v12->Length + 16, &v19, (PSLIST_ENTRY *)&v21);
    v5 = (_DWORD *)v17;
    if ( v17 )
    {
      *(_WORD *)v17 = v12->Length >> 1;
      sub_18000AC00((_OWORD *)(v17 + 16), (char *)v12->Buffer, v12->Length);
    }
    if ( !v16 && v12 != &Source && v12 != &Destination )
      ExFreePoolWithTag(v12, 0);
LABEL_30:
    sub_180004620((__int64)v11);
    if ( v5 )
    {
      v5[1] = a5;
      v5[2] = a3;
      v5[3] = a4;
      sub_180004460(v21);
    }
    return v19;
  }
  return 0xFFFFFFFFi64;
}
// 18000F524: using guessed type int dword_18000F524;
// 18000F680: using guessed type __int64 qword_18000F680;

//----- (0000000180009470) ----------------------------------------------------
_WORD *__fastcall sub_180009470(
        HANDLE Handle,
        void *a2,
        const UNICODE_STRING *a3,
        unsigned __int8 a4,
        unsigned int a5,
        int a6,
        PSLIST_ENTRY *Object,
        _DWORD *a8)
{
  PSLIST_ENTRY *v8; // r13
  UNICODE_STRING *v9; // rdi
  char v10; // r14
  __int16 v11; // bp
  _WORD *v15; // r15
  HANDLE CurrentProcessId; // rax
  __int64 *v17; // rax
  __int64 *v18; // rcx
  __int64 v19; // r8
  __int64 *v20; // rdx
  PSLIST_ENTRY *v21; // rbx
  NTSTATUS v22; // eax
  char v23; // bl
  __int64 v24; // r13
  _WORD *v26; // rax
  _QWORD *v27; // rax
  _QWORD *v28; // r14
  __int64 v29; // rcx
  __int64 *v30; // rbx
  _QWORD *v31; // rax
  PSLIST_ENTRY *v32; // [rsp+38h] [rbp-40h]
  __int64 *v33; // [rsp+40h] [rbp-38h]

  v8 = Object;
  v9 = 0i64;
  v10 = 0;
  v11 = a4;
  v15 = 0i64;
  *Object = 0i64;
  if ( (dword_18000F524 & 0xC) != 0 )
  {
    CurrentProcessId = PsGetCurrentProcessId();
    v33 = sub_1800046B0((__int64)CurrentProcessId, 1);
    if ( v33 )
    {
      if ( (unsigned __int8)v11 <= 1u || (unsigned __int8)(v11 - 12) <= 1u )
        v10 = 1;
      if ( a2 )
      {
        KeWaitForSingleObject(&g_KeMutek4, Executive, 0, 0, 0i64);
        v17 = (__int64 *)qword_18000F680;
        if ( (__int64 *)qword_18000F680 != &qword_18000F680 )
        {
          while ( 1 )
          {
            v18 = v17 - 2;
            if ( (void *)*(v17 - 2) == a2 )
              break;
            v17 = (__int64 *)*v17;
            if ( v17 == &qword_18000F680 )
              goto LABEL_15;
          }
          v9 = (UNICODE_STRING *)v18[1];
          if ( (_BYTE)v11 == 2 )
          {
            v19 = *v17;
            if ( *(__int64 **)(*v17 + 8) != v17 )
              goto LABEL_41;
            v20 = (__int64 *)v17[1];
            if ( (__int64 *)*v20 != v17 )
              goto LABEL_41;
            *v20 = v19;
            *(_QWORD *)(v19 + 8) = v20;
            ExFreePoolWithTag(v18, 0);
          }
        }
LABEL_15:
        KeReleaseMutex(&g_KeMutek4, 0);
      }
      if ( v9 )
      {
        v23 = 1;
      }
      else
      {
        if ( Handle )
        {
          Object = 0i64;
          if ( (int)Handle < 0 && ExGetPreviousMode() )
          {
            v21 = 0i64;
          }
          else
          {
            v22 = ObReferenceObjectByHandle(Handle, 0, 0i64, 0, (PVOID *)&Object, 0i64);
            v21 = Object;
            if ( v22 < 0 )
              v21 = 0i64;
            Object = v21;
          }
          v9 = sub_1800079B0(v10, v21, a3);
          if ( v21 )
            ObfDereferenceObject(v21);
        }
        else
        {
          v9 = sub_1800079B0(v10, a2, a3);
        }
        v23 = 0;
        if ( !v9 )
        {
          v24 = (__int64)v33;
          goto LABEL_29;
        }
      }
      v32 = v8;
      v24 = (__int64)v33;
      v26 = (_WORD *)sub_180003D60(1, 2u, v11, *((_DWORD *)v33 + 3), 259, a6 + a5 + v9->Length, a8, v32);
      v15 = v26;
      if ( v26 )
      {
        *v26 = v9->Length >> 1;
        sub_18000AC00((_WORD *)((char *)v26 + a5), (char *)v9->Buffer, v9->Length);
      }
      if ( (_BYTE)v11 != 9 || !a2 )
      {
        if ( (!v23 || (_BYTE)v11 == 2) && v9 != &Source && v9 != &Destination )
          ExFreePoolWithTag(v9, 0);
        goto LABEL_29;
      }
      v27 = DriverAllocateWithTag(NonPagedPool, 0x20u, 52);
      v28 = v27;
      if ( !v27 )
      {
LABEL_29:
        sub_180004620(v24);
        return v15;
      }
      *v27 = a2;
      v27[1] = v9;
      KeWaitForSingleObject(&g_KeMutek4, Executive, 0, 0, 0i64);
      v29 = qword_18000F680;
      v30 = (__int64 *)qword_18000F680;
      if ( (__int64 *)qword_18000F680 != &qword_18000F680 )
      {
        while ( (void *)*(v30 - 2) != a2 )
        {
          v30 = (__int64 *)*v30;
          if ( v30 == &qword_18000F680 )
            goto LABEL_40;
        }
        ExFreePoolWithTag(v28, 0);
        if ( (UNICODE_STRING *)*(v30 - 1) != v9 )
        {
          ExFreePoolWithTag(v9, 0);
          KeReleaseMutex(&g_KeMutek4, 0);
          goto LABEL_29;
        }
LABEL_45:
        KeReleaseMutex(&g_KeMutek4, 0);
        goto LABEL_29;
      }
LABEL_40:
      v31 = v28 + 2;
      if ( *(__int64 **)(qword_18000F680 + 8) == &qword_18000F680 )
      {
        *v31 = qword_18000F680;
        v28[3] = &qword_18000F680;
        *(_QWORD *)(v29 + 8) = v31;
        qword_18000F680 = (__int64)(v28 + 2);
        goto LABEL_45;
      }
LABEL_41:
      __fastfail(3u);
    }
  }
  return v15;
}
// 18000F524: using guessed type int dword_18000F524;
// 18000F680: using guessed type __int64 qword_18000F680;

//----- (00000001800097D0) ----------------------------------------------------
__int64 __fastcall sub_1800097D0(void *a1, const UNICODE_STRING *a2, unsigned __int16 *a3)
{
  HANDLE CurrentProcessId; // rax
  __int64 *v7; // rsi
  UNICODE_STRING *v8; // rbx
  __int64 v9; // rax
  __int64 v10; // r14
  __int64 v12; // [rsp+40h] [rbp-28h] BYREF
  unsigned int v13; // [rsp+88h] [rbp+20h] BYREF

  v13 = -1;
  CurrentProcessId = PsGetCurrentProcessId();
  v7 = sub_1800046B0((__int64)CurrentProcessId, 1);
  if ( v7 )
  {
    if ( a1 )
      v8 = sub_1800079B0(1, a1, a2);
    else
      v8 = (UNICODE_STRING *)a2;
    v9 = sub_180003D60(
           1,
           2u,
           12,
           *((_DWORD *)v7 + 3),
           259,
           v8->Length + (unsigned int)*a3 + 4,
           &v13,
           (PSLIST_ENTRY *)&v12);
    v10 = v9;
    if ( v9 )
    {
      *(_WORD *)v9 = v8->Length >> 1;
      sub_18000AC00((_OWORD *)(v9 + 4), (char *)v8->Buffer, v8->Length);
      *(_WORD *)(v10 + 2) = *a3 >> 1;
      sub_18000AC00((_OWORD *)(v10 + v8->Length + 4i64), *((char **)a3 + 1), *a3);
      sub_180004460(v12);
    }
    if ( v8 != a2 && v8 != &Source && v8 != &Destination )
      ExFreePoolWithTag(v8, 0);
    sub_180004620((__int64)v7);
  }
  return v13;
}

//----- (0000000180009910) ----------------------------------------------------
__int64 __fastcall sub_180009910(__int16 a1, int a2, volatile void *a3, void *a4, const UNICODE_STRING *a5)
{
  HANDLE CurrentProcessId; // rax
  __int64 *v10; // rbp
  void *v11; // rdi
  HANDLE v12; // rsi
  NTSTATUS v13; // eax
  HANDLE v14; // rcx
  UNICODE_STRING *v15; // rbx
  __int64 v16; // rax
  unsigned int v18; // [rsp+40h] [rbp-48h] BYREF
  HANDLE Handle; // [rsp+48h] [rbp-40h] BYREF
  __int64 v20; // [rsp+50h] [rbp-38h] BYREF
  UNICODE_STRING v21; // [rsp+58h] [rbp-30h] BYREF

  v18 = -1;
  CurrentProcessId = PsGetCurrentProcessId();
  v10 = sub_1800046B0((__int64)CurrentProcessId, 1);
  if ( v10 )
  {
    if ( a3 )
    {
      if ( !sub_18000A830(a3, &Handle, (volatile void **)&v21) )
      {
        v15 = &Source;
        goto LABEL_16;
      }
      v11 = 0i64;
      v12 = Handle;
      if ( Handle )
      {
        Handle = 0i64;
        if ( (int)v12 >= 0 || !ExGetPreviousMode() )
        {
          v13 = ObReferenceObjectByHandle(v12, 0, 0i64, 0, &Handle, 0i64);
          v14 = Handle;
          if ( v13 < 0 )
            v14 = 0i64;
          v11 = v14;
          Handle = v14;
        }
      }
      v15 = sub_1800079B0(1, v11, &v21);
      if ( v12 && v11 )
        ObfDereferenceObject(v11);
    }
    else
    {
      v15 = sub_1800079B0(1, a4, a5);
    }
    if ( !v15 )
    {
LABEL_21:
      sub_180004620((__int64)v10);
      return v18;
    }
LABEL_16:
    v16 = sub_180003D60(1, 2u, a1, *((_DWORD *)v10 + 3), 259, (unsigned int)v15->Length + 8, &v18, (PSLIST_ENTRY *)&v20);
    if ( v16 )
    {
      *(_DWORD *)(v16 + 4) = a2;
      *(_WORD *)v16 = v15->Length >> 1;
      sub_18000AC00((_OWORD *)(v16 + 8), (char *)v15->Buffer, v15->Length);
      sub_180004460(v20);
    }
    if ( v15 != &Source && v15 != &Destination )
      ExFreePoolWithTag(v15, 0);
    goto LABEL_21;
  }
  return v18;
}

//----- (0000000180009AE0) ----------------------------------------------------
__int64 __fastcall sub_180009AE0(HANDLE Handle, void *a2, int a3, int a4)
{
  __int64 v4; // rdi
  HANDLE CurrentProcessId; // rax
  __int64 *v10; // r14
  UNICODE_STRING *v11; // rbx
  __int64 *v12; // rax
  PVOID v13; // rsi
  NTSTATUS v14; // eax
  char v15; // si
  __int64 v16; // rax
  unsigned int v18; // [rsp+40h] [rbp-38h] BYREF
  PVOID Object; // [rsp+48h] [rbp-30h] BYREF
  __int64 v20; // [rsp+50h] [rbp-28h] BYREF

  v4 = 0i64;
  v18 = -1;
  v20 = 0i64;
  if ( (dword_18000F524 & 0xC) != 0 )
  {
    CurrentProcessId = PsGetCurrentProcessId();
    v10 = sub_1800046B0((__int64)CurrentProcessId, 1);
    if ( !v10 )
      return v18;
    v11 = 0i64;
    if ( a2 )
    {
      KeWaitForSingleObject(&g_KeMutek4, Executive, 0, 0, 0i64);
      v12 = (__int64 *)qword_18000F680;
      if ( (__int64 *)qword_18000F680 != &qword_18000F680 )
      {
        while ( (void *)*(v12 - 2) != a2 )
        {
          v12 = (__int64 *)*v12;
          if ( v12 == &qword_18000F680 )
            goto LABEL_9;
        }
        v11 = (UNICODE_STRING *)*(v12 - 1);
      }
LABEL_9:
      KeReleaseMutex(&g_KeMutek4, 0);
    }
    if ( v11 )
    {
      v15 = 1;
    }
    else
    {
      if ( Handle )
      {
        Object = 0i64;
        if ( (int)Handle < 0 && ExGetPreviousMode() )
        {
          v13 = 0i64;
        }
        else
        {
          v14 = ObReferenceObjectByHandle(Handle, 0, 0i64, 0, &Object, 0i64);
          v13 = Object;
          if ( v14 < 0 )
            v13 = 0i64;
          Object = v13;
        }
        v11 = sub_1800079B0(0, v13, 0i64);
        if ( v13 )
          ObfDereferenceObject(v13);
      }
      else
      {
        v11 = sub_1800079B0(0, a2, 0i64);
      }
      v15 = 0;
      if ( !v11 )
        goto LABEL_30;
    }
    v16 = sub_180003D60(1, 2u, 3, *((_DWORD *)v10 + 3), 259, (unsigned int)v11->Length + 12, &v18, (PSLIST_ENTRY *)&v20);
    v4 = v16;
    if ( v16 )
    {
      *(_WORD *)v16 = v11->Length >> 1;
      sub_18000AC00((_OWORD *)(v16 + 12), (char *)v11->Buffer, v11->Length);
    }
    if ( !v15 && v11 != &Source && v11 != &Destination )
      ExFreePoolWithTag(v11, 0);
LABEL_30:
    sub_180004620((__int64)v10);
    if ( v4 )
    {
      *(_DWORD *)(v4 + 8) = a3;
      *(_DWORD *)(v4 + 4) = a4;
      sub_180004460(v20);
    }
    return v18;
  }
  return 0xFFFFFFFFi64;
}
// 18000F524: using guessed type int dword_18000F524;
// 18000F680: using guessed type __int64 qword_18000F680;

//----- (0000000180009D10) ----------------------------------------------------
__int64 __fastcall sub_180009D10(HANDLE Handle, void *a2, const UNICODE_STRING *a3, int a4, int a5, int a6)
{
  __int64 v6; // rdi
  HANDLE CurrentProcessId; // rax
  __int64 *v12; // r14
  UNICODE_STRING *v13; // rbx
  __int64 *v14; // rax
  PVOID v15; // rsi
  NTSTATUS v16; // eax
  char v17; // si
  __int64 v18; // rax
  unsigned int v20; // [rsp+40h] [rbp-38h] BYREF
  PVOID Object; // [rsp+48h] [rbp-30h] BYREF
  __int64 v22; // [rsp+50h] [rbp-28h] BYREF

  v6 = 0i64;
  v20 = -1;
  v22 = 0i64;
  if ( (dword_18000F524 & 0xC) != 0 )
  {
    CurrentProcessId = PsGetCurrentProcessId();
    v12 = sub_1800046B0((__int64)CurrentProcessId, 1);
    if ( !v12 )
      return v20;
    v13 = 0i64;
    if ( a2 )
    {
      KeWaitForSingleObject(&g_KeMutek4, Executive, 0, 0, 0i64);
      v14 = (__int64 *)qword_18000F680;
      if ( (__int64 *)qword_18000F680 != &qword_18000F680 )
      {
        while ( (void *)*(v14 - 2) != a2 )
        {
          v14 = (__int64 *)*v14;
          if ( v14 == &qword_18000F680 )
            goto LABEL_9;
        }
        v13 = (UNICODE_STRING *)*(v14 - 1);
      }
LABEL_9:
      KeReleaseMutex(&g_KeMutek4, 0);
    }
    if ( v13 )
    {
      v17 = 1;
    }
    else
    {
      if ( Handle )
      {
        Object = 0i64;
        if ( (int)Handle < 0 && ExGetPreviousMode() )
        {
          v15 = 0i64;
        }
        else
        {
          v16 = ObReferenceObjectByHandle(Handle, 0, 0i64, 0, &Object, 0i64);
          v15 = Object;
          if ( v16 < 0 )
            v15 = 0i64;
          Object = v15;
        }
        v13 = sub_1800079B0(0, v15, a3);
        if ( v15 )
          ObfDereferenceObject(v15);
      }
      else
      {
        v13 = sub_1800079B0(0, a2, a3);
      }
      v17 = 0;
      if ( !v13 )
        goto LABEL_30;
    }
    v18 = sub_180003D60(1, 2u, 5, *((_DWORD *)v12 + 3), 259, (unsigned int)v13->Length + 12, &v20, (PSLIST_ENTRY *)&v22);
    v6 = v18;
    if ( v18 )
    {
      *(_WORD *)v18 = v13->Length >> 1;
      sub_18000AC00((_OWORD *)(v18 + 12), (char *)v13->Buffer, v13->Length);
    }
    if ( !v17 && v13 != &Source && v13 != &Destination )
      ExFreePoolWithTag(v13, 0);
LABEL_30:
    sub_180004620((__int64)v12);
    if ( v6 )
    {
      *(_DWORD *)(v6 + 4) = a6;
      *(_DWORD *)(v6 + 8) = a4;
      sub_180004460(v22);
    }
    return v20;
  }
  return 0xFFFFFFFFi64;
}
// 18000F524: using guessed type int dword_18000F524;
// 18000F680: using guessed type __int64 qword_18000F680;

//----- (0000000180009F40) ----------------------------------------------------
__int64 __fastcall sub_180009F40(HANDLE Handle, void *a2, unsigned __int16 *a3)
{
  HANDLE CurrentProcessId; // rax
  __int64 *v7; // r12
  unsigned __int16 *v8; // rdi
  int v9; // r13d
  HANDLE v10; // rax
  __int64 *v11; // r15
  UNICODE_STRING *v12; // rbx
  __int64 *v13; // rax
  PVOID v14; // rsi
  NTSTATUS v15; // eax
  char v16; // si
  __int64 v17; // rax
  PVOID Object; // [rsp+40h] [rbp-38h] BYREF
  __int64 v20; // [rsp+48h] [rbp-30h] BYREF
  unsigned int v21; // [rsp+98h] [rbp+20h] BYREF

  v21 = -1;
  CurrentProcessId = PsGetCurrentProcessId();
  v7 = sub_1800046B0((__int64)CurrentProcessId, 1);
  if ( v7 )
  {
    v8 = 0i64;
    v9 = *a3;
    v20 = 0i64;
    if ( (dword_18000F524 & 0xC) == 0 || (v10 = PsGetCurrentProcessId(), (v11 = sub_1800046B0((__int64)v10, 1)) == 0i64) )
    {
LABEL_33:
      sub_180004620((__int64)v7);
      return v21;
    }
    v12 = 0i64;
    if ( a2 )
    {
      KeWaitForSingleObject(&g_KeMutek4, Executive, 0, 0, 0i64);
      v13 = (__int64 *)qword_18000F680;
      if ( (__int64 *)qword_18000F680 != &qword_18000F680 )
      {
        while ( (void *)*(v13 - 2) != a2 )
        {
          v13 = (__int64 *)*v13;
          if ( v13 == &qword_18000F680 )
            goto LABEL_10;
        }
        v12 = (UNICODE_STRING *)*(v13 - 1);
      }
LABEL_10:
      KeReleaseMutex(&g_KeMutek4, 0);
    }
    if ( v12 )
    {
      v16 = 1;
    }
    else
    {
      if ( Handle )
      {
        Object = 0i64;
        if ( (int)Handle < 0 && ExGetPreviousMode() )
        {
          v14 = 0i64;
        }
        else
        {
          v15 = ObReferenceObjectByHandle(Handle, 0, 0i64, 0, &Object, 0i64);
          v14 = Object;
          if ( v15 < 0 )
            v14 = 0i64;
          Object = v14;
        }
        v12 = sub_1800079B0(0, v14, 0i64);
        if ( v14 )
          ObfDereferenceObject(v14);
      }
      else
      {
        v12 = sub_1800079B0(0, a2, 0i64);
      }
      v16 = 0;
      if ( !v12 )
        goto LABEL_31;
    }
    v17 = sub_180003D60(
            1,
            2u,
            14,
            *((_DWORD *)v11 + 3),
            259,
            v9 + (unsigned int)v12->Length + 4,
            &v21,
            (PSLIST_ENTRY *)&v20);
    v8 = (unsigned __int16 *)v17;
    if ( v17 )
    {
      *(_WORD *)v17 = v12->Length >> 1;
      sub_18000AC00((_OWORD *)(v17 + 4), (char *)v12->Buffer, v12->Length);
    }
    if ( !v16 && v12 != &Source && v12 != &Destination )
      ExFreePoolWithTag(v12, 0);
LABEL_31:
    sub_180004620((__int64)v11);
    if ( v8 )
    {
      v8[1] = *a3 >> 1;
      sub_18000AC00(&v8[*v8 + 2], *((char **)a3 + 1), *a3);
      sub_180004460(v20);
    }
    goto LABEL_33;
  }
  return v21;
}
// 18000F524: using guessed type int dword_18000F524;
// 18000F680: using guessed type __int64 qword_18000F680;

//----- (000000018000A1C0) ----------------------------------------------------
__int64 __fastcall sub_18000A1C0(HANDLE Handle, void *a2, int a3, char *a4, int a5)
{
  unsigned __int16 *v5; // rbx
  char *v8; // rbp
  unsigned __int16 v10; // ax
  unsigned __int16 v11; // r14
  unsigned __int16 v12; // ax
  HANDLE CurrentProcessId; // rax
  __int64 *v14; // r13
  UNICODE_STRING *v15; // rdi
  __int64 *v16; // rax
  PVOID v17; // rsi
  NTSTATUS v18; // eax
  char v19; // si
  __int64 v20; // rax
  char *v21; // rcx
  PVOID Object; // [rsp+40h] [rbp-38h] BYREF
  __int64 v24; // [rsp+48h] [rbp-30h] BYREF
  unsigned int v25; // [rsp+90h] [rbp+18h] BYREF

  v5 = 0i64;
  v8 = 0i64;
  v25 = -1;
  Object = 0i64;
  v10 = 8;
  if ( !a3 )
    goto LABEL_5;
  if ( a3 == 1 )
  {
    v10 = 4;
LABEL_5:
    v12 = sub_180008AB0(a4, v10, &Object);
    v8 = (char *)Object;
    v11 = v12;
    goto LABEL_6;
  }
  v11 = 0;
LABEL_6:
  v24 = 0i64;
  if ( (dword_18000F524 & 0xC) == 0 )
    goto LABEL_41;
  CurrentProcessId = PsGetCurrentProcessId();
  v14 = sub_1800046B0((__int64)CurrentProcessId, 1);
  if ( !v14 )
    goto LABEL_41;
  v15 = 0i64;
  if ( a2 )
  {
    KeWaitForSingleObject(&g_KeMutek4, Executive, 0, 0, 0i64);
    v16 = (__int64 *)qword_18000F680;
    if ( (__int64 *)qword_18000F680 != &qword_18000F680 )
    {
      while ( (void *)*(v16 - 2) != a2 )
      {
        v16 = (__int64 *)*v16;
        if ( v16 == &qword_18000F680 )
          goto LABEL_14;
      }
      v15 = (UNICODE_STRING *)*(v16 - 1);
    }
LABEL_14:
    KeReleaseMutex(&g_KeMutek4, 0);
  }
  if ( v15 )
  {
    v19 = 1;
  }
  else
  {
    if ( Handle )
    {
      Object = 0i64;
      if ( (int)Handle < 0 && ExGetPreviousMode() )
      {
        v17 = 0i64;
      }
      else
      {
        v18 = ObReferenceObjectByHandle(Handle, 0, 0i64, 0, &Object, 0i64);
        v17 = Object;
        if ( v18 < 0 )
          v17 = 0i64;
        Object = v17;
      }
      v15 = sub_1800079B0(0, v17, 0i64);
      if ( v17 )
        ObfDereferenceObject(v17);
    }
    else
    {
      v15 = sub_1800079B0(0, a2, 0i64);
    }
    v19 = 0;
    if ( !v15 )
      goto LABEL_35;
  }
  v20 = sub_180003D60(
          1,
          2u,
          8,
          *((_DWORD *)v14 + 3),
          259,
          v15->Length + (unsigned int)v11 + 16,
          &v25,
          (PSLIST_ENTRY *)&v24);
  v5 = (unsigned __int16 *)v20;
  if ( v20 )
  {
    *(_WORD *)v20 = v15->Length >> 1;
    sub_18000AC00((_OWORD *)(v20 + 16), (char *)v15->Buffer, v15->Length);
  }
  if ( !v19 && v15 != &Source && v15 != &Destination )
    ExFreePoolWithTag(v15, 0);
LABEL_35:
  sub_180004620((__int64)v14);
  if ( v5 )
  {
    *((_DWORD *)v5 + 2) = a5;
    *((_DWORD *)v5 + 1) = a3;
    v5[6] = v11;
    if ( v11 )
    {
      v21 = (char *)&v5[*v5 + 8];
      if ( v8 )
      {
        sub_18000AC00(v21, v8, v11);
        v5[6] = v11;
      }
      else
      {
        sub_18000AEC0(v21, 0, v11);
      }
    }
    sub_180004460(v24);
  }
LABEL_41:
  if ( v8 )
    ExFreePoolWithTag(v8, 0);
  return v25;
}
// 18000F524: using guessed type int dword_18000F524;
// 18000F680: using guessed type __int64 qword_18000F680;

//----- (000000018000A480) ----------------------------------------------------
__int64 __fastcall sub_18000A480(
        HANDLE Handle,
        void *a2,
        const UNICODE_STRING *a3,
        __int64 a4,
        int a5,
        char *a6,
        int a7)
{
  char *v10; // rbp
  __int16 v11; // ax
  unsigned __int16 v12; // r14
  unsigned __int16 v13; // ax
  unsigned __int16 *v14; // rdi
  HANDLE CurrentProcessId; // rax
  __int64 *v16; // r13
  UNICODE_STRING *v17; // rbx
  __int64 *v18; // rax
  PVOID v19; // rsi
  NTSTATUS v20; // eax
  char v21; // si
  __int64 v22; // rax
  char *v23; // rcx
  unsigned int v25; // [rsp+40h] [rbp-48h] BYREF
  PVOID Object; // [rsp+48h] [rbp-40h] BYREF
  __int64 v27; // [rsp+50h] [rbp-38h] BYREF

  v25 = -1;
  Object = 0i64;
  v10 = 0i64;
  v11 = sub_180008800(a5, (__int64)a6, a7);
  v12 = v11;
  if ( v11 )
  {
    v13 = sub_180008AB0(a6, v11, &Object);
    v10 = (char *)Object;
    v12 = v13;
  }
  v14 = 0i64;
  v27 = 0i64;
  if ( (dword_18000F524 & 0xC) != 0 )
  {
    CurrentProcessId = PsGetCurrentProcessId();
    v16 = sub_1800046B0((__int64)CurrentProcessId, 1);
    if ( v16 )
    {
      v17 = 0i64;
      if ( a2 )
      {
        KeWaitForSingleObject(&g_KeMutek4, Executive, 0, 0, 0i64);
        v18 = (__int64 *)qword_18000F680;
        if ( (__int64 *)qword_18000F680 != &qword_18000F680 )
        {
          while ( (void *)*(v18 - 2) != a2 )
          {
            v18 = (__int64 *)*v18;
            if ( v18 == &qword_18000F680 )
              goto LABEL_11;
          }
          v17 = (UNICODE_STRING *)*(v18 - 1);
        }
LABEL_11:
        KeReleaseMutex(&g_KeMutek4, 0);
      }
      if ( v17 )
      {
        v21 = 1;
      }
      else
      {
        if ( Handle )
        {
          Object = 0i64;
          if ( (int)Handle < 0 && ExGetPreviousMode() )
          {
            v19 = 0i64;
          }
          else
          {
            v20 = ObReferenceObjectByHandle(Handle, 0, 0i64, 0, &Object, 0i64);
            v19 = Object;
            if ( v20 < 0 )
              v19 = 0i64;
            Object = v19;
          }
          v17 = sub_1800079B0(0, v19, a3);
          if ( v19 )
            ObfDereferenceObject(v19);
        }
        else
        {
          v17 = sub_1800079B0(0, a2, a3);
        }
        v21 = 0;
        if ( !v17 )
          goto LABEL_32;
      }
      v22 = sub_180003D60(
              1,
              2u,
              4,
              *((_DWORD *)v16 + 3),
              259,
              v17->Length + (unsigned int)v12 + 16,
              &v25,
              (PSLIST_ENTRY *)&v27);
      v14 = (unsigned __int16 *)v22;
      if ( v22 )
      {
        *(_WORD *)v22 = v17->Length >> 1;
        sub_18000AC00((_OWORD *)(v22 + 16), (char *)v17->Buffer, v17->Length);
      }
      if ( !v21 && v17 != &Source && v17 != &Destination )
        ExFreePoolWithTag(v17, 0);
LABEL_32:
      sub_180004620((__int64)v16);
      if ( v14 )
      {
        *((_DWORD *)v14 + 1) = a5;
        v14[6] = 0;
        *((_DWORD *)v14 + 2) = a7;
        if ( v12 )
        {
          v23 = (char *)&v14[*v14 + 8];
          if ( v10 )
          {
            sub_18000AC00(v23, v10, v12);
            v14[6] = v12;
          }
          else
          {
            sub_18000AEC0(v23, 0, v12);
          }
        }
        sub_180004460(v27);
      }
    }
  }
  if ( v10 )
    ExFreePoolWithTag(v10, 0);
  return v25;
}
// 18000F524: using guessed type int dword_18000F524;
// 18000F680: using guessed type __int64 qword_18000F680;

//----- (000000018000A740) ----------------------------------------------------
__int64 __fastcall sub_18000A740(UNICODE_STRING *P, void *a2)
{
  HANDLE CurrentProcessId; // rax
  __int64 *v5; // rdi
  __int64 v6; // rax
  unsigned int v8; // [rsp+60h] [rbp+18h] BYREF
  __int64 v9; // [rsp+68h] [rbp+20h] BYREF

  v8 = -1;
  CurrentProcessId = PsGetCurrentProcessId();
  v5 = sub_1800046B0((__int64)CurrentProcessId, 1);
  if ( v5 )
  {
    if ( !P )
      P = sub_1800079B0(1, a2, 0i64);
    v6 = sub_180003D60(1, 2u, 13, *((_DWORD *)v5 + 3), 259, (unsigned int)P->Length + 2, &v8, (PSLIST_ENTRY *)&v9);
    if ( v6 )
    {
      *(_WORD *)v6 = P->Length >> 1;
      sub_18000AC00((_OWORD *)(v6 + 2), (char *)P->Buffer, P->Length);
      sub_180004460(v9);
    }
    if ( P != &Source && P != &Destination )
      ExFreePoolWithTag(P, 0);
    sub_180004620((__int64)v5);
  }
  return v8;
}

//----- (000000018000A830) ----------------------------------------------------
char __fastcall sub_18000A830(volatile void *Address, _QWORD *a2, volatile void **a3)
{
  if ( ExGetPreviousMode() == 1 )
  {
    ProbeForRead(Address, 0x30ui64, 1u);
    sub_18000A8B0(*((_OWORD **)Address + 2), a3);
  }
  else
  {
    *(_OWORD *)a3 = *(_OWORD *)*((_QWORD *)Address + 2);
  }
  *a2 = *((_QWORD *)Address + 1);
  return 1;
}

//----- (000000018000A8B0) ----------------------------------------------------
char __fastcall sub_18000A8B0(_OWORD *Address, volatile void **a2)
{
  if ( ExGetPreviousMode() == 1 )
  {
    ProbeForRead(Address, 0x10ui64, 1u);
    *(_OWORD *)a2 = *Address;
    ProbeForRead(a2[1], *(unsigned __int16 *)a2, 1u);
  }
  else
  {
    *(_OWORD *)a2 = *Address;
  }
  return 1;
}

//----- (000000018000A920) ----------------------------------------------------
__int64 __fastcall sub_18000A920(__int64 a1, __int64 a2)
{
  __int16 v2; // r8
  unsigned __int64 v3; // rax
  __int64 result; // rax
  __int16 v5; // ax

  v2 = 0;
  if ( a2 )
  {
    v3 = -1i64;
    do
      ++v3;
    while ( *(_WORD *)(a2 + 2 * v3) );
    if ( v3 > 0x7FFE )
      return 3221225734i64;
    v5 = 2 * v3;
    v2 = v5 + 2;
  }
  else
  {
    a2 = 0i64;
    v5 = 0;
  }
  *(_WORD *)a1 = v5;
  result = 0i64;
  *(_WORD *)(a1 + 2) = v2;
  *(_QWORD *)(a1 + 8) = a2;
  return result;
}

//----- (000000018000A970) ----------------------------------------------------
__int64 sub_18000A970()
{
  int v5; // r8d
  char v7; // r9
  int v12; // r10d

  _RAX = 0i64;
  __asm { cpuid }
  v5 = _RAX;
  _RAX = 1i64;
  v7 = 0;
  __asm { cpuid }
  v12 = _RCX;
  _RAX = 7i64;
  if ( v5 >= 7 )
  {
    v7 = 0;
    __asm { cpuid }
    LOBYTE(_RAX) = 2;
    if ( (_RBX & 0x200) != 0 )
      v7 = 2;
  }
  if ( (v12 & 0x100000) != 0 && (v12 & 0x8000000) != 0 && (v12 & 0x10000000) != 0 )
  {
    __asm { xgetbv }
    if ( (_RAX & 6) == 6 )
      v7 |= 4u;
  }
  byte_18000F080 = v7 | 1;
  return 0i64;
}
// 18000F080: using guessed type char byte_18000F080;

//----- (000000018000AA38) ----------------------------------------------------
__int64 __fastcall sub_18000AA38(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  int v3; // edx

  result = *(_QWORD *)(a2 + 8);
  v3 = *(unsigned __int8 *)(*(unsigned int *)(*(_QWORD *)(a2 + 16) + 8i64) + result + 3);
  if ( (v3 & 0xF) != 0 )
    return v3 & 0xFFFFFFF0;
  return result;
}

//----- (000000018000AAA4) ----------------------------------------------------
void __fastcall __noreturn sub_18000AAA4(ULONG_PTR BugCheckParameter1)
{
  KeBugCheckEx(0xF7u, BugCheckParameter1, _security_cookie, BugCheckParameter3, 0i64);
}

//----- (000000018000AC00) ----------------------------------------------------
__m128 *__fastcall sub_18000AC00(_OWORD *a1, char *a2, unsigned __int64 a3)
{
  __m128 *result; // rax
  __int64 v4; // r11
  __int64 v5; // rdx
  __int128 v6; // xmm1
  bool v7; // cf
  signed __int64 v8; // rdx
  char v9; // r11
  _BYTE *v10; // rcx
  char v11; // r11
  char *v12; // r11
  signed __int64 v13; // rdx
  __m128 v14; // xmm0
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // rcx
  __m128 v17; // xmm1
  unsigned __int64 v18; // r8
  unsigned __int64 v19; // r9
  __int128 v20; // xmm1
  __int128 v21; // xmm2
  __int128 v22; // xmm3
  __m128 v23; // xmm4
  unsigned __int64 j; // r9
  unsigned __int64 v25; // r8
  unsigned __int64 v26; // r9
  __m128 v27; // xmm1
  __m128 v28; // xmm2
  __m128 v29; // xmm3
  __m128 v30; // xmm4
  char *v31; // rcx
  __int128 v32; // xmm0
  unsigned __int64 v33; // rcx
  unsigned __int64 v34; // r8
  _OWORD *v35; // r11
  __int128 v36; // xmm1
  unsigned __int64 v37; // r9
  __int128 v38; // xmm1
  __int128 v39; // xmm2
  __int128 v40; // xmm3
  __int128 v41; // xmm4
  unsigned __int64 i; // r9
  unsigned __int64 v43; // r8

  result = (__m128 *)a1;
  if ( a3 < 8 )
  {
    if ( a3 )
    {
      v7 = a2 < (char *)a1;
      v8 = a2 - (char *)a1;
      if ( v7 )
      {
        v10 = (char *)a1 + a3;
        do
        {
          v11 = v10[v8 - 1];
          --v10;
          --a3;
          *v10 = v11;
        }
        while ( a3 );
      }
      else
      {
        do
        {
          v9 = *((_BYTE *)a1 + v8);
          a1 = (_OWORD *)((char *)a1 + 1);
          --a3;
          *((_BYTE *)a1 - 1) = v9;
        }
        while ( a3 );
      }
    }
  }
  else if ( a3 > 0x10 )
  {
    if ( a3 > 0x20 )
    {
      v12 = &a2[a3];
      v7 = a2 < (char *)a1;
      v13 = a2 - (char *)a1;
      if ( v7 && v12 > (char *)a1 )
      {
        v31 = (char *)a1 + a3;
        v32 = *(_OWORD *)&v31[v13 - 16];
        v33 = (unsigned __int64)(v31 - 16);
        v34 = a3 - 16;
        if ( (v33 & 0xF) != 0 )
        {
          v35 = (_OWORD *)v33;
          v33 &= 0xFFFFFFFFFFFFFFF0ui64;
          v36 = *(_OWORD *)(v33 + v13);
          *v35 = v32;
          v32 = v36;
          v34 = v33 - (_QWORD)result;
        }
        v37 = v34 >> 6;
        if ( v34 >> 6 )
        {
          v34 &= 0x3Fu;
          do
          {
            v38 = *(_OWORD *)(v33 + v13 - 16);
            v39 = *(_OWORD *)(v33 + v13 - 32);
            v40 = *(_OWORD *)(v33 + v13 - 48);
            v41 = *(_OWORD *)(v33 + v13 - 64);
            *(_OWORD *)v33 = v32;
            v33 -= 64i64;
            --v37;
            *(_OWORD *)(v33 + 48) = v38;
            *(_OWORD *)(v33 + 32) = v39;
            *(_OWORD *)(v33 + 16) = v40;
            v32 = v41;
          }
          while ( v37 );
        }
        for ( i = v34 >> 4; i; --i )
        {
          *(_OWORD *)v33 = v32;
          v32 = *(_OWORD *)(v33 + v13 - 16);
          v33 -= 16i64;
        }
        v43 = v34 & 0xF;
        if ( v43 )
          *(_OWORD *)(v33 - v43) = *(_OWORD *)(v33 - v43 + v13);
        *(_OWORD *)v33 = v32;
      }
      else
      {
        v14 = *(__m128 *)((char *)a1 + v13);
        v15 = (unsigned __int64)(a1 + 1);
        if ( (v15 & 0xF) != 0 )
        {
          v16 = v15 & 0xFFFFFFFFFFFFFFF0ui64;
          v17 = *(__m128 *)(v16 + v13);
          *result = v14;
          v14 = v17;
          v15 = v16 + 16;
        }
        v18 = (unsigned __int64)result + a3 - v15;
        v19 = v18 >> 6;
        if ( v18 >> 6 )
        {
          if ( v19 > 0x1000 )
          {
            v26 = v18 >> 6;
            v18 &= 0x3Fu;
            _mm_prefetch((const char *)(v15 + v13 + 64), 0);
            do
            {
              v27 = *(__m128 *)(v15 + v13);
              v28 = *(__m128 *)(v15 + v13 + 16);
              v29 = *(__m128 *)(v15 + v13 + 32);
              v30 = *(__m128 *)(v15 + v13 + 48);
              _mm_stream_ps((float *)(v15 - 16), v14);
              v15 += 64i64;
              _mm_prefetch((const char *)(v15 + v13 + 64), 0);
              --v26;
              _mm_stream_ps((float *)(v15 - 64), v27);
              _mm_stream_ps((float *)(v15 - 48), v28);
              _mm_stream_ps((float *)(v15 - 32), v29);
              v14 = v30;
            }
            while ( v26 );
            _mm_sfence();
          }
          else
          {
            v18 &= 0x3Fu;
            do
            {
              v20 = *(_OWORD *)(v15 + v13);
              v21 = *(_OWORD *)(v15 + v13 + 16);
              v22 = *(_OWORD *)(v15 + v13 + 32);
              v23 = *(__m128 *)(v15 + v13 + 48);
              *(__m128 *)(v15 - 16) = v14;
              v15 += 64i64;
              --v19;
              *(_OWORD *)(v15 - 64) = v20;
              *(_OWORD *)(v15 - 48) = v21;
              *(_OWORD *)(v15 - 32) = v22;
              v14 = v23;
            }
            while ( v19 );
          }
        }
        for ( j = v18 >> 4; j; --j )
        {
          *(__m128 *)(v15 - 16) = v14;
          v14 = *(__m128 *)(v15 + v13);
          v15 += 16i64;
        }
        v25 = v18 & 0xF;
        if ( v25 )
          *(_OWORD *)(v15 + v25 - 16) = *(_OWORD *)(v15 + v25 - 16 + v13);
        *(__m128 *)(v15 - 16) = v14;
      }
    }
    else
    {
      v6 = *(_OWORD *)&a2[a3 - 16];
      *a1 = *(_OWORD *)a2;
      *(_OWORD *)((char *)a1 + a3 - 16) = v6;
    }
  }
  else
  {
    v4 = *(_QWORD *)a2;
    v5 = *(_QWORD *)&a2[a3 - 8];
    *(_QWORD *)a1 = v4;
    *(_QWORD *)((char *)a1 + a3 - 8) = v5;
  }
  return result;
}

//----- (000000018000AEC0) ----------------------------------------------------
__int64 __fastcall sub_18000AEC0(char *a1, unsigned __int8 a2, unsigned __int64 a3)
{
  __int64 result; // rax
  __int64 v4; // rdx
  __m128 v5; // xmm0
  char *v6; // r8
  __m128 *v7; // rdx
  _OWORD *v8; // r9
  unsigned __int64 v9; // r8
  __m128 *v10; // r9
  unsigned __int64 v11; // r8
  char *v12; // r9
  unsigned __int64 v13; // r8

  result = (__int64)a1;
  v4 = 0x101010101010101i64 * a2;
  v5 = _mm_movelh_ps((__m128)(unsigned __int64)v4, (__m128)(unsigned __int64)v4);
  if ( a3 >= 0x40 )
  {
    if ( (byte_18000F080 & 2) != 0 && a3 >= 0x320 )
      return sub_18000B000(a1, v4, a3);
    *(__m128 *)a1 = v5;
    v6 = &a1[a3];
    a1 = (char *)((unsigned __int64)(a1 + 16) & 0xFFFFFFFFFFFFFFF0ui64);
    a3 = v6 - a1;
    if ( a3 >= 0x40 )
    {
      v7 = (__m128 *)&a1[a3 - 16];
      v8 = (_OWORD *)((unsigned __int64)&a1[a3 - 48] & 0xFFFFFFFFFFFFFFF0ui64);
      v9 = a3 >> 6;
      do
      {
        *(__m128 *)a1 = v5;
        *((__m128 *)a1 + 1) = v5;
        a1 += 64;
        --v9;
        *((__m128 *)a1 - 2) = v5;
        *((__m128 *)a1 - 1) = v5;
      }
      while ( v9 );
      *v8 = v5;
      v8[1] = v5;
      v8[2] = v5;
      *v7 = v5;
      return result;
    }
LABEL_9:
    v10 = (__m128 *)&a1[a3 - 16];
    *(__m128 *)a1 = v5;
    v11 = (a3 & 0x20) >> 1;
    *v10 = v5;
    *(__m128 *)&a1[v11] = v5;
    *(__m128 *)((char *)v10 - v11) = v5;
    return result;
  }
  if ( a3 >= 0x10 )
    goto LABEL_9;
  if ( a3 < 4 )
  {
    if ( a3 )
    {
      *a1 = v4;
      if ( a3 != 1 )
        *(_WORD *)&a1[a3 - 2] = v4;
    }
  }
  else
  {
    v12 = &a1[a3 - 4];
    *(_DWORD *)a1 = v4;
    v13 = (a3 & 8) >> 1;
    *(_DWORD *)v12 = v4;
    *(_DWORD *)&a1[v13] = v4;
    *(_DWORD *)&v12[-v13] = v4;
  }
  return result;
}
// 18000F080: using guessed type char byte_18000F080;

//----- (000000018000B000) ----------------------------------------------------
__int64 __fastcall sub_18000B000(_OWORD *a1, __int64 a2, __int64 a3)
{
  __int128 v3; // xmm0
  __int64 result; // rax

  if ( (byte_18000F080 & 1) == 0 )
    sub_18000B080();
  *a1 = v3;
  a1[1] = v3;
  a1[2] = v3;
  a1[3] = v3;
  memset(
    (void *)((unsigned __int64)(a1 + 4) & 0xFFFFFFFFFFFFFFC0ui64),
    v3,
    (unsigned __int64)a1 + a3 - ((unsigned __int64)(a1 + 4) & 0xFFFFFFFFFFFFFFC0ui64));
  return result;
}
// 18000B010: variable 'v3' is possibly undefined
// 18000B010: variable 'a1' is possibly undefined
// 18000B00D: variable 'a3' is possibly undefined
// 18000F080: using guessed type char byte_18000F080;

//----- (000000018000B080) ----------------------------------------------------
void sub_18000B080()
{
  sub_18000A970();
}

//----- (0000000180012000) ----------------------------------------------------
PVOID sub_180012000()
{
  PVOID result; // rax
  struct _UNICODE_STRING DestinationString; // [rsp+20h] [rbp-18h] BYREF

  DestinationString = 0i64;
  RtlInitUnicodeString(&DestinationString, L"IoCreateDeviceSecure");
  qword_18000F610 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _QWORD, _QWORD))MmGetSystemRoutineAddress(&DestinationString);
  if ( !qword_18000F610 )
    qword_18000F610 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _QWORD, _QWORD))sub_180012124;
  RtlInitUnicodeString(&DestinationString, L"IoValidateDeviceIoControlAccess");
  result = MmGetSystemRoutineAddress(&DestinationString);
  qword_18000F608 = (__int64)result;
  byte_18000F618 = 1;
  return result;
}
// 18000F608: using guessed type __int64 qword_18000F608;
// 18000F610: using guessed type __int64 (__fastcall *qword_18000F610)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _QWORD, _QWORD);
// 18000F618: using guessed type char byte_18000F618;

//----- (000000018001208C) ----------------------------------------------------
__int64 __fastcall CreateSercuredDeviceAndControlAccess(
        __int64 a1,
        unsigned int a2,
        __int64 a3,
        unsigned int a4,
        int a5,
        char a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  if ( !byte_18000F618 )
    sub_180012000();
  return qword_18000F610(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}
// 18000F610: invalid function type '?' has been ignored
// 18000F610: using guessed type __int64 (__fastcall *qword_18000F610)(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _QWORD, _QWORD);
// 18000F618: using guessed type char byte_18000F618;

//----- (0000000180012124) ----------------------------------------------------
__int64 __fastcall sub_180012124(
        PDRIVER_OBJECT DriverObject,
        ULONG a2,
        struct _UNICODE_STRING *a3,
        ULONG a4,
        int a5,
        char a6,
        unsigned __int16 *a7,
        __int64 a8,
        PDEVICE_OBJECT DeviceObject)
{
  PDEVICE_OBJECT v9; // rsi
  ULONG DeviceCharacteristics; // r14d
  __int64 result; // rax
  char v15; // al
  int v16; // ebx
  BOOLEAN Exclusive; // cl
  ULONG DeviceType[4]; // [rsp+40h] [rbp-30h] BYREF
  ULONG v19[2]; // [rsp+50h] [rbp-20h]
  __int128 v20; // [rsp+58h] [rbp-18h] BYREF
  __int64 v21; // [rsp+68h] [rbp-8h]
  __int64 v23; // [rsp+B0h] [rbp+40h] BYREF

  v9 = DeviceObject;
  DeviceCharacteristics = a5;
  v23 = 0i64;
  *(_QWORD *)v19 = 0i64;
  *(_QWORD *)&DeviceObject->Type = 0i64;
  v21 = 0i64;
  DeviceObject = 0i64;
  *(_OWORD *)DeviceType = 0i64;
  v20 = 0i64;
  if ( !a3 && (DeviceCharacteristics & 0x80u) == 0 )
    return 3221225485i64;
  if ( !a8 )
  {
    unknown_libname_1(DeviceType);
LABEL_8:
    v15 = DeviceType[0];
    if ( (DeviceType[0] & 2) == 0 )
    {
      v16 = sub_180012AB0(a7, 1, &v23);
      if ( v16 < 0
        || (PpRegStateLoadSecurityDescriptor(v23, DeviceType), a8)
        && (unknown_libname_1(&v20),
            PpRegStateLoadSecurityDescriptor(v23, &v20),
            v16 = sub_180012964(a8, (__int64)&v20),
            v16 < 0) )
      {
LABEL_23:
        sub_1800127E8((__int64)DeviceType);
        return (unsigned int)v16;
      }
      v15 = DeviceType[0];
    }
    Exclusive = a6;
    if ( (v15 & 1) != 0 )
      a4 = DeviceType[1];
    if ( (v15 & 4) != 0 )
      DeviceCharacteristics = v19[0];
    if ( (v15 & 8) != 0 )
      Exclusive = v19[1];
    v16 = IoCreateDevice(DriverObject, a2, a3, a4, DeviceCharacteristics, Exclusive, &DeviceObject);
    if ( v16 >= 0 )
    {
      v16 = sub_1800122B4(DeviceObject, (PSECURITY_DESCRIPTOR *)DeviceType);
      if ( v16 >= 0 )
        *(_QWORD *)&v9->Type = DeviceObject;
      else
        IoDeleteDevice(DeviceObject);
    }
    goto LABEL_23;
  }
  result = sub_180012828(a8, (__int64)DriverObject, (__int64)DeviceType);
  if ( (int)result >= 0 )
    goto LABEL_8;
  return result;
}
// 18001280C: using guessed type __int64 __fastcall unknown_libname_1(_QWORD);
// 18001281C: using guessed type __int64 __fastcall PpRegStateLoadSecurityDescriptor(_QWORD, _QWORD);

//----- (00000001800122B4) ----------------------------------------------------
NTSTATUS __fastcall sub_1800122B4(PVOID Object, PSECURITY_DESCRIPTOR *a2)
{
  int v4; // eax
  NTSTATUS result; // eax
  NTSTATUS v6; // ebx
  HANDLE Handle; // [rsp+40h] [rbp-10h] BYREF
  unsigned __int8 v8; // [rsp+78h] [rbp+28h] BYREF
  SECURITY_INFORMATION SecurityInformation; // [rsp+80h] [rbp+30h] BYREF
  ACCESS_MASK DesiredAccess; // [rsp+88h] [rbp+38h] BYREF

  SecurityInformation = 0;
  DesiredAccess = 0;
  Handle = 0i64;
  v4 = *(_DWORD *)a2;
  v8 = 0;
  if ( (v4 & 2) == 0 )
    return 0;
  result = sub_18001239C(a2[1], &v8, &SecurityInformation);
  if ( result >= 0 )
  {
    sub_180012374(SecurityInformation, (int *)&DesiredAccess);
    result = ObOpenObjectByPointer(Object, 0x200u, 0i64, DesiredAccess, IoDeviceObjectType, 0, &Handle);
    if ( result >= 0 )
    {
      v6 = ZwSetSecurityObject(Handle, SecurityInformation, a2[1]);
      ZwClose(Handle);
      return v6;
    }
  }
  return result;
}

//----- (0000000180012374) ----------------------------------------------------
int __fastcall sub_180012374(char a1, int *a2)
{
  int result; // eax

  result = 0;
  *a2 = 0;
  if ( (a1 & 3) != 0 )
  {
    result = 0x80000;
    *a2 = 0x80000;
  }
  if ( (a1 & 4) != 0 )
  {
    result |= 0x40000u;
    *a2 = result;
  }
  if ( (a1 & 8) != 0 )
  {
    result |= 0x1000000u;
    *a2 = result;
  }
  return result;
}

//----- (000000018001239C) ----------------------------------------------------
NTSTATUS __fastcall sub_18001239C(PSECURITY_DESCRIPTOR SecurityDescriptor, unsigned __int8 *a2, _DWORD *a3)
{
  NTSTATUS result; // eax
  int v7; // ebx
  PSID Owner; // [rsp+20h] [rbp-10h] BYREF
  PACL Sacl; // [rsp+28h] [rbp-8h] BYREF
  unsigned __int8 OwnerDefaulted; // [rsp+58h] [rbp+28h] BYREF
  unsigned __int8 SaclPresent; // [rsp+68h] [rbp+38h] BYREF

  Owner = 0i64;
  Sacl = 0i64;
  *a2 = 0;
  *a3 = 0;
  OwnerDefaulted = 0;
  SaclPresent = 0;
  result = RtlGetOwnerSecurityDescriptor(SecurityDescriptor, &Owner, &OwnerDefaulted);
  if ( result >= 0 )
  {
    v7 = Owner != 0i64;
    result = RtlGetGroupSecurityDescriptor(SecurityDescriptor, &Owner, &OwnerDefaulted);
    if ( result >= 0 )
    {
      if ( Owner )
        v7 |= 2u;
      result = RtlGetSaclSecurityDescriptor(SecurityDescriptor, &SaclPresent, &Sacl, &OwnerDefaulted);
      if ( result >= 0 )
      {
        if ( SaclPresent )
          v7 |= 8u;
        result = RtlGetDaclSecurityDescriptor(SecurityDescriptor, &SaclPresent, &Sacl, &OwnerDefaulted);
        if ( result >= 0 )
        {
          if ( SaclPresent )
            v7 |= 4u;
          *a2 = OwnerDefaulted;
          result = 0;
          *a3 = v7;
        }
      }
    }
  }
  return result;
}

//----- (0000000180012620) ----------------------------------------------------
__int64 __fastcall sub_180012620(void *a1, __int64 a2)
{
  _DWORD *v2; // r12
  _DWORD *v3; // r15
  _DWORD *v4; // r14
  int v7; // ebx
  __int64 v8; // r9
  PVOID v9; // rax
  NTSTATUS v10; // eax
  NTSTATUS v11; // eax
  NTSTATUS v12; // eax
  void *v13; // rcx
  PVOID P; // [rsp+30h] [rbp-10h] BYREF
  unsigned __int8 v16; // [rsp+88h] [rbp+48h] BYREF
  int v17; // [rsp+90h] [rbp+50h] BYREF
  PVOID SecurityDescriptor; // [rsp+98h] [rbp+58h] BYREF

  v2 = (_DWORD *)(a2 + 4);
  v3 = (_DWORD *)(a2 + 16);
  *(_DWORD *)a2 = 0;
  v4 = (_DWORD *)(a2 + 20);
  *(_QWORD *)(a2 + 8) = 0i64;
  SecurityDescriptor = 0i64;
  v17 = 0;
  v16 = 0;
  P = 0i64;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  v7 = sub_180013A80(a1, (__int64)L"Security", 3, 0, (char **)&P);
  if ( v7 < 0 )
  {
    if ( v7 == -1073741772 )
      v7 = 0;
  }
  else
  {
    LOBYTE(v8) = 1;
    v7 = SeCaptureSecurityDescriptor((char *)P + *((unsigned int *)P + 2), 0i64, 1i64, v8, &SecurityDescriptor);
  }
  if ( P )
    ExFreePoolWithTag(P, 0);
  if ( v7 < 0 )
    goto LABEL_23;
  if ( SecurityDescriptor )
  {
    v7 = sub_18001239C(SecurityDescriptor, &v16, &v17);
    if ( v7 < 0 )
      goto LABEL_23;
    if ( v16 )
    {
      ExFreePoolWithTag(SecurityDescriptor, 0);
    }
    else
    {
      v9 = SecurityDescriptor;
      *(_DWORD *)a2 |= 2u;
      *(_QWORD *)(a2 + 8) = v9;
    }
  }
  v10 = sub_180013A2C(a1, (__int64)L"DeviceType", 0, v2);
  v7 = v10;
  if ( v10 < 0 )
  {
    if ( v10 != -1073741772 )
      goto LABEL_23;
  }
  else
  {
    *(_DWORD *)a2 |= 1u;
  }
  v11 = sub_180013A2C(a1, (__int64)L"DeviceCharacteristics", 0, v3);
  v7 = v11;
  if ( v11 < 0 )
  {
    if ( v11 != -1073741772 )
      goto LABEL_23;
  }
  else
  {
    *(_DWORD *)a2 |= 4u;
  }
  v12 = sub_180013A2C(a1, (__int64)L"Exclusive", 0, v4);
  v7 = v12;
  if ( v12 >= 0 )
  {
    *(_DWORD *)a2 |= 8u;
    return (unsigned int)v7;
  }
  if ( v12 == -1073741772 )
    return 0;
LABEL_23:
  v13 = *(void **)(a2 + 8);
  if ( v13 )
    ExFreePoolWithTag(v13, 0);
  *(_DWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0i64;
  *v2 = 0;
  *v3 = 0;
  *v4 = 0;
  return (unsigned int)v7;
}
// 1800126AB: variable 'v8' is possibly undefined
// 18000C358: using guessed type __int64 __fastcall SeCaptureSecurityDescriptor(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18000CF98: using guessed type wchar_t aSecurity[9];
// 18000CFB0: using guessed type wchar_t aDevicetype[11];
// 18000CFC8: using guessed type wchar_t aDevicecharacte[22];
// 18000CFF8: using guessed type wchar_t aExclusive[10];

//----- (00000001800127E8) ----------------------------------------------------
void __fastcall sub_1800127E8(__int64 a1)
{
  if ( (*(_DWORD *)a1 & 2) != 0 )
    ExFreePoolWithTag(*(PVOID *)(a1 + 8), 0);
}

//----- (0000000180012828) ----------------------------------------------------
__int64 __fastcall sub_180012828(int a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  int v6; // ebx
  int v7; // eax
  void *v8; // rcx
  HANDLE v9; // rdi
  void *v10; // [rsp+30h] [rbp-10h] BYREF
  int v11; // [rsp+60h] [rbp+20h] BYREF
  HANDLE Handle; // [rsp+68h] [rbp+28h] BYREF

  *(_DWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0i64;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 16) = 0;
  *(_DWORD *)(a3 + 20) = 0;
  v11 = 0;
  Handle = 0i64;
  v10 = 0i64;
  result = PiRegStateOpenClassKey(a1, 983103, 1, (unsigned int)&v11, (__int64)&Handle);
  if ( (int)result >= 0 )
  {
    if ( v11 == 2 )
    {
      v6 = sub_1800136B8(Handle, (__int64)L"Properties", 0x20019u, &v10);
      ZwClose(Handle);
      if ( v6 < 0 )
      {
        if ( v6 == -1073741772 )
          return 0;
        return (unsigned int)v6;
      }
      v7 = sub_180012620(v10, a3);
      v8 = v10;
      v6 = v7;
    }
    else
    {
      v9 = Handle;
      if ( *(_QWORD *)(a2 + 48) == -24i64 )
      {
        v6 = -1073741670;
      }
      else
      {
        v6 = sub_180013B44(Handle, (__int64)L"Class", (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 24i64));
        if ( v6 >= 0 )
        {
          v11 = 49;
          v6 = sub_180013B88(v9, (__int64)L"NoDisplayClass", (__int64)&v11);
          if ( v6 >= 0 )
            v6 = sub_180013B88(v9, (__int64)L"NoUseClass", (__int64)&v11);
        }
      }
      v8 = v9;
    }
    ZwClose(v8);
    return (unsigned int)v6;
  }
  return result;
}
// 18000CF38: using guessed type wchar_t aProperties[11];
// 18000CF50: using guessed type wchar_t aClass[6];
// 18000CF60: using guessed type wchar_t aNodisplayclass[15];
// 18000CF80: using guessed type wchar_t aNouseclass[11];
// 180012490: using guessed type __int64 __fastcall PiRegStateOpenClassKey(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (0000000180012964) ----------------------------------------------------
__int64 __fastcall sub_180012964(int a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v4; // r9
  void *v5; // rbx
  int v6; // ebx
  ULONG v7; // eax
  HANDLE KeyHandle[3]; // [rsp+40h] [rbp-18h] BYREF
  PVOID P; // [rsp+70h] [rbp+18h] BYREF
  HANDLE Handle; // [rsp+78h] [rbp+20h] BYREF

  P = 0i64;
  KeyHandle[0] = 0i64;
  Handle = 0i64;
  result = PiRegStateOpenClassKey(a1, 983103, 0, 0, (__int64)&Handle);
  if ( (int)result >= 0 )
  {
    v5 = &unk_18000F088;
    if ( !dword_18000F61C )
    {
      LOBYTE(v4) = 1;
      if ( (int)SeCaptureSecurityDescriptor(&unk_18000F088, 0i64, 1i64, v4, &P) < 0 )
      {
        dword_18000F61C = 2;
      }
      else
      {
        dword_18000F61C = 1;
        ExFreePoolWithTag(P, 0);
      }
    }
    if ( dword_18000F61C != 1 )
      v5 = 0i64;
    P = v5;
    v6 = sub_1800135D0(Handle, (__int64)L"Properties", 0xF003Fu, 0, v5, 0i64, KeyHandle);
    ZwClose(Handle);
    if ( v6 >= 0 )
    {
      v7 = RtlLengthSecurityDescriptor(*(PSECURITY_DESCRIPTOR *)(a2 + 8));
      v6 = sub_180013ADC(KeyHandle[0], (__int64)L"Security", 3u, *(void **)(a2 + 8), v7);
      ZwClose(KeyHandle[0]);
    }
    return (unsigned int)v6;
  }
  return result;
}
// 1800129CA: variable 'v4' is possibly undefined
// 18000C358: using guessed type __int64 __fastcall SeCaptureSecurityDescriptor(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18000CF38: using guessed type wchar_t aProperties[11];
// 18000CF98: using guessed type wchar_t aSecurity[9];
// 18000F61C: using guessed type int dword_18000F61C;
// 180012490: using guessed type __int64 __fastcall PiRegStateOpenClassKey(_DWORD, _DWORD, _DWORD, _DWORD, __int64);
// 180012964: using guessed type HANDLE KeyHandle[3];

//----- (0000000180012AB0) ----------------------------------------------------
__int64 __fastcall sub_180012AB0(unsigned __int16 *a1, int a2, _QWORD *a3)
{
  unsigned __int64 v3; // r9
  _WORD *v7; // rcx
  char *PoolWithTag; // rax
  char *v10; // rsi
  unsigned int v11; // ebx

  v3 = *a1;
  if ( a1[1] == v3 + 2 )
  {
    v7 = (_WORD *)*((_QWORD *)a1 + 1);
    if ( !v7[v3 >> 1] )
      return sub_180013384(v7, a2, (__int64)a3);
  }
  PoolWithTag = (char *)ExAllocatePoolWithTag(PagedPool, v3 + 2, 0x73546553u);
  v10 = PoolWithTag;
  if ( PoolWithTag )
  {
    sub_18000AEC0(PoolWithTag, 0, *a1 + 2i64);
    sub_18000AC00(v10, *((char **)a1 + 1), *a1);
    *(_WORD *)&v10[2 * ((unsigned __int64)*a1 >> 1)] = 0;
    v11 = sub_180013384(v10, a2, (__int64)a3);
    ExFreePoolWithTag(v10, 0);
    return v11;
  }
  else
  {
    *a3 = 0i64;
    return 3221225626i64;
  }
}

//----- (0000000180012B90) ----------------------------------------------------
NTSTATUS __fastcall sub_180012B90(
        char **a1,
        _DWORD *a2,
        __int64 a3,
        __int64 a4,
        ACCESS_MASK AccessMask,
        int a6,
        PSID Sid)
{
  struct _ACL *v7; // rsi
  unsigned __int64 v10; // rbp
  ULONG v11; // ebx
  int v12; // r15d
  unsigned int v13; // ebx
  char *PoolWithTag; // rax
  char *v15; // rdi

  v7 = (struct _ACL *)*a1;
  v10 = (unsigned int)*a2;
  v11 = RtlLengthSid(Sid) + 8;
  v12 = v11 + v10;
  if ( v11 + (unsigned int)v10 > v7->AclSize )
  {
    v13 = v10 + a6 * v11;
    PoolWithTag = (char *)ExAllocatePoolWithTag(PagedPool, v13, 0x6C416553u);
    v15 = PoolWithTag;
    if ( !PoolWithTag )
      return -1073741670;
    sub_18000AEC0(PoolWithTag, 0, v13);
    sub_18000AC00(v15, *a1, v10);
    *((_WORD *)v15 + 1) = v13;
    ExFreePoolWithTag(v7, 0);
    *a1 = v15;
    v7 = (struct _ACL *)v15;
  }
  *a2 = v12;
  return RtlAddAccessAllowedAce(v7, 2u, AccessMask, Sid);
}

//----- (0000000180012C88) ----------------------------------------------------
__int64 __fastcall sub_180012C88(_WORD *a1, int a2, int *a3, PVOID *a4)
{
  _WORD *v6; // r8
  wchar_t *v7; // rcx
  int v8; // edi
  unsigned int v9; // ebx
  wchar_t *i; // rcx
  PVOID P; // [rsp+40h] [rbp+8h] BYREF
  wchar_t *v13; // [rsp+50h] [rbp+18h] BYREF

  *a4 = 0i64;
  *a3 = 0;
  P = 0i64;
  v13 = 0i64;
  while ( *a1 == 32 )
    ++a1;
  if ( *a1 == 68 )
  {
    v6 = a1 + 1;
    if ( a1[1] == 58 )
    {
      v7 = a1 + 2;
      v8 = a2 != 0 ? 8 : 0;
      if ( *v7 == 80 )
      {
        v7 = v6 + 2;
        v8 = a2 != 0 ? 4104 : 4096;
      }
      v9 = sub_180012D74(v7, (char **)&P, &v13);
      if ( !v9 )
      {
        for ( i = v13; *i == 32; ++i )
          ;
        if ( !*i )
        {
          *a4 = P;
          *a3 = v8;
          return v9;
        }
        v9 = -1073741811;
      }
      if ( P )
        ExFreePoolWithTag(P, 0);
      return v9;
    }
  }
  return 3221225485i64;
}

//----- (0000000180012D74) ----------------------------------------------------
__int64 __fastcall sub_180012D74(wchar_t *Str1, char **a2, wchar_t **a3)
{
  wchar_t *v5; // rbx
  unsigned int v6; // edi
  unsigned int v7; // r15d
  wchar_t *v8; // rax
  __int64 v10; // rax
  wchar_t *v11; // rax
  wchar_t *v12; // rcx
  int i; // r8d
  unsigned int v14; // r13d
  char *v15; // rax
  unsigned int v16; // r15d
  char *PoolWithTag; // rax
  unsigned int v18; // r12d
  ACCESS_MASK AccessMask; // r15d
  unsigned __int16 *j; // rbx
  unsigned __int16 v21; // ax
  unsigned __int16 *v22; // rax
  wchar_t *v23; // rbx
  __int64 v24; // rcx
  _WORD *v25; // rbx
  char *v26; // rax
  PSID Sid[3]; // [rsp+40h] [rbp-18h] BYREF
  _WORD *v28; // [rsp+A0h] [rbp+48h] BYREF
  int v29; // [rsp+A8h] [rbp+50h] BYREF
  int v30; // [rsp+B0h] [rbp+58h] BYREF
  unsigned __int16 *v31; // [rsp+B8h] [rbp+60h] BYREF

  *a2 = 0i64;
  v5 = Str1;
  v29 = 0;
  v6 = 0;
  v31 = 0i64;
  Sid[0] = 0i64;
  v7 = 0;
  v8 = wcschr(Str1, 0x3Au);
  *a3 = v8;
  if ( v8 == v5 )
    return 3221225485i64;
  if ( v8 )
  {
    v11 = v8 - 1;
  }
  else
  {
    v10 = -1i64;
    do
      ++v10;
    while ( v5[v10] );
    v11 = &v5[v10];
  }
  *a3 = v11;
  v12 = v5;
  for ( i = 0; v12 < v11; ++v12 )
  {
    if ( *v12 == 59 )
    {
      ++v7;
    }
    else if ( *v12 != 32 )
    {
      i = 1;
    }
  }
  v14 = v7 / 5;
  if ( v7 != 5 * (v7 / 5) || !v7 && i )
    return (unsigned int)-1073741811;
  if ( v14 )
  {
    v16 = 48 * v14 + 8;
    if ( v16 > 0xFFFF )
      v16 = 0xFFFF;
    PoolWithTag = (char *)ExAllocatePoolWithTag(PagedPool, v16, 0x6C416553u);
    *a2 = PoolWithTag;
    if ( PoolWithTag )
    {
      v30 = 8;
      sub_18000AEC0(PoolWithTag, 0, v16);
      v18 = 0;
      **a2 = 2;
      (*a2)[1] = 0;
      *((_WORD *)*a2 + 1) = v16;
      *((_WORD *)*a2 + 2) = 0;
      *((_WORD *)*a2 + 3) = 0;
      do
      {
        AccessMask = 0;
        LODWORD(v28) = 0;
        while ( *v5 == 32 )
          ++v5;
        if ( *v5 == 40 )
        {
          do
            ++v5;
          while ( *v5 == 32 );
        }
        if ( wcsnicmp(v5, L"A", 1ui64) )
          goto LABEL_67;
        for ( j = v5 + 2; *j == 32; ++j )
          ;
        if ( *j != 59 )
        {
LABEL_67:
          v6 = -1073741811;
LABEL_68:
          v26 = *a2;
LABEL_66:
          ExFreePoolWithTag(v26, 0);
          *a2 = 0i64;
          return v6;
        }
        do
          v21 = *++j;
        while ( *j == 32 );
        for ( ; v21 != 59; v21 = *v22 )
        {
          if ( v21 == 32 )
          {
            do
              ++j;
            while ( *j == 32 );
          }
          if ( (unsigned int)sub_1800131F4(j, &v29, &v31) )
          {
            AccessMask |= v29;
            v22 = v31;
            LODWORD(v28) = AccessMask;
          }
          else
          {
            sub_180013280(j, &v31, (unsigned int *)&v28);
            v22 = v31;
            if ( v31 == j )
              goto LABEL_67;
            AccessMask = (unsigned int)v28;
          }
          j = v22;
        }
        v23 = j + 1;
        v24 = 2i64;
        do
        {
          while ( *v23 == 32 )
            ++v23;
          if ( *v23 != 59 )
            v6 = -1073741811;
          ++v23;
          --v24;
        }
        while ( v24 );
        if ( v6 )
          goto LABEL_68;
        while ( *v23 == 32 )
          ++v23;
        v28 = 0i64;
        v6 = sub_18001312C(v23, Sid, &v28);
        if ( v6 )
          break;
        v25 = v28;
        if ( !v28 )
          goto LABEL_56;
        while ( *v25 == 32 )
          ++v25;
        if ( *v25 != 41 )
        {
LABEL_56:
          v6 = -1073741705;
          goto LABEL_68;
        }
        v5 = v25 + 1;
        if ( Sid[0] )
        {
          v6 = sub_180012B90(a2, &v30, 0i64, 0i64, AccessMask, v14 - v18, Sid[0]);
          if ( v6 )
            goto LABEL_68;
        }
        if ( *v5 == 40 )
          ++v5;
        ++v18;
      }
      while ( v18 < v14 );
      v26 = *a2;
      if ( v6 )
        goto LABEL_66;
      *((_WORD *)v26 + 1) = v30;
      return v6;
    }
    return (unsigned int)-1073741670;
  }
  v15 = (char *)ExAllocatePoolWithTag(PagedPool, 8ui64, 0x6C416553u);
  *a2 = v15;
  if ( !v15 )
    return (unsigned int)-1073741670;
  *(_QWORD *)v15 = 0i64;
  **a2 = 2;
  (*a2)[1] = 0;
  *((_WORD *)*a2 + 1) = 8;
  *((_WORD *)*a2 + 2) = 0;
  *((_WORD *)*a2 + 3) = 0;
  return v6;
}
// 180012F1D: conditional instruction was optimized away because r13d.4!=0
// 18001300E: conditional instruction was optimized away because edi.4==0
// 180012D74: using guessed type PSID var_18[3];

//----- (000000018001312C) ----------------------------------------------------
__int64 __fastcall sub_18001312C(wchar_t *Str1, _QWORD *a2, _QWORD *a3)
{
  __int64 v3; // rbx
  unsigned int *v4; // rbp
  unsigned int v5; // edi
  __int64 result; // rax

  v3 = 0i64;
  v4 = (unsigned int *)&unk_18000F0D4;
  v5 = 0;
  while ( wcsnicmp(Str1, (const wchar_t *)&unk_18000F0C0 + 12 * v5 + 6, *v4) )
  {
    ++v5;
    v4 += 6;
    if ( v5 >= 0xE )
    {
      result = 3221225587i64;
      goto LABEL_9;
    }
  }
  *a3 = &Str1[*((unsigned int *)&unk_18000F0C0 + 6 * v5 + 5)];
  if ( *((_DWORD *)&unk_18000F0C0 + 6 * v5 + 2) != 1 || IoIsWdmVersionAvailable(1u, 0x20u) )
    v3 = *(__int64 *)((char *)&SeExports->SeCreateTokenPrivilege + *((_QWORD *)&unk_18000F0C0 + 3 * v5));
  result = 0i64;
LABEL_9:
  *a2 = v3;
  return result;
}

//----- (00000001800131F4) ----------------------------------------------------
__int64 __fastcall sub_1800131F4(wchar_t *Str1, _DWORD *a2, _QWORD *a3)
{
  wchar_t **v4; // rdi
  unsigned int v7; // ebx
  __int64 result; // rax

  v4 = &off_18000F210;
  v7 = 0;
  while ( wcsnicmp(Str1, *v4, *((unsigned int *)v4 + 2)) )
  {
    ++v7;
    v4 += 2;
    if ( v7 >= 8 )
    {
      *a2 = 0;
      result = 0i64;
      *a3 = Str1;
      return result;
    }
  }
  result = 1i64;
  *a2 = *((_DWORD *)&off_18000F210 + 4 * v7 + 3);
  *a3 = &Str1[*((unsigned int *)&off_18000F210 + 4 * v7 + 2)];
  return result;
}
// 18000F210: using guessed type wchar_t *off_18000F210;

//----- (0000000180013280) ----------------------------------------------------
__int64 __fastcall sub_180013280(unsigned __int16 *a1, unsigned __int16 **a2, unsigned int *a3)
{
  unsigned __int16 v4; // r9
  int v5; // r10d
  unsigned __int16 *v6; // r11
  unsigned int v7; // r8d
  int v8; // eax
  __int64 result; // rax

  *a3 = 0;
  *a2 = a1;
  v4 = *a1;
  if ( *a1 == 48 )
  {
    if ( ((a1[1] - 88) & 0xFFDF) == 0 )
    {
      v4 = a1[2];
      a1 += 2;
      goto LABEL_4;
    }
  }
  else if ( (unsigned __int16)(v4 - 48) > 9u )
  {
LABEL_4:
    v5 = 16;
    v6 = a1;
    v7 = 0;
    if ( v4 )
      goto LABEL_5;
    return 0i64;
  }
  v5 = 10;
  v6 = a1;
  v7 = 0;
  do
  {
LABEL_5:
    if ( (unsigned __int16)(v4 - 48) > 9u )
    {
      if ( v5 != 16 )
        break;
      if ( (unsigned __int16)(v4 - 65) > 5u )
      {
        if ( (unsigned __int16)(v4 - 97) > 5u )
          break;
        v8 = v4 - 87;
      }
      else
      {
        v8 = v4 - 55;
      }
    }
    else
    {
      v8 = v4 - 48;
    }
    if ( v8 + v7 * v5 < v7 )
      return 0i64;
    ++a1;
    v7 = v8 + v7 * v5;
    v4 = *a1;
  }
  while ( *a1 );
  if ( a1 != v6 )
  {
    *a2 = a1;
    result = 1i64;
    *a3 = v7;
    return result;
  }
  return 0i64;
}

//----- (0000000180013384) ----------------------------------------------------
__int64 __fastcall sub_180013384(_WORD *a1, int a2, __int64 a3)
{
  __int64 (__fastcall *SystemRoutineAddress)(_WORD *, __int64, __int64); // rax
  __int64 result; // rax
  char *v8; // rdi
  int v9; // eax
  struct _ACL *v10; // rsi
  NTSTATUS v11; // ebx
  char *PoolWithTag; // rax
  int v13; // [rsp+20h] [rbp-50h] BYREF
  PACL Dacl; // [rsp+28h] [rbp-48h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+30h] [rbp-40h] BYREF
  __int128 SecurityDescriptor[2]; // [rsp+40h] [rbp-30h] BYREF
  __int64 v17; // [rsp+60h] [rbp-10h]
  ULONG BufferLength; // [rsp+A8h] [rbp+38h] BYREF

  DestinationString = 0i64;
  RtlInitUnicodeString(&DestinationString, L"SeConvertStringSecurityDescriptorToSecurityDescriptor");
  SystemRoutineAddress = (__int64 (__fastcall *)(_WORD *, __int64, __int64))MmGetSystemRoutineAddress(&DestinationString);
  if ( !SystemRoutineAddress )
  {
    v13 = 0;
    BufferLength = 0;
    Dacl = 0i64;
    *(_QWORD *)a3 = 0i64;
    v8 = 0i64;
    memset(SecurityDescriptor, 0, sizeof(SecurityDescriptor));
    v17 = 0i64;
    v9 = sub_180012C88(a1, a2, &v13, (PVOID *)&Dacl);
    v10 = Dacl;
    v11 = v9;
    if ( v9 >= 0 )
    {
      RtlCreateSecurityDescriptor(SecurityDescriptor, 1u);
      RtlSetDaclSecurityDescriptor(SecurityDescriptor, 1u, v10, 0);
      WORD1(SecurityDescriptor[0]) |= v13;
      RtlAbsoluteToSelfRelativeSD(SecurityDescriptor, 0i64, &BufferLength);
      PoolWithTag = (char *)ExAllocatePoolWithTag(PagedPool, BufferLength, 0x64536553u);
      v8 = PoolWithTag;
      if ( PoolWithTag )
      {
        sub_18000AEC0(PoolWithTag, 0, BufferLength);
        v11 = RtlAbsoluteToSelfRelativeSD(SecurityDescriptor, v8, &BufferLength);
        if ( v11 >= 0 )
        {
          ExFreePoolWithTag(v10, 0);
          *(_QWORD *)a3 = v8;
          return (unsigned int)v11;
        }
      }
      else
      {
        v11 = -1073741670;
      }
    }
    if ( v10 )
      ExFreePoolWithTag(v10, 0);
    if ( v8 )
      ExFreePoolWithTag(v8, 0);
    return (unsigned int)v11;
  }
  result = SystemRoutineAddress(a1, 1i64, a3);
  if ( (int)result >= 0 )
  {
    if ( a2 )
      *(_WORD *)(*(_QWORD *)a3 + 2i64) |= 8u;
  }
  return result;
}

//----- (0000000180013530) ----------------------------------------------------
__int64 __fastcall sub_180013530(
        void *a1,
        struct _UNICODE_STRING *a2,
        ACCESS_MASK a3,
        ULONG CreateOptions,
        void *a5,
        ULONG *a6,
        _QWORD *a7)
{
  NTSTATUS v7; // r8d
  void *v8; // rdx
  ULONG v9; // ecx
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+40h] [rbp-30h] BYREF
  ULONG Disposition; // [rsp+80h] [rbp+10h] BYREF
  void *KeyHandle; // [rsp+88h] [rbp+18h] BYREF

  *(&ObjectAttributes.Attributes + 1) = 0;
  Disposition = 0;
  KeyHandle = 0i64;
  ObjectAttributes.SecurityQualityOfService = 0i64;
  ObjectAttributes.SecurityDescriptor = a5;
  ObjectAttributes.RootDirectory = a1;
  ObjectAttributes.ObjectName = a2;
  *(_QWORD *)&ObjectAttributes.Length = 48i64;
  ObjectAttributes.Attributes = 576;
  v7 = ZwCreateKey(&KeyHandle, a3, &ObjectAttributes, 0, 0i64, CreateOptions, &Disposition);
  if ( v7 >= 0 )
  {
    v9 = Disposition;
    v8 = KeyHandle;
  }
  else
  {
    v8 = 0i64;
    v9 = 0;
  }
  *a7 = v8;
  if ( a6 )
    *a6 = v9;
  return (unsigned int)v7;
}

//----- (00000001800135D0) ----------------------------------------------------
__int64 __fastcall sub_1800135D0(void *a1, __int64 a2, ACCESS_MASK a3, ULONG a4, void *a5, ULONG *a6, _QWORD *a7)
{
  __int64 result; // rax
  struct _UNICODE_STRING v11; // [rsp+40h] [rbp-18h] BYREF

  v11 = 0i64;
  result = sub_18000A920((__int64)&v11, a2);
  if ( (int)result >= 0 )
    return sub_180013530(a1, &v11, a3, a4, a5, a6, a7);
  return result;
}
// 1800135D0: using guessed type struct _UNICODE_STRING var_18;

//----- (0000000180013648) ----------------------------------------------------
NTSTATUS __fastcall sub_180013648(void *a1, struct _UNICODE_STRING *a2, ACCESS_MASK a3, void **a4)
{
  NTSTATUS result; // eax
  struct _OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+20h] [rbp-30h] BYREF
  void *KeyHandle; // [rsp+60h] [rbp+10h] BYREF

  *(&ObjectAttributes.Attributes + 1) = 0;
  KeyHandle = 0i64;
  *a4 = 0i64;
  ObjectAttributes.RootDirectory = a1;
  ObjectAttributes.ObjectName = a2;
  *(_QWORD *)&ObjectAttributes.Length = 48i64;
  ObjectAttributes.Attributes = 576;
  *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0i64;
  result = ZwOpenKey(&KeyHandle, a3, &ObjectAttributes);
  if ( result >= 0 )
    *a4 = KeyHandle;
  return result;
}

//----- (00000001800136B8) ----------------------------------------------------
NTSTATUS __fastcall sub_1800136B8(void *a1, __int64 a2, ACCESS_MASK a3, void **a4)
{
  NTSTATUS result; // eax
  struct _UNICODE_STRING v8; // [rsp+20h] [rbp-18h] BYREF

  v8 = 0i64;
  result = sub_18000A920((__int64)&v8, a2);
  if ( result >= 0 )
    return sub_180013648(a1, &v8, a3, a4);
  return result;
}
// 1800136B8: using guessed type struct _UNICODE_STRING var_18;

//----- (000000018001370C) ----------------------------------------------------
NTSTATUS __fastcall sub_18001370C(void *a1, struct _UNICODE_STRING *a2, int a3, _DWORD *a4)
{
  NTSTATUS result; // eax
  ULONG v7; // [rsp+30h] [rbp-28h] BYREF
  _DWORD v8[4]; // [rsp+38h] [rbp-20h] BYREF

  v7 = 0;
  result = ZwQueryValueKey(a1, a2, KeyValuePartialInformation, v8, 0x10u, &v7);
  if ( result >= 0 )
  {
    if ( v8[1] == 4 )
      a3 = v8[3];
    else
      result = -1073741788;
  }
  *a4 = a3;
  return result;
}

//----- (000000018001378C) ----------------------------------------------------
__int64 __fastcall sub_18001378C(HANDLE KeyHandle, PUNICODE_STRING ValueName, int a3, int a4, char **a5)
{
  char **v5; // r14
  unsigned int v9; // eax
  ULONG Length; // edi
  char *PoolWithTag; // rax
  char *v12; // rbx
  NTSTATUS v13; // edi
  char *v15; // rax
  ULONG ResultLength; // [rsp+78h] [rbp+20h] BYREF

  v5 = a5;
  ResultLength = 0;
  *a5 = 0i64;
  v9 = (ValueName->Length + 31) & 0xFFFFFFF8;
  Length = v9 + a4;
  if ( v9 + a4 < v9 )
    return 3221225621i64;
  PoolWithTag = (char *)ExAllocatePoolWithTag((POOL_TYPE)512, Length, 0x62527050u);
  v12 = PoolWithTag;
  if ( !PoolWithTag )
    return 3221225626i64;
  sub_18000AEC0(PoolWithTag, 0, Length);
  v13 = ZwQueryValueKey(KeyHandle, ValueName, KeyValueFullInformation, v12, Length, &ResultLength);
  if ( v13 < 0 )
  {
    ExFreePoolWithTag(v12, 0);
    if ( v13 != -2147483643 && v13 != -1073741789 )
      return (unsigned int)v13;
    v15 = (char *)ExAllocatePoolWithTag((POOL_TYPE)512, ResultLength, 0x62527050u);
    v12 = v15;
    if ( v15 )
    {
      sub_18000AEC0(v15, 0, ResultLength);
      v13 = ZwQueryValueKey(KeyHandle, ValueName, KeyValueFullInformation, v12, ResultLength, &ResultLength);
      if ( v13 < 0 )
      {
LABEL_12:
        ExFreePoolWithTag(v12, 0);
        return (unsigned int)v13;
      }
      goto LABEL_9;
    }
    return 3221225626i64;
  }
LABEL_9:
  if ( a3 && *((_DWORD *)v12 + 1) != a3 )
  {
    v13 = -1073741788;
    goto LABEL_12;
  }
  *v5 = v12;
  return 0i64;
}

//----- (0000000180013918) ----------------------------------------------------
__int64 __fastcall sub_180013918(HANDLE KeyHandle, PUNICODE_STRING ValueName, unsigned __int16 *a3)
{
  unsigned __int64 v4; // rdx
  int v7; // ebx
  char *v8; // rdx
  struct _UNICODE_STRING UnicodeString; // [rsp+30h] [rbp-18h] BYREF

  v4 = *a3;
  UnicodeString = 0i64;
  if ( a3[1] - v4 < 2 )
  {
    v7 = sub_180013BE8((__int64)&UnicodeString, v4);
    if ( v7 >= 0 )
    {
      v8 = (char *)*((_QWORD *)a3 + 1);
      UnicodeString.Length = *a3;
      sub_18000AC00((_OWORD *)UnicodeString.Buffer, v8, UnicodeString.Length);
      UnicodeString.Buffer[(unsigned __int64)UnicodeString.Length >> 1] = 0;
      v7 = ZwSetValueKey(KeyHandle, ValueName, 0, 1u, UnicodeString.Buffer, UnicodeString.Length + 2);
      RtlFreeUnicodeString(&UnicodeString);
    }
  }
  else
  {
    *(_WORD *)(*((_QWORD *)a3 + 1) + 2 * (v4 >> 1)) = 0;
    return (unsigned int)ZwSetValueKey(KeyHandle, ValueName, 0, 1u, *((PVOID *)a3 + 1), *a3 + 2);
  }
  return (unsigned int)v7;
}

//----- (0000000180013A2C) ----------------------------------------------------
NTSTATUS __fastcall sub_180013A2C(void *a1, __int64 a2, int a3, _DWORD *a4)
{
  NTSTATUS result; // eax
  struct _UNICODE_STRING v8; // [rsp+20h] [rbp-18h] BYREF

  v8 = 0i64;
  result = sub_18000A920((__int64)&v8, a2);
  if ( result >= 0 )
    return sub_18001370C(a1, &v8, a3, a4);
  return result;
}
// 180013A2C: using guessed type struct _UNICODE_STRING var_18;

//----- (0000000180013A80) ----------------------------------------------------
__int64 __fastcall sub_180013A80(HANDLE KeyHandle, __int64 a2, int a3, int a4, char **a5)
{
  __int64 result; // rax
  struct _UNICODE_STRING ValueName; // [rsp+30h] [rbp-18h] BYREF

  ValueName = 0i64;
  result = sub_18000A920((__int64)&ValueName, a2);
  if ( (int)result >= 0 )
    return sub_18001378C(KeyHandle, &ValueName, a3, a4, a5);
  return result;
}

//----- (0000000180013ADC) ----------------------------------------------------
NTSTATUS __fastcall sub_180013ADC(HANDLE KeyHandle, __int64 a2, ULONG a3, void *a4, ULONG DataSize)
{
  NTSTATUS result; // eax
  struct _UNICODE_STRING ValueName; // [rsp+30h] [rbp-18h] BYREF

  ValueName = 0i64;
  result = sub_18000A920((__int64)&ValueName, a2);
  if ( result >= 0 )
    return ZwSetValueKey(KeyHandle, &ValueName, 0, a3, a4, DataSize);
  return result;
}

//----- (0000000180013B44) ----------------------------------------------------
__int64 __fastcall sub_180013B44(HANDLE KeyHandle, __int64 a2, unsigned __int16 *a3)
{
  __int64 result; // rax
  struct _UNICODE_STRING ValueName; // [rsp+20h] [rbp-18h] BYREF

  ValueName = 0i64;
  result = sub_18000A920((__int64)&ValueName, a2);
  if ( (int)result >= 0 )
    return sub_180013918(KeyHandle, &ValueName, a3);
  return result;
}

//----- (0000000180013B88) ----------------------------------------------------
__int64 __fastcall sub_180013B88(HANDLE KeyHandle, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  __int128 v6; // [rsp+20h] [rbp-28h] BYREF
  struct _UNICODE_STRING ValueName; // [rsp+30h] [rbp-18h] BYREF

  ValueName = 0i64;
  v6 = 0i64;
  result = sub_18000A920((__int64)&v6, a3);
  if ( (int)result >= 0 )
  {
    result = sub_18000A920((__int64)&ValueName, a2);
    if ( (int)result >= 0 )
      return sub_180013918(KeyHandle, &ValueName, (unsigned __int16 *)&v6);
  }
  return result;
}

//----- (0000000180013BE8) ----------------------------------------------------
__int64 __fastcall sub_180013BE8(__int64 a1, unsigned __int16 a2)
{
  __int64 v2; // rdi
  char *PoolWithTag; // rax

  v2 = a2;
  *(_WORD *)(a1 + 2) = a2 + 2;
  *(_WORD *)a1 = 0;
  PoolWithTag = (char *)ExAllocatePoolWithTag(PagedPool, a2 + 2i64, 0x63557050u);
  *(_QWORD *)(a1 + 8) = PoolWithTag;
  if ( !PoolWithTag )
    return 3221225626i64;
  sub_18000AEC0(PoolWithTag, 0, v2 + 2);
  return 0i64;
}

//----- (0000000180014000) ----------------------------------------------------
NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
  _security_init_cookie();
  return DriverInitialize(DriverObject, RegistryPath);
}

// nfuncs=185 queued=151 decompiled=151 lumina nreq=0 worse=0 better=0
// ALL OK, 151 function(s) have been successfully decompiled
